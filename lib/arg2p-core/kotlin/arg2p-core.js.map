{"version":3,"file":"arg2p-core.js","sources":["generated/_Collections.kt","kotlin/collections.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/Arg2p.kt","util/Standard.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/dsl/Arg2pScope.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/ArgLibrary.kt","util/Lazy.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/basic/Cache.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/basic/Context.kt","collections/Maps.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/basic/DynamicLoader.kt","generated/_Sequences.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/basic/EngineInterface.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/basic/FlagManager.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/extra/MetaInterpreter.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/extra/ModuleCalls.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/AbstractMode.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/builder/ArgumentationGraphBuilder.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/extension/AttackRestrictionHandler.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/extension/BpMetaGraphHandler.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/extension/DefeasiblePreferencesHandler.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/extension/GenericDefeasiblePreferencesHandler.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/extension/StrictPreferencesHandler.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/BpCompleteLabeller.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/BpLabeller.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/BpPartialLabeller.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/CompleteLabeller.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/GroundedLabeller.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/StatementLabeller.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/language/RuleParser.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/structured/StructuredMode.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/utils/Debug.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/utils/SuperiorityRelation.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/utils/Utils.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/mining/SolverMining.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/model/Argument.kt","collections/Collections.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/model/Attack.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/model/Graph.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/model/LabelledArgument.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/model/Rule.kt","../../../../../core/src/commonMain/kotlin/it/unibo/tuprolog/argumentation/core/model/Support.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/basic/EngineInterface.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/AbstractMode.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/builder/ArgumentationGraphBuilder.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/extension/AttackRestrictionHandler.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/extension/BpMetaGraphHandler.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/extension/DefeasiblePreferencesHandler.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/extension/GenericDefeasiblePreferencesHandler.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/extension/StrictPreferencesHandler.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/BpCompleteLabeller.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/BpLabeller.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/BpPartialLabeller.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/CompleteLabeller.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/GroundedLabeller.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/graph/labelling/StatementLabeller.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/language/RuleParser.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/AbstractMode.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/ArgumentationEngineInterface.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/ArgumentationGraph.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/AttackRestriction.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/Bp.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/BpGrounded.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/BpGroundedComplete.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/BpGroundedPartial.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/BpPartialComplete.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/Complete.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/Debug.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/DefPreferences.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/GenericDefPreferences.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/Grounded.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/Preferences.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/QueryMode.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/RuleTranslator.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/StatementLabelling.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/SuperiorityRelation.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/sources/Utils.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/structured/StructuredMode.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/utils/Debug.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/utils/SuperiorityRelation.kt","../../../../../core/src/jsMain/kotlin/it/unibo/tuprolog/argumentation/core/libs/utils/Utils.kt"],"sourcesContent":["/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the collection was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}","package it.unibo.tuprolog.argumentation.core\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.basic.Cache\r\nimport it.unibo.tuprolog.argumentation.core.libs.basic.Context\r\nimport it.unibo.tuprolog.argumentation.core.libs.basic.DynamicLoader\r\nimport it.unibo.tuprolog.argumentation.core.libs.basic.EngineInterface\r\nimport it.unibo.tuprolog.argumentation.core.libs.extra.MetaInterpreter\r\nimport it.unibo.tuprolog.argumentation.core.libs.extra.ModuleCalls\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.AbstractMode\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.builder.ArgumentationGraphBuilder\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.extension.AttackRestrictionHandler\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.extension.BpMetaGraphHandler\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.extension.DefeasiblePreferencesHandler\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.extension.GenericDefeasiblePreferencesHandler\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.extension.StrictPreferencesHandler\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.labelling.BpCompleteLabeller\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.labelling.BpLabeller\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.labelling.BpPartialLabeller\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.labelling.CompleteLabeller\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.labelling.GroundedLabeller\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.labelling.StatementLabeller\r\nimport it.unibo.tuprolog.argumentation.core.libs.language.RuleParser\r\nimport it.unibo.tuprolog.argumentation.core.libs.structured.StructuredMode\r\nimport it.unibo.tuprolog.argumentation.core.libs.utils.Debug\r\nimport it.unibo.tuprolog.argumentation.core.libs.utils.SuperiorityRelation\r\nimport it.unibo.tuprolog.argumentation.core.libs.utils.Utils\r\nimport it.unibo.tuprolog.core.operators.OperatorSet\r\nimport it.unibo.tuprolog.solve.library.Libraries\r\n\r\ninterface Arg2pSolver {\r\n    val loader: DynamicLoader\r\n    fun staticLibraries(): Iterable<ArgLibrary>\r\n    fun dynamicLibraries(): Iterable<ArgLibrary>\r\n\r\n    fun to2pLibraries() = Libraries.of(listOf(loader).plus(staticLibraries()).map { it.content() })\r\n    fun operators() = listOf(loader).plus(staticLibraries())\r\n        .map { it.theoryOperators }.reduce(OperatorSet::plus)\r\n\r\n    companion object {\r\n        fun of(staticLibs: Iterable<ArgLibrary>, dynamicLibs: Iterable<ArgLibrary>) =\r\n            object : Arg2pSolver {\r\n\r\n                override val loader = DynamicLoader(this)\r\n                override fun staticLibraries() = staticLibs\r\n                override fun dynamicLibraries() = dynamicLibs\r\n\r\n                init {\r\n                    operators().also { operators ->\r\n                        staticLibs.onEach { it.theoryOperators = operators }\r\n                        dynamicLibs.onEach { it.theoryOperators = operators }\r\n                    }\r\n                }\r\n            }\r\n    }\r\n}\r\n\r\nfun arg2p(): Arg2pSolver = Arg2pSolver.of(\r\n    listOf(EngineInterface, Context(), Cache()),\r\n    listOf(\r\n        Utils,\r\n        Debug,\r\n        RuleParser,\r\n        MetaInterpreter,\r\n        ModuleCalls,\r\n        ArgumentationGraphBuilder,\r\n        AttackRestrictionHandler,\r\n        BpMetaGraphHandler,\r\n        DefeasiblePreferencesHandler,\r\n        GenericDefeasiblePreferencesHandler,\r\n        StrictPreferencesHandler,\r\n        BpLabeller,\r\n        CompleteLabeller,\r\n        GroundedLabeller,\r\n        StatementLabeller,\r\n        AbstractMode,\r\n        StructuredMode,\r\n        SuperiorityRelation,\r\n        BpPartialLabeller,\r\n        BpCompleteLabeller\r\n    )\r\n)\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package it.unibo.tuprolog.argumentation.core.dsl\r\n\r\nimport it.unibo.tuprolog.dsl.PrologScope\r\nimport it.unibo.tuprolog.dsl.theory.PrologScopeWithTheories\r\nimport it.unibo.tuprolog.unify.Unificator\r\n\r\ninterface PrologWithArgumentation : PrologScopeWithTheories {\r\n    infix fun Any.call(other: Any) = structOf(\"::\", this.toTerm(), other.toTerm())\r\n}\r\n\r\ninternal class PrologWithArgumentationImpl :\r\n    PrologWithArgumentation, PrologScope by PrologScope.empty(), Unificator by Unificator.default\r\n\r\nfun <R> arg2pScope(function: PrologWithArgumentation.() -> R): R = PrologWithArgumentationImpl().function()\r\n","package it.unibo.tuprolog.argumentation.core.libs\r\n\r\nimport it.unibo.tuprolog.core.operators.OperatorSet\r\nimport it.unibo.tuprolog.solve.Signature\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\nimport it.unibo.tuprolog.solve.primitive.Primitive\r\nimport it.unibo.tuprolog.theory.Theory\r\nimport it.unibo.tuprolog.theory.parsing.parse\r\n\r\ninterface ArgLibrary {\r\n    val alias: String\r\n    val baseContent: AliasedLibrary\r\n    val baseFlags: Iterable<ArgsFlag<*, *>>\r\n    var theoryOperators: OperatorSet\r\n\r\n    fun flags() = baseFlags\r\n    fun content() = baseContent\r\n}\r\n\r\nabstract class BaseArgLibrary : ArgLibrary {\r\n    override var theoryOperators: OperatorSet = OperatorSet.DEFAULT\r\n        get() = OperatorSet.DEFAULT.plus(if (field == OperatorSet.DEFAULT) field else OperatorSet.DEFAULT.plus(field))\r\n}\r\n\r\ninterface UnionArgLibrary<T> : ArgLibrary where T : ArgLibrary {\r\n\r\n    val parentLibrary: T\r\n\r\n    override fun flags() = baseFlags.union(parentLibrary.flags())\r\n    override fun content() = Library.aliased(\r\n        alias = baseContent.alias,\r\n        theory = baseContent.theory.plus(parentLibrary.content().theory)\r\n    )\r\n}\r\n\r\ninterface RawPrologContent {\r\n    val prologTheory: Theory\r\n}\r\n\r\nabstract class LazyRawPrologContent : BaseArgLibrary(), RawPrologContent {\r\n    abstract val prologRawTheory: String\r\n    override val prologTheory: Theory by lazy {\r\n        Theory.parse(prologRawTheory, theoryOperators)\r\n    }\r\n}\r\n\r\ninterface Loadable {\r\n    fun identifier(): String\r\n}\r\n\r\ninterface ArgsFlag<T, G> {\r\n    fun predicate(): String\r\n    fun default(): T\r\n    fun values(): G\r\n}\r\n\r\ninterface PrimitiveWithSignature : Primitive {\r\n    val signature: Signature\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","package it.unibo.tuprolog.argumentation.core.libs.basic\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.BaseArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.PrimitiveWithSignature\r\nimport it.unibo.tuprolog.core.Term\r\nimport it.unibo.tuprolog.solve.ExecutionContext\r\nimport it.unibo.tuprolog.solve.MutableSolver\r\nimport it.unibo.tuprolog.solve.Signature\r\nimport it.unibo.tuprolog.solve.classic.classic\r\nimport it.unibo.tuprolog.solve.flags.Unknown\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\nimport it.unibo.tuprolog.solve.primitive.Solve\r\nimport it.unibo.tuprolog.theory.MutableTheory\r\nimport it.unibo.tuprolog.theory.Theory\r\n\r\nclass Cache : BaseArgLibrary() {\r\n\r\n    private val solver: MutableSolver =\r\n        MutableSolver.classic(staticKb = Theory.empty(), dynamicKb = MutableTheory.empty())\r\n            .also { it.setFlag(Unknown.name, Unknown.FAIL) }\r\n\r\n    inner class CacheAssert : PrimitiveWithSignature {\r\n\r\n        override val signature = Signature(\"cache_assert\", 1)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            val term: Term = request.arguments[0]\r\n            this@Cache.solver.assertA(term.castToStruct())\r\n            return sequenceOf(request.replyWith(true))\r\n        }\r\n    }\r\n\r\n    inner class CacheRetract : PrimitiveWithSignature {\r\n\r\n        override val signature = Signature(\"cache_retract\", 1)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            val term: Term = request.arguments[0]\r\n            this@Cache.solver.retractAll(term.castToStruct())\r\n            return sequenceOf(request.replyWith(true))\r\n        }\r\n    }\r\n\r\n    inner class CacheGet : PrimitiveWithSignature {\r\n\r\n        override val signature = Signature(\"cache_check\", 1)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            val term: Term = request.arguments[0]\r\n\r\n            return sequence {\r\n                yieldAll(\r\n                    this@Cache.solver.solve(term.castToStruct()).map {\r\n                        request.replyWith(it.substitution)\r\n                    }\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    override val alias = \"prolog.argumentation.cache\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() =\r\n            listOf(\r\n                CacheAssert(),\r\n                CacheRetract(),\r\n                CacheGet()\r\n            ).let { primitives ->\r\n                Library.aliased(\r\n                    alias = this.alias,\r\n                    primitives = primitives.associateBy { it.signature }\r\n                )\r\n            }\r\n\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.basic\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.BaseArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.PrimitiveWithSignature\r\nimport it.unibo.tuprolog.core.Numeric\r\nimport it.unibo.tuprolog.core.Substitution\r\nimport it.unibo.tuprolog.core.Term\r\nimport it.unibo.tuprolog.solve.ExecutionContext\r\nimport it.unibo.tuprolog.solve.MutableSolver\r\nimport it.unibo.tuprolog.solve.Signature\r\nimport it.unibo.tuprolog.solve.classic.classic\r\nimport it.unibo.tuprolog.solve.flags.Unknown\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\nimport it.unibo.tuprolog.solve.primitive.Solve\r\nimport it.unibo.tuprolog.theory.MutableTheory\r\nimport it.unibo.tuprolog.theory.Theory\r\n\r\nclass Context : BaseArgLibrary() {\r\n\r\n    private var nextSolver: Int = 1\r\n    private var selectedSolver: Int = 0\r\n    private val dynamicSolver: MutableMap<Int, MutableSolver> = mutableMapOf(\r\n        0 to\r\n            MutableSolver.classic(staticKb = Theory.empty(), dynamicKb = MutableTheory.empty())\r\n                .also { it.setFlag(Unknown.name, Unknown.FAIL) }\r\n    )\r\n\r\n    inner class DynamicCacheReset : PrimitiveWithSignature {\r\n\r\n        override val signature = Signature(\"context_reset\", 0)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            this@Context.selectedSolver = 0\r\n            this@Context.nextSolver = 1\r\n            this@Context.dynamicSolver.clear()\r\n            this@Context.dynamicSolver[0] =\r\n                MutableSolver.classic(staticKb = Theory.empty(), dynamicKb = MutableTheory.empty())\r\n                    .also { it.setFlag(Unknown.name, Unknown.FAIL) }\r\n            return sequenceOf(request.replyWith(true))\r\n        }\r\n    }\r\n\r\n    inner class DynamicCacheSelected : PrimitiveWithSignature {\r\n\r\n        override val signature = Signature(\"context_active\", 1)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            val term: Term = request.arguments[0]\r\n            return sequenceOf(request.replyWith(Substitution.of(term.castToVar(), Numeric.of(this@Context.selectedSolver))))\r\n        }\r\n    }\r\n\r\n    inner class DynamicCacheCheckout : PrimitiveWithSignature {\r\n\r\n        override val signature = Signature(\"context_checkout\", 1)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            val target: Int = request.arguments[0].castToInteger().intValue.toInt()\r\n            val result = dynamicSolver.keys.contains(target)\r\n            this@Context.selectedSolver = target\r\n            return sequenceOf(request.replyWith(result))\r\n        }\r\n    }\r\n\r\n    inner class DynamicCacheBranch : PrimitiveWithSignature {\r\n\r\n        override val signature = Signature(\"context_branch\", 2)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            val target: Int = request.arguments[0].castToInteger().intValue.toInt()\r\n            val result: Term = request.arguments[1]\r\n            this@Context.dynamicSolver[this@Context.nextSolver] =\r\n                MutableSolver.classic(staticKb = Theory.empty(), dynamicKb = MutableTheory.of(this@Context.dynamicSolver[target]!!.dynamicKb))\r\n                    .also { it.setFlag(Unknown.name, Unknown.FAIL) }\r\n            this@Context.selectedSolver = this@Context.nextSolver++\r\n            return sequenceOf(request.replyWith(Substitution.of(result.castToVar(), Numeric.of(this@Context.selectedSolver))))\r\n        }\r\n    }\r\n\r\n    inner class DynamicCacheAssert : PrimitiveWithSignature {\r\n\r\n        override val signature = Signature(\"context_assert\", 1)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            val term: Term = request.arguments[0]\r\n            this@Context.dynamicSolver[this@Context.selectedSolver]!!.assertA(term.castToStruct())\r\n            return sequenceOf(request.replyWith(true))\r\n        }\r\n    }\r\n\r\n    inner class DynamicCacheRetract : PrimitiveWithSignature {\r\n\r\n        override val signature = Signature(\"context_retract\", 1)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            val term: Term = request.arguments[0]\r\n            this@Context.dynamicSolver[this@Context.selectedSolver]!!.retractAll(term.castToStruct())\r\n            return sequenceOf(request.replyWith(true))\r\n        }\r\n    }\r\n\r\n    inner class DynamicCacheGet : PrimitiveWithSignature {\r\n\r\n        override val signature = Signature(\"context_check\", 1)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            val term: Term = request.arguments[0]\r\n\r\n            return sequence {\r\n                yieldAll(\r\n                    this@Context.dynamicSolver[this@Context.selectedSolver]!!.solve(term.castToStruct()).map {\r\n                        request.replyWith(it.substitution)\r\n                    }\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    inner class DynamicCacheGetIndexed : PrimitiveWithSignature {\r\n\r\n        override val signature = Signature(\"context_check\", 2)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            val index: Int = request.arguments[0].asNumeric()!!.intValue.toInt()\r\n            val term: Term = request.arguments[1]\r\n\r\n            return sequence {\r\n                yieldAll(\r\n                    this@Context.dynamicSolver[index]!!.solve(term.castToStruct()).map {\r\n                        request.replyWith(it.substitution)\r\n                    }\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    override val alias = \"prolog.argumentation.context\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() =\r\n            listOf(\r\n                DynamicCacheReset(),\r\n                DynamicCacheCheckout(),\r\n                DynamicCacheSelected(),\r\n                DynamicCacheBranch(),\r\n                DynamicCacheAssert(),\r\n                DynamicCacheRetract(),\r\n                DynamicCacheGet(),\r\n                DynamicCacheGetIndexed()\r\n            ).let { primitives ->\r\n                Library.aliased(\r\n                    alias = this.alias,\r\n                    primitives = primitives.associateBy { it.signature }\r\n                )\r\n            }\r\n\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","package it.unibo.tuprolog.argumentation.core.libs.basic\r\n\r\nimport it.unibo.tuprolog.argumentation.core.Arg2pSolver\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.BaseArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.core.Atom\r\nimport it.unibo.tuprolog.core.Struct\r\nimport it.unibo.tuprolog.core.Term\r\nimport it.unibo.tuprolog.core.operators.Operator\r\nimport it.unibo.tuprolog.core.operators.OperatorSet\r\nimport it.unibo.tuprolog.core.operators.Specifier\r\nimport it.unibo.tuprolog.dsl.prolog\r\nimport it.unibo.tuprolog.solve.ExecutionContext\r\nimport it.unibo.tuprolog.solve.MutableSolver\r\nimport it.unibo.tuprolog.solve.Signature\r\nimport it.unibo.tuprolog.solve.exception.error.DomainError\r\nimport it.unibo.tuprolog.solve.exception.error.TypeError\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Libraries\r\nimport it.unibo.tuprolog.solve.library.Library\r\nimport it.unibo.tuprolog.solve.primitive.Primitive\r\nimport it.unibo.tuprolog.solve.primitive.Solve\r\n\r\nclass DynamicLoader(private val solver: Arg2pSolver) : BaseArgLibrary() {\r\n\r\n    abstract inner class AbstractWithLib : Primitive {\r\n\r\n        abstract val signature: Signature\r\n        abstract fun execute(module: String, solver: MutableSolver)\r\n\r\n        override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n            val lib: Term = request.arguments[0]\r\n            val goal: Term = request.arguments[1]\r\n\r\n            if (lib !is Atom) {\r\n                throw TypeError.forGoal(\r\n                    request.context,\r\n                    request.signature,\r\n                    TypeError.Expected.LIST,\r\n                    lib\r\n                )\r\n            }\r\n\r\n            if (goal !is Struct) {\r\n                throw TypeError.forGoal(\r\n                    request.context,\r\n                    request.signature,\r\n                    TypeError.Expected.CALLABLE,\r\n                    goal\r\n                )\r\n            }\r\n\r\n            val solver = (\r\n                this@DynamicLoader.solver.dynamicLibraries().firstOrNull {\r\n                    (it as Loadable).identifier() == lib.toString()\r\n                } ?: throw DomainError.forGoal(\r\n                    request.context,\r\n                    request.signature,\r\n                    DomainError.Expected.of(\"Loadable Lib\"),\r\n                    lib\r\n                )\r\n                ).let { library ->\r\n                request.context.createMutableSolver(\r\n                    libraries = Libraries.of(\r\n                        request.context.libraries.libraries.filterNot { lib ->\r\n                            this@DynamicLoader.solver.dynamicLibraries()\r\n                                .map { it.alias }\r\n                                .contains(lib.alias)\r\n                        }\r\n                    ).plus(library.content()),\r\n                    staticKb = request.context.staticKb\r\n                )\r\n            }\r\n\r\n            execute(lib.toString(), solver)\r\n\r\n            return sequence {\r\n                yieldAll(\r\n                    solver.solve(goal).map {\r\n                        request.replyWith(it.substitution)\r\n                    }\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    inner class WithLib : AbstractWithLib() {\r\n        override val signature = Signature(\"::\", 2)\r\n        override fun execute(module: String, solver: MutableSolver) = Unit\r\n    }\r\n\r\n    inner class WithLibInNewContext : AbstractWithLib() {\r\n        override val signature = Signature(\":::\", 2)\r\n        override fun execute(module: String, solver: MutableSolver) =\r\n            prolog {\r\n                solver.solve(\"context_active\"(X))\r\n                    .filter { it.isYes }\r\n                    .forEach {\r\n                        solver.solve(\"context_branch\"(it.substitution[X]!!, `_`)).first()\r\n                    }\r\n            }\r\n    }\r\n\r\n    override val alias = \"prolog.argumentation.loader\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = listOf(WithLib(), WithLibInNewContext()).let {\r\n            Library.aliased(\r\n                alias = this.alias,\r\n                primitives = it.associateBy { prim -> prim.signature },\r\n                operatorSet = OperatorSet(\r\n                    Operator(\"::\", Specifier.XFX, 700),\r\n                    Operator(\":::\", Specifier.XFX, 700),\r\n                )\r\n            )\r\n        }\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    init {\r\n        theoryOperators = OperatorSet(\r\n            Operator(\"::\", Specifier.XFX, 700),\r\n            Operator(\":::\", Specifier.XFX, 700),\r\n        )\r\n    }\r\n}\r\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or `null` if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","package it.unibo.tuprolog.argumentation.core.libs.basic\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.core.operators.Operator\r\nimport it.unibo.tuprolog.core.operators.OperatorSet\r\nimport it.unibo.tuprolog.core.operators.Specifier\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class EngineInterfaceBase : ArgLibrary, LazyRawPrologContent() {\r\n\r\n    override val alias = \"prolog.argumentation.interface\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory,\r\n            operatorSet = OperatorSet(\r\n                Operator(\"=>\", Specifier.XFX, 1199),\r\n                Operator(\":=>\", Specifier.XFX, 1199),\r\n                Operator(\":->\", Specifier.XFX, 1199),\r\n                Operator(\":\", Specifier.XFX, 1001),\r\n                Operator(\":=\", Specifier.XFX, 1199)\r\n            )\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    init {\r\n        OperatorSet(\r\n            Operator(\"=>\", Specifier.XFX, 1199),\r\n            Operator(\":=>\", Specifier.XFX, 1199),\r\n            Operator(\":->\", Specifier.XFX, 1199),\r\n            Operator(\":\", Specifier.XFX, 1001),\r\n            Operator(\":=\", Specifier.XFX, 1199)\r\n        ).also { theoryOperators = it }\r\n    }\r\n}\r\n\r\nexpect object EngineInterface : EngineInterfaceBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.basic\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.BaseArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.extra.ModulesPath\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.ArgumentLabellingMode\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.GraphBuildMode\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.GraphExtension\r\nimport it.unibo.tuprolog.argumentation.core.libs.graph.StatementLabellingMode\r\nimport it.unibo.tuprolog.argumentation.core.libs.language.AutoTransposition\r\nimport it.unibo.tuprolog.argumentation.core.libs.language.PrologStrictCompatibility\r\nimport it.unibo.tuprolog.argumentation.core.libs.structured.QueryMode\r\nimport it.unibo.tuprolog.argumentation.core.libs.utils.OrderingComparator\r\nimport it.unibo.tuprolog.argumentation.core.libs.utils.OrderingPrinciple\r\nimport it.unibo.tuprolog.core.Clause\r\nimport it.unibo.tuprolog.core.Struct\r\nimport it.unibo.tuprolog.core.parsing.parse\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\nimport it.unibo.tuprolog.theory.MutableTheory\r\nimport kotlin.jvm.JvmStatic\r\n\r\ndata class FlagsBuilder(\r\n    var queryMode: Boolean = QueryMode.default(),\r\n    var autoTransposition: Boolean = AutoTransposition.default(),\r\n    var prologStrictCompatibility: Boolean = PrologStrictCompatibility.default(),\r\n    var graphBuildMode: String = GraphBuildMode.default(),\r\n    var argumentLabellingMode: String = ArgumentLabellingMode.default(),\r\n    var statementLabellingMode: String = StatementLabellingMode.default(),\r\n    var orderingPrinciple: String = OrderingPrinciple.default(),\r\n    var orderingComparator: String = OrderingComparator.default(),\r\n    var modulesPath: String = ModulesPath.default(),\r\n    var graphExtensions: Iterable<String> = GraphExtension.default()\r\n) {\r\n\r\n    companion object {\r\n        @JvmStatic\r\n        fun setupSolver(target: FlagsBuilder) =\r\n            MutableTheory.empty().also { kb ->\r\n                target.graphExtensions.forEach { kb.assertA(Clause.parse(\"${GraphExtension.predicate()}(X) :- X = $it\")) }\r\n                if (target.queryMode) kb.assertA(Struct.parse(QueryMode.predicate()))\r\n                if (target.autoTransposition) kb.assertA(Struct.parse(AutoTransposition.predicate()))\r\n                if (target.prologStrictCompatibility) kb.assertA(Struct.parse(PrologStrictCompatibility.predicate()))\r\n                kb.assertA(Struct.parse(\"${GraphBuildMode.predicate()}(${target.graphBuildMode})\"))\r\n                kb.assertA(Struct.parse(\"${ArgumentLabellingMode.predicate()}(${target.argumentLabellingMode})\"))\r\n                kb.assertA(Struct.parse(\"${StatementLabellingMode.predicate()}(${target.statementLabellingMode})\"))\r\n                kb.assertA(Struct.parse(\"${OrderingPrinciple.predicate()}(${target.orderingPrinciple})\"))\r\n                kb.assertA(Struct.parse(\"${OrderingComparator.predicate()}(${target.orderingComparator})\"))\r\n                kb.assertA(Struct.parse(\"${ModulesPath.predicate()}(${target.modulesPath})\"))\r\n            }\r\n    }\r\n\r\n    fun queryMode(queryMode: Boolean) = apply { this.queryMode = queryMode }\r\n    fun prologStrictCompatibility(prologStrictCompatibility: Boolean) =\r\n        apply { this.prologStrictCompatibility = prologStrictCompatibility }\r\n    fun graphBuildMode(graphBuildMode: String) = apply { this.graphBuildMode = graphBuildMode }\r\n    fun argumentLabellingMode(argumentLabellingMode: String) =\r\n        apply { this.argumentLabellingMode = argumentLabellingMode }\r\n    fun statementLabellingMode(statementLabellingMode: String) =\r\n        apply { this.statementLabellingMode = statementLabellingMode }\r\n\r\n    fun orderingPrinciple(orderingPrinciple: String) = apply { this.orderingPrinciple = orderingPrinciple }\r\n    fun orderingComparator(orderingComparator: String) = apply { this.orderingComparator = orderingComparator }\r\n    fun modulesPath(modulesPath: String) = apply { this.modulesPath = modulesPath }\r\n    fun graphExtensions(graphExtensions: Iterable<String>) = apply { this.graphExtensions = graphExtensions }\r\n\r\n    fun create() = object : BaseArgLibrary() {\r\n\r\n        override val alias = \"prolog.argumentation.flags\"\r\n\r\n        override val baseContent: AliasedLibrary\r\n            get() = Library.aliased(\r\n                alias = this.alias,\r\n                theory = setupSolver(this@FlagsBuilder),\r\n            )\r\n        override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n            get() = emptyList()\r\n    }\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.extra\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.BaseArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\nimport it.unibo.tuprolog.theory.Theory\r\nimport it.unibo.tuprolog.theory.parsing.parse\r\n\r\nobject MetaInterpreter : BaseArgLibrary(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.meta.crossjustice\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = Theory.parse(\r\n                \"\"\"\r\n                % with_facts_and_length/3\r\n                with_facts_and_length(X, Y, L) :-\r\n                    solve(X, R),\r\n                    recover_facts(R, Y),\r\n                    length(Y, L).\r\n        \r\n                % lenght/2\r\n        \r\n                length([], 0).\r\n                length([_|T], X) :- length(T, Y), X is Y + 1.\r\n        \r\n                % recover_facts/2\r\n        \r\n                recover_facts([], []) :- !.\r\n                recover_facts([H|T], C) :-\r\n                    is_list(H), !,\r\n                    recover_facts(T, TC),\r\n                    recover_facts(H, HC),\r\n                    append(TC, HC, C).\r\n                recover_facts([H|T], C) :-\r\n                    \\+ is_list(H),\r\n                    recover_facts(T, TC),\r\n                    evaluate(H, HC),\r\n                    append(TC, HC, C).\r\n        \r\n                evaluate(user_fact(X), [X]) :- !.\r\n                evaluate(_, []) :- !.\r\n        \r\n                % solve/2\r\n        \r\n                solve((A,B), Result) :- !,\r\n                    solve(A, ARes),\r\n                    solve(B, BRes),\r\n                    append(ARes, BRes, Result).\r\n        \r\n                solve((A;B), Result) :- !,\r\n                    solve(A, Result);\r\n                    solve(B, Result).\r\n        \r\n                solve(member(A, B), [system_predicate]) :- !,\r\n                    call(member(A, B)).\r\n        \r\n                solve(\\+(A), [not(A)]) :- !,\r\n                    call(\\+(A)).\r\n        \r\n                solve((A)\\=(B), [doNotUnify(A, B)]) :- !,\r\n                    call((A)\\=(B)).\r\n        \r\n                solve(A, [system_predicate]) :-\r\n                    catch(clause(A, _), B, true),\r\n                    \\+ var(B), !,\r\n                    call(A).\r\n        \r\n                solve(A, [A]) :-\r\n                    \\+ clause(A, B), !,\r\n                    call(A).\r\n        \r\n                solve(A, [A|[Res]]) :-\r\n                    clause(A, B),\r\n                    solve(B, Res).\r\n        \r\n                % is_list/1\r\n        \r\n                is_list(X) :- var(X), !, fail.\r\n                is_list([]).\r\n                is_list([_|T]) :- is_list(T).\r\n                \"\"\".trimIndent()\r\n            )\r\n        )\r\n\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"interpreter\"\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.extra\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.BaseArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.core.List\r\nimport it.unibo.tuprolog.core.Struct\r\nimport it.unibo.tuprolog.core.Term\r\nimport it.unibo.tuprolog.dsl.theory.prolog\r\nimport it.unibo.tuprolog.solve.ExecutionContext\r\nimport it.unibo.tuprolog.solve.Signature\r\nimport it.unibo.tuprolog.solve.Solution\r\nimport it.unibo.tuprolog.solve.Solver\r\nimport it.unibo.tuprolog.solve.classic.classic\r\nimport it.unibo.tuprolog.solve.exception.error.TypeError\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\nimport it.unibo.tuprolog.solve.primitive.Primitive\r\nimport it.unibo.tuprolog.solve.primitive.Solve\r\n\r\nobject ModuleCalls : BaseArgLibrary(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.modularity\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            primitives = mapOf(\r\n                ModuleCall.signature to ModuleCall\r\n            )\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = listOf(ModulesPath)\r\n\r\n    override fun identifier(): String = \"module\"\r\n}\r\n\r\nobject ModulesPath : ArgsFlag<String, Unit> {\r\n    override fun predicate(): String = \"modulesPath\"\r\n    override fun default(): String = \"none\"\r\n    override fun values() {}\r\n}\r\n\r\nobject ModuleCall : Primitive {\r\n\r\n    val signature = Signature(\"call_module\", 2)\r\n\r\n    override fun solve(request: Solve.Request<ExecutionContext>): Sequence<Solve.Response> {\r\n        val modules: Term = request.arguments[0]\r\n        val goal: Term = request.arguments[1]\r\n\r\n        if (modules !is List) {\r\n            throw TypeError.forGoal(\r\n                request.context,\r\n                request.signature,\r\n                TypeError.Expected.LIST,\r\n                modules\r\n            )\r\n        }\r\n\r\n        if (goal !is Struct) {\r\n            throw TypeError.forGoal(\r\n                request.context,\r\n                request.signature,\r\n                TypeError.Expected.CALLABLE,\r\n                goal\r\n            )\r\n        }\r\n\r\n        val solver = getCleanSolver(request.context, mineModulesPath(request.context), modules.toList().map { it.toString() })\r\n        return sequence {\r\n            yieldAll(\r\n                solver.solve(goal).map {\r\n                    when (it) {\r\n                        is Solution.Yes -> request.replySuccess(it.substitution)\r\n                        else -> request.replyFail()\r\n                    }\r\n                }\r\n            )\r\n        }\r\n    }\r\n\r\n    private fun mineModulesPath(context: ExecutionContext): String {\r\n        return prolog {\r\n            Solver.classic(libraries = context.libraries)\r\n                .solve(\"modulesPath\"(X))\r\n                .map { if (it is Solution.Yes) it.substitution[X].toString() else \"\" }\r\n                .first()\r\n        }\r\n    }\r\n\r\n    private fun getCleanSolver(context: ExecutionContext, modulesPath: String, modules: Iterable<String>): Solver {\r\n        val module = { mod: String -> if (mod.contains(\".pl\")) mod else \"${modulesPath.removeSurrounding(\"'\")}/$mod.pl\" }\r\n        return prolog {\r\n            Solver.classic(\r\n                libraries = context.libraries\r\n            ).also { solver: Solver -> modules.forEach { solver.solve(\"consult\"(module(it))).toList() } }\r\n        }\r\n    }\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class AbstractModeBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.abstract\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = listOf(GraphExtension, ArgumentLabellingMode, StatementLabellingMode, GraphBuildMode)\r\n\r\n    override fun identifier(): String = \"abstract\"\r\n}\r\n\r\nexpect object AbstractMode : AbstractModeBase\r\n\r\nobject GraphExtension : ArgsFlag<Iterable<String>, Iterable<String>> {\r\n    override fun predicate(): String = \"graphExtension\"\r\n    override fun default(): Iterable<String> = listOf(\"standardPref\")\r\n    override fun values(): Iterable<String> = listOf(\"rebutRestriction\", \"bp\", \"standardPref\", \"defeasiblePref\", \"defeasibleAllPref\")\r\n}\r\n\r\nobject ArgumentLabellingMode : ArgsFlag<String, Iterable<String>> {\r\n    override fun predicate(): String = \"argumentLabellingMode\"\r\n    override fun default(): String = \"grounded\"\r\n    override fun values(): Iterable<String> = listOf(\r\n        \"grounded\",\r\n        \"complete\",\r\n        \"bp_grounded\",\r\n        \"bp_grounded_partial\",\r\n        \"bp_grounded_complete\"\r\n    )\r\n}\r\n\r\nobject StatementLabellingMode : ArgsFlag<String, Iterable<String>> {\r\n    override fun predicate(): String = \"statementLabellingMode\"\r\n    override fun default(): String = \"statement\"\r\n    override fun values(): Iterable<String> = listOf(\"statement\")\r\n}\r\n\r\nobject GraphBuildMode : ArgsFlag<String, Iterable<String>> {\r\n    override fun predicate(): String = \"graphBuildMode\"\r\n    override fun default(): String = \"standard_af\"\r\n    override fun values(): Iterable<String> = listOf(\"standard_af\")\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.builder\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class ArgumentationGraphBuilderBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"standard_af\"\r\n}\r\n\r\nexpect object ArgumentationGraphBuilder : ArgumentationGraphBuilderBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.extension\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class AttackRestrictionHandlerBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph.rebutrestriction\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"rebutRestriction\"\r\n}\r\n\r\nexpect object AttackRestrictionHandler : AttackRestrictionHandlerBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.extension\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class BpMetaGraphHandlerBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph.meta.bp\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"bp\"\r\n}\r\n\r\nexpect object BpMetaGraphHandler : BpMetaGraphHandlerBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.extension\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class DefeasiblePreferencesHandlerBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph.preferences.defeasible\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"defeasiblePref\"\r\n}\r\n\r\nexpect object DefeasiblePreferencesHandler : DefeasiblePreferencesHandlerBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.extension\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class GenericDefeasiblePreferencesHandlerBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph.preferences.defeasible.generic\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"defeasibleAllPref\"\r\n}\r\n\r\nexpect object GenericDefeasiblePreferencesHandler : GenericDefeasiblePreferencesHandlerBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.extension\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class StrictPreferencesHandlerBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph.preferences.strict\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"standardPref\"\r\n}\r\n\r\nexpect object StrictPreferencesHandler : StrictPreferencesHandlerBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class BpCompleteLabellerBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph.labelling.bpgroundedcomplete\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"bp_grounded_complete\"\r\n}\r\n\r\nexpect object BpCompleteLabeller : BpCompleteLabellerBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class BpLabellerBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph.labelling.bpgrounded\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"bp_grounded\"\r\n}\r\n\r\nexpect object BpLabeller : BpLabellerBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class BpPartialLabellerBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph.labelling.bpgroundedpartial\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"bp_grounded_partial\"\r\n}\r\n\r\nexpect object BpPartialLabeller : BpPartialLabellerBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class CompleteLabellerBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph.labelling.complete\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"complete\"\r\n}\r\n\r\nexpect object CompleteLabeller : CompleteLabellerBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class GroundedLabellerBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph.labelling.grounded\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"grounded\"\r\n}\r\n\r\nexpect object GroundedLabeller : GroundedLabellerBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class StatementLabellerBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.graph.labelling.statement\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"statement\"\r\n}\r\n\r\nexpect object StatementLabeller : StatementLabellerBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.language\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.core.Clause\r\nimport it.unibo.tuprolog.core.Struct\r\nimport it.unibo.tuprolog.core.Substitution\r\nimport it.unibo.tuprolog.core.Term\r\nimport it.unibo.tuprolog.core.Var\r\nimport it.unibo.tuprolog.core.parsing.parse\r\nimport it.unibo.tuprolog.core.toTerm\r\nimport it.unibo.tuprolog.dsl.theory.PrologScopeWithTheories\r\nimport it.unibo.tuprolog.dsl.theory.prolog\r\nimport it.unibo.tuprolog.solve.ExecutionContext\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\nimport it.unibo.tuprolog.solve.primitive.PrimitiveWrapper.Companion.ensuringArgumentIsVariable\r\nimport it.unibo.tuprolog.solve.primitive.Solve\r\nimport it.unibo.tuprolog.solve.primitive.UnaryPredicate\r\nimport kotlin.random.Random\r\n\r\nsealed class RuleParserBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.parser\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            primitives = mapOf(\r\n                StrictRules::descriptionPair.get(),\r\n                Axioms::descriptionPair.get(),\r\n                Bps::descriptionPair.get(),\r\n                Premises::descriptionPair.get(),\r\n                DefeasibleRules::descriptionPair.get()\r\n            ),\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = listOf(AutoTransposition, PrologStrictCompatibility)\r\n\r\n    override fun identifier() = \"parser\"\r\n}\r\n\r\nexpect object RuleParser : RuleParserBase\r\n\r\nobject AutoTransposition : ArgsFlag<Boolean, Unit> {\r\n    override fun predicate(): String = \"autoTransposition\"\r\n    override fun default(): Boolean = false\r\n    override fun values() {}\r\n}\r\n\r\nobject PrologStrictCompatibility : ArgsFlag<Boolean, Unit> {\r\n    override fun predicate(): String = \"prologStrictCompatibility\"\r\n    override fun default(): Boolean = true\r\n    override fun values() {}\r\n}\r\n\r\nobject ConversionUtils {\r\n    fun modifiers(target: Clause, context: Solve.Request<ExecutionContext>): Term =\r\n        prolog {\r\n            target.bodyItems.map { term ->\r\n                if (term.isStruct && term.asStruct()?.functor == \"\\\\+\") \"~\"(term.asStruct()!!.args[0])\r\n                else if (context.solve(\"clause\"(term, Var.ANONYMOUS_NAME)).first().isHalt) \"prolog\"(term)\r\n                else term\r\n            }.let { if (it.count() > 1) tupleOf(it) else it.first() }\r\n        }\r\n\r\n    fun commonMap(\r\n        context: Solve.Request<ExecutionContext>,\r\n        first: Term,\r\n        force: Boolean = false,\r\n        mapper: (Iterable<Clause>, PrologScopeWithTheories) -> Term\r\n    ): Sequence<Substitution> {\r\n        context.ensuringArgumentIsVariable(0)\r\n        return prolog {\r\n            sequenceOf(\r\n                Substitution.of(\r\n                    first.castToVar(),\r\n                    if (force || context.solve(Struct.parse(\"prologStrictCompatibility\")).first().isYes) {\r\n                        mapper(context.context.staticKb.clauses, this)\r\n                    } else {\r\n                        emptyList\r\n                    }\r\n                )\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\nobject StrictRules : UnaryPredicate.WithoutSideEffects<ExecutionContext>(\"prologStrictRules\") {\r\n    override fun Solve.Request<ExecutionContext>.computeAllSubstitutions(first: Term): Sequence<Substitution> =\r\n        ConversionUtils.commonMap(this, first) { clauses, prologScope ->\r\n            clauses.filter { !it.isFact }\r\n                .map {\r\n                    prologScope.listOf(\r\n                        \"rule_${Random.nextInt(0, Int.MAX_VALUE)}\",\r\n                        ConversionUtils.modifiers(it, this@computeAllSubstitutions),\r\n                        it.head!!\r\n                    )\r\n                }.toTerm()\r\n        }\r\n}\r\n\r\nobject Axioms : UnaryPredicate.WithoutSideEffects<ExecutionContext>(\"prologAxioms\") {\r\n    override fun Solve.Request<ExecutionContext>.computeAllSubstitutions(first: Term): Sequence<Substitution> =\r\n        ConversionUtils.commonMap(this, first) { clauses, prologScope ->\r\n            clauses\r\n                .filter { it.isFact && !listOf(\":->\", \"->\", \"=>\", \":=>\", \":\", \":=\", \",\").contains(it.head!!.functor) }\r\n                .map {\r\n                    prologScope.listOf(\r\n                        \"rule_${Random.nextInt(0, Int.MAX_VALUE)}\",\r\n                        it.head!!\r\n                    )\r\n                }.toTerm()\r\n        }\r\n}\r\n\r\nobject Premises : UnaryPredicate.WithoutSideEffects<ExecutionContext>(\"prologPremises\") {\r\n    override fun Solve.Request<ExecutionContext>.computeAllSubstitutions(first: Term): Sequence<Substitution> =\r\n        ConversionUtils.commonMap(this, first) { clauses, prologScope ->\r\n            clauses\r\n                .filter { it.isFact && it.head!!.functor == \":=\" && it.head!!.arity == 1 }\r\n                .map {\r\n                    prologScope.listOf(\r\n                        \"rule_${Random.nextInt(0, Int.MAX_VALUE)}\",\r\n                        it.head!!.args[0]\r\n                    )\r\n                }.toTerm()\r\n        }\r\n}\r\n\r\nobject DefeasibleRules : UnaryPredicate.WithoutSideEffects<ExecutionContext>(\"prologDefeasibleRules\") {\r\n    override fun Solve.Request<ExecutionContext>.computeAllSubstitutions(first: Term): Sequence<Substitution> =\r\n        ConversionUtils.commonMap(this, first) { clauses, prologScope ->\r\n            clauses\r\n                .filter {\r\n                    it.isFact && (\r\n                        it.head!!.functor == \":=\" ||\r\n                            (it.head!!.functor == \",\" && it.head!!.args[0].asStruct()?.functor == \":=\")\r\n                        ) &&\r\n                        it.head!!.arity == 2\r\n                }\r\n                .map { clause ->\r\n                    if (clause.head!!.functor == \",\") {\r\n                        val head = clause.head!!.args[0].asStruct()\r\n                        val term = (\r\n                            listOf(head!![1]) + (\r\n                                clause.head!!.args[1].asTuple()?.args\r\n                                    ?: listOf(clause.head!!.args[1])\r\n                                )\r\n                            ).toTypedArray()\r\n                        prologScope.clauseOf(head[0].asStruct(), *term)\r\n                    } else {\r\n                        prologScope.clauseOf(clause.head!!.args[0].asStruct(), clause.head!!.args[1])\r\n                    }.let {\r\n                        prologScope.listOf(\r\n                            \"rule_${Random.nextInt(0, Int.MAX_VALUE)}\",\r\n                            ConversionUtils.modifiers(it, this@computeAllSubstitutions),\r\n                            it.head!!\r\n                        )\r\n                    }\r\n                }.toTerm()\r\n        }\r\n}\r\n\r\nobject Bps : UnaryPredicate.WithoutSideEffects<ExecutionContext>(\"bpsNew\") {\r\n    override fun Solve.Request<ExecutionContext>.computeAllSubstitutions(first: Term): Sequence<Substitution> =\r\n        ConversionUtils.commonMap(this, first, true) { clauses, prologScope ->\r\n            clauses\r\n                .filter { it.isFact && it.head?.functor == \"bp\" }\r\n                .map {\r\n                    prologScope.listOf(\r\n                        \"bps\",\r\n                        it.head!!\r\n                    )\r\n                }.toTerm()\r\n        }\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.structured\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class StructuredModeBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.structured\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = listOf(QueryMode)\r\n\r\n    override fun identifier(): String = \"structured\"\r\n}\r\n\r\nexpect object StructuredMode : StructuredModeBase\r\n\r\nobject QueryMode : ArgsFlag<Boolean, Unit> {\r\n    override fun predicate(): String = \"queryMode\"\r\n    override fun default(): Boolean = true\r\n    override fun values() {}\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.utils\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class DebugBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.debug\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier() = \"debug\"\r\n}\r\n\r\nexpect object Debug : DebugBase\r\n","package it.unibo.tuprolog.argumentation.core.libs.utils\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class SuperiorityRelationBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.superiority\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = listOf(OrderingPrinciple, OrderingComparator)\r\n\r\n    override fun identifier(): String = \"superiority\"\r\n}\r\n\r\nexpect object SuperiorityRelation : SuperiorityRelationBase\r\n\r\nobject OrderingPrinciple : ArgsFlag<String, Iterable<String>> {\r\n    override fun predicate(): String = \"orderingPrinciple\"\r\n    override fun default(): String = \"last\"\r\n    override fun values(): Iterable<String> = listOf(\"last\", \"weakest\")\r\n}\r\n\r\nobject OrderingComparator : ArgsFlag<String, Iterable<String>> {\r\n    override fun predicate(): String = \"orderingComparator\"\r\n    override fun default(): String = \"elitist\"\r\n    override fun values(): Iterable<String> = listOf(\"elitist\", \"democrat\", \"normal\")\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.utils\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgLibrary\r\nimport it.unibo.tuprolog.argumentation.core.libs.ArgsFlag\r\nimport it.unibo.tuprolog.argumentation.core.libs.LazyRawPrologContent\r\nimport it.unibo.tuprolog.argumentation.core.libs.Loadable\r\nimport it.unibo.tuprolog.solve.library.AliasedLibrary\r\nimport it.unibo.tuprolog.solve.library.Library\r\n\r\nsealed class UtilsBase : ArgLibrary, LazyRawPrologContent(), Loadable {\r\n\r\n    override val alias = \"prolog.argumentation.utils\"\r\n\r\n    override val baseContent: AliasedLibrary\r\n        get() = Library.aliased(\r\n            alias = this.alias,\r\n            theory = this.prologTheory\r\n        )\r\n    override val baseFlags: Iterable<ArgsFlag<*, *>>\r\n        get() = emptyList()\r\n\r\n    override fun identifier(): String = \"utils\"\r\n}\r\n\r\nexpect object Utils : UtilsBase\r\n","package it.unibo.tuprolog.argumentation.core.mining\r\n\r\nimport it.unibo.tuprolog.argumentation.core.model.Argument\r\nimport it.unibo.tuprolog.argumentation.core.model.Attack\r\nimport it.unibo.tuprolog.argumentation.core.model.Graph\r\nimport it.unibo.tuprolog.argumentation.core.model.LabelledArgument\r\nimport it.unibo.tuprolog.argumentation.core.model.Support\r\nimport it.unibo.tuprolog.dsl.prolog\r\nimport it.unibo.tuprolog.solve.Solver\r\nimport it.unibo.tuprolog.unify.Unificator\r\nimport kotlin.js.JsName\r\n\r\n@JsName(\"mineGraph\")\r\nfun Solver.graph(context: Int) =\r\n    this.arguments(context).let {\r\n        Graph.of(\r\n            this.labels(context, it),\r\n            this.attacks(context, it),\r\n            this.supports(context, it)\r\n        )\r\n    }\r\n\r\n@JsName(\"mineArguments\")\r\nfun Solver.arguments(context: Int): List<Argument> =\r\n    prolog {\r\n        this@arguments.solve(\"context_check\"(context, \"argument\"(X)))\r\n            .filter { it.isYes }\r\n            .map { it.substitution[X]!! }\r\n            .map { solution ->\r\n                Argument.of(solution)\r\n            }\r\n            .sortedWith(compareBy({ it.supports.size }, { it.rules.size }, { it.conclusion }, { it.topRule }))\r\n            .mapIndexed { index, arg ->\r\n                arg.identifier = \"A$index\"\r\n                arg\r\n            }\r\n    }.toList()\r\n\r\n@JsName(\"mineAttacks\")\r\nfun Solver.attacks(context: Int, arguments: List<Argument>): List<Attack> {\r\n    if (arguments.isEmpty()) return emptyList()\r\n    return prolog {\r\n        this@attacks.solve(\"context_check\"(context, \"attack\"(`_`, X, Y, `_`)))\r\n            .filter { it.isYes }\r\n            .map { solution ->\r\n                Attack(\r\n                    arguments.first { Unificator.default.match(it.termRepresentation(), solution.substitution[X]!!) },\r\n                    arguments.first { Unificator.default.match(it.termRepresentation(), solution.substitution[Y]!!) }\r\n                )\r\n            }\r\n    }.toList()\r\n}\r\n\r\n@JsName(\"mineSupports\")\r\nfun Solver.supports(context: Int, arguments: List<Argument>): List<Support> =\r\n    arguments.flatMap { argument ->\r\n        prolog {\r\n            this@supports.solve(\"context_check\"(context, \"support\"(X, argument.termRepresentation())))\r\n                .filter { it.isYes }\r\n                .map { it.substitution[X]!! }\r\n                .map { solution ->\r\n                    Support(\r\n                        arguments.first { Unificator.default.match(it.termRepresentation(), solution) },\r\n                        argument\r\n                    ).also {\r\n                        argument.supports.add(it.supporter)\r\n                    }\r\n                }.toList()\r\n        }\r\n    }\r\n\r\n@JsName(\"mineLabels\")\r\nfun Solver.labels(context: Int, arguments: List<Argument>): List<LabelledArgument> {\r\n    fun checkFunctor(functor: String, argument: Argument) =\r\n        prolog {\r\n            this@labels.solve(\"context_check\"(context, functor(argument.termRepresentation())))\r\n                .filter { it.isYes }\r\n                .map { functor }\r\n                .firstOrNull()\r\n        }\r\n\r\n    return arguments.map {\r\n        LabelledArgument(\r\n            it,\r\n            checkFunctor(\"in\", it)\r\n                ?: checkFunctor(\"out\", it) ?: \"und\"\r\n        )\r\n    }\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.model\r\n\r\nimport it.unibo.tuprolog.core.Cons\r\nimport it.unibo.tuprolog.core.Struct\r\nimport it.unibo.tuprolog.core.Term\r\nimport it.unibo.tuprolog.core.parsing.parse\r\n\r\ndata class Argument(\r\n    val rules: List<RuleIdentifier>,\r\n    val topRule: RuleIdentifier,\r\n    val conclusion: Literal,\r\n    val groundings: List<Literal> = emptyList(),\r\n    val defeasibleRules: List<RuleIdentifier> = emptyList(),\r\n    val defeasiblePremises: List<RuleIdentifier> = emptyList(),\r\n    val lastDefeasibleRules: List<RuleIdentifier> = emptyList()\r\n) {\r\n\r\n    var identifier: String = \"\"\r\n    val supports: MutableList<Argument> = mutableListOf()\r\n\r\n    val descriptor: String\r\n        get() = \"$identifier : \" + (\r\n            if (topRule == \"none\") rules.firstOrNull() ?: \"\" else {\r\n                supports.map { it.identifier }.plus(topRule)\r\n                    .reduce { a: String, b: String -> \"$a,$b\" }\r\n            }\r\n            ) + \" : \" + conclusion\r\n\r\n    fun termRepresentation(): Term = Struct.parse(\"[$rules, $topRule, $conclusion, $groundings, [$lastDefeasibleRules, $defeasibleRules, $defeasiblePremises]]\")\r\n\r\n    override fun toString(): String {\r\n        return \"argument(${this.termRepresentation()})\"\r\n    }\r\n\r\n    fun toTerm(): Term {\r\n        return Struct.parse(this.toString())\r\n    }\r\n\r\n    companion object {\r\n\r\n        fun of(term: Term): Argument {\r\n            fun termAsList(t: Term?): List<Term> = (t as Cons).toList()\r\n\r\n            fun toStringList(argument: List<Term>, target: Int): List<String> {\r\n                return (\r\n                    if (argument[target].isEmptyList) emptyList()\r\n                    else (argument[target] as Cons).toList()\r\n                    ).map { x -> x.toString() }\r\n            }\r\n\r\n            fun argRules(argument: List<Term>): List<String> = toStringList(argument, 0)\r\n\r\n            fun argTopRule(argument: List<Term>): String = argument[1].toString()\r\n\r\n            fun argConclusion(argument: List<Term>): String = argument[2].toString()\r\n\r\n            fun argGroundings(argument: List<Term>): List<String> = toStringList(argument, 3)\r\n\r\n            fun argDefeasibleRules(argument: List<Term>): List<String> =\r\n                toStringList(termAsList(argument[4]), 1)\r\n\r\n            fun argDefeasiblePremises(argument: List<Term>): List<String> =\r\n                toStringList(termAsList(argument[4]), 2)\r\n\r\n            fun argLastDefeasibleRules(argument: List<Term>): List<String> =\r\n                toStringList(termAsList(argument[4]), 0)\r\n\r\n            return termAsList(term).let {\r\n                Argument(\r\n                    argRules(it),\r\n                    argTopRule(it),\r\n                    argConclusion(it),\r\n                    argGroundings(it),\r\n                    argDefeasibleRules(it),\r\n                    argDefeasiblePremises(it),\r\n                    argLastDefeasibleRules(it)\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","package it.unibo.tuprolog.argumentation.core.model\r\n\r\nimport it.unibo.tuprolog.core.Struct\r\nimport it.unibo.tuprolog.core.Term\r\nimport it.unibo.tuprolog.core.parsing.parse\r\n\r\ndata class Attack(val attacker: Argument, val target: Argument, val type: AttackType? = null, val on: Argument? = null) {\r\n    override fun toString(): String {\r\n        return \"attack(${type ?: \"none\"}, ${attacker.termRepresentation()}, ${target.termRepresentation()}, ${on?.termRepresentation() ?: \"none\"})\"\r\n    }\r\n\r\n    fun toTerm(): Term {\r\n        return Struct.parse(this.toString())\r\n    }\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.model\r\n\r\ndata class Graph(val arguments: List<Argument>, val attacks: List<Attack>, val supports: List<Support>) {\r\n\r\n    var labellings: List<LabelledArgument> = emptyList()\r\n\r\n    companion object {\r\n        fun of(labellings: List<LabelledArgument>, attacks: List<Attack>, supports: List<Support>) =\r\n            Graph(labellings.map { it.argument }, attacks, supports).also {\r\n                it.labellings = labellings\r\n            }\r\n    }\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.model\r\n\r\nimport it.unibo.tuprolog.core.Struct\r\nimport it.unibo.tuprolog.core.Term\r\nimport it.unibo.tuprolog.core.parsing.parse\r\n\r\ndata class LabelledArgument(val argument: Argument, val label: Label) {\r\n    override fun toString(): String {\r\n        return \"$label(${argument.termRepresentation()})\"\r\n    }\r\n\r\n    fun toTerm(): Term {\r\n        return Struct.parse(this.toString())\r\n    }\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.model\r\n\r\nimport it.unibo.tuprolog.core.Struct\r\nimport it.unibo.tuprolog.core.parsing.parse\r\n\r\ninterface ArgItem {\r\n    val identifier: RuleIdentifier\r\n    val conclusion: Term\r\n\r\n    fun toTerm(): it.unibo.tuprolog.core.Term {\r\n        return Struct.parse(this.toString())\r\n    }\r\n}\r\n\r\ndata class Premise(override val identifier: RuleIdentifier, override val conclusion: Term, val strict: Boolean = false) : ArgItem {\r\n    override fun toString(): String {\r\n        return \"premise([$identifier, $conclusion])\"\r\n    }\r\n}\r\n\r\ndata class Rule(override val identifier: RuleIdentifier, val premises: List<Term>, override val conclusion: Term, val strict: Boolean = false) : ArgItem {\r\n    override fun toString(): String {\r\n        return \"rule([$identifier, $premises, $conclusion])\"\r\n    }\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.model\r\n\r\nimport it.unibo.tuprolog.core.Struct\r\nimport it.unibo.tuprolog.core.Term\r\nimport it.unibo.tuprolog.core.parsing.parse\r\n\r\ndata class Support(val supporter: Argument, val supported: Argument) {\r\n    override fun toString(): String {\r\n        return \"support(${supporter.termRepresentation()}, ${supported.termRepresentation()})\"\r\n    }\r\n\r\n    fun toTerm(): Term {\r\n        return Struct.parse(this.toString())\r\n    }\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.basic\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.sources.ArgumentationEngineInterface\r\n\r\nactual object EngineInterface : EngineInterfaceBase() {\r\n    override val prologRawTheory: String\r\n        get() = ArgumentationEngineInterface.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph\r\n\r\nactual object AbstractMode : AbstractModeBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.AbstractMode.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.builder\r\n\r\nactual object ArgumentationGraphBuilder : ArgumentationGraphBuilderBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.ArgumentationGraph.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.extension\r\n\r\nactual object AttackRestrictionHandler : AttackRestrictionHandlerBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.AttackRestriction.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.extension\r\n\r\nactual object BpMetaGraphHandler : BpMetaGraphHandlerBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.Bp.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.extension\r\n\r\nactual object DefeasiblePreferencesHandler : DefeasiblePreferencesHandlerBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.DefPreferences.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.extension\r\n\r\nactual object GenericDefeasiblePreferencesHandler : GenericDefeasiblePreferencesHandlerBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.GenericDefPreferences.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.extension\r\n\r\nactual object StrictPreferencesHandler : StrictPreferencesHandlerBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.Preferences.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nactual object BpCompleteLabeller : BpCompleteLabellerBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.BpGroundedComplete.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nactual object BpLabeller : BpLabellerBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.BpGrounded.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nactual object BpPartialLabeller : BpPartialLabellerBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.BpGroundedPartial.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nactual object CompleteLabeller : CompleteLabellerBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.Complete.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nactual object GroundedLabeller : GroundedLabellerBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.Grounded.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.graph.labelling\r\n\r\nactual object StatementLabeller : StatementLabellerBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.StatementLabelling.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.language\r\n\r\nimport it.unibo.tuprolog.argumentation.core.libs.sources.RuleTranslator\r\n\r\nactual object RuleParser : RuleParserBase() {\r\n    override val prologRawTheory: String\r\n        get() = RuleTranslator.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject AbstractMode {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    computeGlobalAcceptance :-\r\n        buildGraph,\r\n        modifyGraph,\r\n        buildArgumentLabelling,\r\n        buildStatementLabelling.\r\n    computeGlobalAcceptance([Arguments, Attacks, Supports], [ArgsIn, ArgsOut, ArgsUnd], [StatIn, StatOut, StatUnd]) :-\r\n        computeGlobalAcceptance,\r\n        utils::recoverGraph(Arguments, Attacks, Supports),\r\n        utils::recoverArgumentLabelling(ArgsIn, ArgsOut, ArgsUnd),\r\n        utils::recoverStatementLabelling(StatIn, StatOut, StatUnd).\r\n    buildGraph :-\r\n        graphBuildMode(X),\r\n        X:::buildArgumentationGraph.\r\n    modifyGraph :-\r\n        findall(X, graphExtension(X), Ext),\r\n        modifyGraph(Ext).\r\n    modifyGraph([]).\r\n    modifyGraph([X|Ext]) :-\r\n        modifyGraph(Ext),\r\n        X:::modifyArgumentationGraph.\r\n    buildArgumentLabelling :-\r\n        argumentLabellingMode(X),\r\n        X:::argumentLabelling.\r\n    buildStatementLabelling :-\r\n        statementLabellingMode(X),\r\n        X:::statementLabelling.\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject ArgumentationEngineInterface {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    argTuProlog.\r\n    buildLabelSets([StatIn, StatOut, StatUnd], [ArgsIn, ArgsOut, ArgsUnd]) :-\r\n        context_reset,\r\n        parser:::convertAllRules(_),\r\n        abstract::computeGlobalAcceptance(_, [ArgsIn, ArgsOut, ArgsUnd], [StatIn, StatOut, StatUnd]).\r\n    buildLabelSets(StatIn, StatOut, StatUnd) :-\r\n        buildLabelSets([StatIn, StatOut, StatUnd], _).\r\n    buildLabelSets :-\r\n        context_reset,\r\n        parser:::convertAllRules(ArgRules),\r\n        debug::printTheory(ArgRules),\r\n        abstract::computeGlobalAcceptance([Arguments, Attacks, Supports], [ArgsIn, ArgsOut, ArgsUnd], [StatIn, StatOut, StatUnd]),\r\n        debug::printArgumentationGraph(Arguments, Attacks, Supports),\r\n        debug::printArgumentLabelling([ArgsIn, ArgsOut, ArgsUnd]),\r\n        debug::printStatementLabelling([StatIn, StatOut, StatUnd]).\r\n    answerQuery(Goal, Yes, No, Und) :-\r\n        context_reset,\r\n        parser:::convertAllRules(_),\r\n        structured:::computeStatementAcceptance(Goal, Yes, No, Und).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject ArgumentationGraph {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    buildArgumentationGraph :-\r\n        buildArguments,\r\n        buildAttacks.\r\n    buildArguments :-\r\n    \tbuildArgumentsFromPremises,\r\n    \tfindall([RuleID, RuleBody, RuleHead], context_check(rule([RuleID, RuleBody, RuleHead])), Rules),\r\n    \tbuildArgumentsFromRules(Rules, Rules, n).\r\n    buildArgumentsFromPremises :-\r\n        findall(\r\n            _,\r\n            (\r\n                context_check(premise([PremiseID, Premise])),\r\n                checkStrict(PremiseID, DefPrem),\r\n                ground(Premise),\r\n                context_assert(argument([[PremiseID], none, Premise, [], [[], [], DefPrem]]))\r\n            ),\r\n            _\r\n        ).\r\n    buildArgumentsFromRules(Rules, [], n).\r\n    buildArgumentsFromRules(Rules, [], y) :- buildArgumentsFromRules(Rules, Rules, n).\r\n    buildArgumentsFromRules(Rules, [H|T], _) :-\r\n        copy_term(H, HH),\r\n        buildArgumentsFromRule(HH),\r\n        buildArgumentsFromRules(Rules, T, y), !.\r\n    buildArgumentsFromRules(Rules, [_|T], X) :-\r\n        buildArgumentsFromRules(Rules, T, X).\r\n    buildArgumentsFromRule([RuleID, RuleBody, RuleHead]) :-\r\n    \truleBodyIsSupported(RuleBody, [], [], SupportRules, ArgSupports),\r\n    \t\\+ member(RuleID, SupportRules),\r\n    \tground(RuleHead),\r\n    \tutils::sort([RuleID|SupportRules], SortedPremises),\r\n    \t\\+ context_check(argument([SortedPremises, RuleID, RuleHead, RuleBody, _])),\r\n    \tbuildArgumentInfo(ArgSupports, RuleID, Info),\r\n        NewArgument = [SortedPremises, RuleID, RuleHead, RuleBody, Info],\r\n    \tcontext_assert(argument(NewArgument)),\r\n    \tsupports(NewArgument, ArgSupports).\r\n    supports(Argument, Supports) :-\r\n        findall(_, (\r\n            member(S, Supports),\r\n            context_assert(support(S, Argument))\r\n        ), _).\r\n    checkStrict(Id, [Id]) :- \\+ context_check(strict(Id)).\r\n    checkStrict(Id, []) :- context_check(strict(Id)).\r\n    buildArgumentInfo(Supports, RuleId, [LastDefRules, DefRules, DefPrem]) :-\r\n        defeasibleRules(RuleId, Supports, DefRules),\r\n        ordinaryPremises(Supports, DefPrem),\r\n        lastDefeasibleRules(Supports, RuleId, LastDefRules).\r\n    ordinaryPremises(Supports, DefPrem) :-\r\n        findall(Def, member([_, _, _, _, [_, _, Def]], Supports), Prem),\r\n        utils::appendLists(Prem, TempPrem),\r\n        utils::sortDistinct(TempPrem, DefPrem).\r\n    defeasibleRules(RuleId, Supports, DefRules) :-\r\n    \tfindall(Def, member([_, _, _, _, [_, Def, _]], Supports), UnsortedRules),\r\n    \tcheckStrict(RuleId, DefRule),\r\n    \tutils::appendLists([DefRule|UnsortedRules], TempRules),\r\n    \tutils::sortDistinct(TempRules, DefRules).\r\n    lastDefeasibleRules(_, TopRule, [TopRule]) :-\r\n        TopRule \\== none, \\+ context_check(strict(TopRule)).\r\n    lastDefeasibleRules(Supports, TopRule, LastRules) :-\r\n    \tcontext_check(strict(TopRule)),\r\n    \tfindall(Def, member([_, _, _, _, [Def, _, _]], Supports), Res),\r\n    \tutils::appendLists(Res, TempLastRules),\r\n    \tutils::sortDistinct(TempLastRules, LastRules).\r\n    ruleBodyIsSupported([], ResultPremises, ResultSupports, ResultPremises, ResultSupports).\r\n    ruleBodyIsSupported([ [unless, _] | Others], Premises, Supports, ResultPremises, ResultSupports) :-\r\n    \truleBodyIsSupported(Others, Premises, Supports, ResultPremises, ResultSupports).\r\n    ruleBodyIsSupported([ [prolog(Check)] | Others], Premises, Supports, ResultPremises, ResultSupports) :-\r\n    \t(callable(Check) -> call(Check); Check),\r\n    \truleBodyIsSupported(Others, Premises, Supports, ResultPremises, ResultSupports).\r\n    ruleBodyIsSupported([Statement|Others], Premises, Supports, ResultPremises, ResultSupports) :-\r\n        context_check(argument([ArgumentID, RuleID, Statement, Body, Info])),\r\n    \tappend(ArgumentID, Premises, NewPremises),\r\n    \truleBodyIsSupported(Others, NewPremises, [[ArgumentID, RuleID, Statement, Body, Info]|Supports], ResultPremises, ResultSupports).\r\n    buildAttacks :-\r\n        findall(X, context_check(argument(X)), Args),\r\n    \tbuildDirectAttacks(Args),\r\n    \tbuildTransitiveAttacks.\r\n    buildDirectAttacks([]).\r\n    buildDirectAttacks([H|T]) :-\r\n        findall(_, buildDirectAttack(H), _),\r\n        buildDirectAttacks(T).\r\n    buildDirectAttack(A) :-\r\n    \tcontext_check(argument(B)),\r\n    \tA \\== B,\r\n        attacks(T, A, B),\r\n    \t\\+ context_check(attack(T, A, B, B)),\r\n    \tcontext_assert(attack(T, A, B, B)).\r\n    buildTransitiveAttacks :-\r\n    \tcontext_check(attack(T, A, B, D)),\r\n    \tcontext_check(support(B, C)),\r\n    \t\\+ context_check(attack(T, A, C, D)), !,\r\n    \tcontext_assert(attack(T, A, C, D)),\r\n        buildTransitiveAttacks.\r\n    buildTransitiveAttacks.\r\n    attacks(rebut, A, B) :- rebuts(A, B), !.\r\n    attacks(contrary_rebut, A, B) :- contraryRebuts(A, B), !.\r\n    attacks(undermine, A, B) :- undermines(A, B), !.\r\n    attacks(contrary_undermine, A, B) :- contraryUndermines(A, B), !.\r\n    attacks(undercut, A, B) :- undercuts(A, B), !.\r\n    rebuts([IDPremisesA, RuleA, RuleHeadA, _, _], [IDPremisesB, RuleB, RuleHeadB, _, Info]) :-\r\n    \tRuleB \\== none,\r\n        Info \\== [[], [], []],\r\n    \tconflict(RuleHeadA, RuleHeadB).\r\n    contraryRebuts([IDPremisesA, RuleA, RuleHeadA, _, _], [IDPremisesB, RuleB, RuleHeadB, Body, Info]) :-\r\n    \tRuleA \\== none,\r\n    \tRuleB \\== none,\r\n    \tmember([unless, RuleHeadA], Body).\r\n    undermines([IDPremisesA, RuleA, RuleHeadA, _, _], [[IDPremiseB], none, RuleHeadB, _, Info]) :-\r\n    \tInfo \\== [[], [], []],\r\n    \tconflict(RuleHeadA, RuleHeadB).\r\n    contraryUndermines([IDPremisesA, none, RuleHeadA, _, _], [IDPremisesB, RuleB, RuleHeadB, Body, Info]) :-\r\n    \tRuleB \\== none,\r\n    \tmember([unless, RuleHeadA], Body).\r\n    undercuts([_, _, [undercut(RuleB)], _, _], [_, RuleB, _, _, [[RuleB], _, _]]).\r\n    conflict( [Atom], [neg, Atom]).\r\n    conflict( [neg, Atom], [Atom]).\r\n    conflict( [obl, [Atom]],  [obl, [neg, Atom]]).\r\n    conflict( [obl, [neg, Atom]],  [obl, [Atom]]).\r\n    conflict( [obl, Lit],  [neg, obl, Lit]).\r\n    conflict( [neg, obl, Lit],  [obl, Lit]).\r\n    conflict( [perm, [Atom]],  [obl, [neg, Atom]]).\r\n    conflict( [obl, [neg, Atom]],  [perm, [Atom]]).\r\n    conflict( [perm, [neg, Atom]],  [obl, [Atom]]).\r\n    conflict( [obl, [Atom]],  [perm, [neg, Atom]]).\r\n    conflict([bp, Atom], [neg, bp, Atom]).\r\n    conflict([neg, bp, Atom], [bp, Atom]).\r\n    conflict([sup(X, Y)],  [sup(Y, X)]).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject AttackRestriction {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    modifyArgumentationGraph :-\r\n        findall(_, (\r\n            context_check(attack(T, A, B, C)),\r\n            checkRebutRestriction(T, A, B, C)\r\n        ), _).\r\n    checkRebutRestriction(T, A, B, C) :-\r\n        \\+ rebutRestriction(T, A, B, C),\r\n        context_retract(attack(T, A, B, C)).\r\n    rebutRestriction(rebut, _, _, C) :- restrict(C).\r\n    rebutRestriction(undermine, _, _, C).\r\n    rebutRestriction(contrary_rebut, _, _, _).\r\n    rebutRestriction(contrary_undermine, _, _, _).\r\n    rebutRestriction(undercut, _, _, _).\r\n    restrict([_, TopRule, _, _, [[TopRule], _, _]]) :- TopRule \\== none.\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject Bp {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    modifyArgumentationGraph :-\r\n        findall(([Rules, Top, [bp, Checked], G, I], [Z, P, Y, GG, II]), (\r\n            context_check(argument([Rules, Top, [bp, Checked], G, I])),\r\n            member(Y, Checked),\r\n            context_check(argument([Z, P, Y, GG, II]))\r\n        ), TemplateBpPairs),\r\n        checkBpArguments(TemplateBpPairs).\r\n    checkBpArguments([]).\r\n    checkBpArguments(TemplateBpPairs) :-\r\n        createBpArguments(TemplateBpPairs, BpPairs),\r\n        createBpAttacks(BpPairs).\r\n    createBpArguments([], []).\r\n    createBpArguments([(Original, [Z, P, Y, B, I])|Others], [(Conflict, [Z, P, Y, B, I])|BpPairs]) :-\r\n        Conflict = [[artificial|Z], artificial, [neg, burdmet(Y)], [], [[artificial], [artificial], []]],\r\n        context_assert(argument(Conflict)),\r\n        context_assert(support(Original, Conflict)),\r\n        liftBpAttacks(Original, Conflict),\r\n        createBpArguments(Others, BpPairs).\r\n    liftBpAttacks(Template, BpArg) :-\r\n        findall(_, (\r\n            context_check(attack(T, A, Template, O)),\r\n            context_assert(attack(T, A, BpArg, O))\r\n        ), _).\r\n    createBpAttacks(BpPairs) :-\r\n        generateBpsEvaluationChain(BpPairs, OrderedBpPairs),\r\n        evaluateBurdenedArgs(OrderedBpPairs).\r\n    generateBpsEvaluationChain([], []).\r\n    generateBpsEvaluationChain([BpPair|BpPairs], OrderedBpPairs) :-\r\n        generateBpsEvaluationChain(BpPairs, TempOrderedBpPairs),\r\n        insertBpPair(BpPair, TempOrderedBpPairs, OrderedBpPairs).\r\n    insertBpPair(BpPair, [], [BpPair]).\r\n    insertBpPair((Bp, Burdened), [(BpL, BurdenedL)|Others], [(BpL, BurdenedL)|Return]) :-\r\n        bp_grounded::argumentChain(BurdenedL, Burdened),\r\n        insertBpPair((Bp, Burdened), Others, Return), !.\r\n    insertBpPair((Bp, Burdened), [(BpL, BurdenedL)|Others], [(Bp, Burdened)|[(BpL, BurdenedL)|Others]]).\r\n    evaluateBurdenedArgs([]).\r\n    evaluateBurdenedArgs([(Bp, Burdened)|Others]) :-\r\n        context_active(X),\r\n        grounded:::argumentLabelling,\r\n        statusToAttack((Bp, Burdened), Attack),\r\n        context_checkout(X),\r\n        context_assert(Attack),\r\n        evaluateBurdenedArgs(Others).\r\n    statusToAttack((Bp, Burdened), attack(bprebut, Burdened, Bp, Bp)) :-\r\n        context_check(in(Burdened)).\r\n    statusToAttack((Bp, Burdened), attack(bprebut, Bp, Burdened, Burdened)) :-\r\n        \\+ context_check(in(Burdened)).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject BpGrounded {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    argumentLabelling :-\r\n        reifyBurdenOfProofs,\r\n        filterBpDefeats,\r\n        findall(X, context_check(argument(X)), Arguments),\r\n        bpLabelling(Arguments).\r\n    bpLabelling(Arguments) :-\r\n        member(A, Arguments),\r\n        grounded::allAttacksOUT(A), !,\r\n        context_assert(in(A)),\r\n        utils::subtract(Arguments, [A], NewArguments),\r\n        bpLabelling(NewArguments).\r\n    bpLabelling(Arguments) :-\r\n        member(A, Arguments),\r\n        \\+ isArgumentInBurdenOfProof(A),\r\n        grounded::oneAttackIN(A), !,\r\n        context_assert(out(A)),\r\n        utils::subtract(Arguments, [A], NewArguments),\r\n        bpLabelling(NewArguments).\r\n    bpLabelling(Arguments) :-\r\n        context_active(Branch),\r\n        mostGroundedBpUnd(Arguments, A),\r\n        context_branch(Branch, _),\r\n        context_assert(out(A)),\r\n        utils::subtract(Arguments, [A], NewArguments),\r\n        bpLabelling(NewArguments).\r\n    bpLabelling(Args) :-\r\n        notLabelled(Args),\r\n        findall(_, (member(A, Args), context_assert(und(A))), _).\r\n    notLabelled(Args) :-\r\n        \\+ (\r\n            member(A, Args),\r\n            (\r\n                context_check(in(A));\r\n                context_check(out(A));\r\n                context_check(und(A))\r\n            )\r\n        ).\r\n    isInBurdenOfProof(Conclusion) :-\r\n        context_check(reifiedBp(Literals)),\r\n        member(Conclusion, Literals), !.\r\n    isArgumentInBurdenOfProof([_, _, Conclusion, _, _]) :-\r\n        isInBurdenOfProof(Conclusion).\r\n    filterBpDefeats :-\r\n        findall(_, (\r\n            context_check(attack(T, A, B, C)),\r\n            filterBpDefeat(T, A, B, C)\r\n        ), _).\r\n    filterBpDefeat(T, B, A, C) :-\r\n        (T = rebut; T = undermine),\r\n        isArgumentInBurdenOfProof(B),\r\n        \\+ superiority::superiorArgument(B, C),\r\n        context_retract(attack(T, B, A, C)).\r\n    mostGroundedBpUnd(Arguments, Arg) :-\r\n        member(Arg, Arguments),\r\n        isArgumentInBurdenOfProof(Arg),\r\n        \\+ (\r\n            member(A, Arguments), Arg \\= A,\r\n            isArgumentInBurdenOfProof(A),\r\n            argumentChain(A, Arg)\r\n        ).\r\n    argumentChain(A, A) :- !.\r\n    argumentChain(A, B) :-\r\n        A \\== B,\r\n        context_check(attack(_, A, C, _)),\r\n        argumentChain(C, B).\r\n    reifyBurdenOfProofs :-\r\n        findall(_, (\r\n            context_check(abstractBp(AbstractBp)),\r\n            fillTemplate(AbstractBp, R),\r\n            \\+ context_check(reifiedBp(R)),\r\n            context_assert(reifiedBp(R))\r\n        ), _).\r\n    /*\r\n        Fill the template (first parameter) using arguments conclusions\r\n    */\r\n    fillTemplate([], []).\r\n    fillTemplate([H|T], [H|R]) :-\r\n        context_check(argument([_, _, Conclusion, _, _])),\r\n        fillTemplate(T, R).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject BpGroundedComplete {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    argumentLabelling :-\r\n        bp_grounded::reifyBurdenOfProofs,\r\n        findall(X, context_check(argument(X)), Arguments),\r\n        completeBpLabelling(go, Arguments).\r\n    completeBpLabelling(stop, _).\r\n    completeBpLabelling(go, Arguments) :-\r\n        bp_grounded_partial::partialBpLabelling(Arguments), !,\r\n        findall(X, (context_check(und(X)), context_retract(und(X))), NewArgs),\r\n        grounded::groundedLabelling(NewArgs),\r\n        findall(X, context_check(und(X)), LeftArguments),\r\n        stopCondition(Stop, Arguments, LeftArguments),\r\n        completeBpLabelling(Stop, LeftArguments).\r\n    stopCondition(stop, Args, NewArgs) :-\r\n        utils::sort(Args, SortedArgs),\r\n        utils::sort(NewArgs, SortedArgs), !.\r\n    stopCondition(go, _, _) :- context_retract(und(_)).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject BpGroundedPartial {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    argumentLabelling :-\r\n        bp_grounded::reifyBurdenOfProofs,\r\n        findall(X, context_check(argument(X)), Arguments),\r\n        partialBpLabelling(Arguments), !.\r\n    partialBpLabelling([]).\r\n    partialBpLabelling(Arguments) :-\r\n        mostGroundedArgument(Arguments, A),\r\n        debug::writeDebug(['Evaluating ', A]),\r\n        demonstration(Arguments, A, [A], Evaluated),\r\n        utils::subtract(Arguments, [Evaluated], NewArgs),\r\n        partialBpLabelling(NewArgs).\r\n    /*\r\n        (a.i) BP(neg(\u03c6)), and no argument B for neg(\u03c6) such that A < B is IN*, and no A1,...An is OUT*\r\n    */\r\n    demonstration(Arguments, A, Resolving, A) :-\r\n    \tisComplementInBurdenOfProof(A),\r\n    \t\\+ notEvaluatedSuperiorComplementArgument(Arguments, A, Resolving, _),\r\n    \t\\+ (\r\n    \t    superiorComplementArgument(A, B),\r\n    \t    context_check(in(B))\r\n    \t),\r\n    \t\\+ notEvaluatedSubArgument(Arguments, A, Resolving, _),\r\n    \t\\+ (\r\n    \t    context_check(support(X, A)),\r\n    \t    context_check(out(X))\r\n    \t),\r\n    \tdebug::writeDebug(['Adding argument: ', A, ' to IN* (2.a.i)']),\r\n        context_assert(in(A)).\r\n    /*\r\n        (a.ii) not BP(neg(\u03c6)) and every argument B for neg(\u03c6) such that B(not <)A is OUT*, and every A1,...An is IN*\r\n    */\r\n    demonstration(Arguments, A, Resolving, A) :-\r\n    \t\\+ isComplementInBurdenOfProof(A),\r\n    \t\\+ notEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, _),\r\n    \t\\+ (\r\n            superiorOrEqualComplementArgument(A, B),\r\n            \\+ context_check(out(B))\r\n        ),\r\n    \t\\+ notEvaluatedSubArgument(Arguments, A, Resolving, _),\r\n    \t\\+ (\r\n            context_check(support(X, A)),\r\n            \\+ context_check(in(X))\r\n        ),\r\n    \tdebug::writeDebug(['Adding argument: ', A, ' to IN* (2.a.ii)']),\r\n        context_assert(in(A)).\r\n    /*\r\n        (b.i.1) BP(\u03c6) and exists an argument B for neg(\u03c6) such that B(not <)A is not OUT*\r\n    */\r\n    demonstration(Arguments, A, Resolving, A) :-\r\n    \tbp_grounded::isArgumentInBurdenOfProof(A),\r\n    \t\\+ notEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, _),\r\n    \tsuperiorOrEqualComplementArgument(A, B),\r\n    \t\\+ context_check(out(B)),\r\n        debug::writeDebug(['Adding argument: ', A, ' to OUT* (2.b.i.1)']),\r\n        context_assert(out(A)).\r\n    /*\r\n        (b.i.2) BP(\u03c6) and exist one of A1,...An is not IN*\r\n    */\r\n    demonstration(Arguments, A, Resolving, A) :-\r\n    \tbp_grounded::isArgumentInBurdenOfProof(A),\r\n    \t\\+ notEvaluatedSubArgument(Arguments, A, Resolving, _),\r\n    \tcontext_check(support(X, A)),\r\n        \\+ context_check(in(X)),\r\n        debug::writeDebug(['Adding argument: ', A, ' to OUT* (2.b.i.2)']),\r\n        context_assert(out(A)).\r\n    /*\r\n        (b.ii.1) not BP(\u03c6) and an argument B for neg(\u03c6) such A < B is IN*\r\n    */\r\n    demonstration(Arguments, A, Resolving, A) :-\r\n    \t\\+ bp_grounded::isArgumentInBurdenOfProof(A),\r\n    \t\\+ notEvaluatedSuperiorComplementArgument(Arguments, A, Resolving, _),\r\n    \tsuperiorComplementArgument(A, B),\r\n    \tcontext_check(in(B)),\r\n        debug::writeDebug(['Adding argument: ', A, ' to OUT* (2.b.ii.1)']),\r\n        context_assert(out(A)).\r\n    /*\r\n        (b.ii.2) not BP(\u03c6) and one of A1,...An is OUT*\r\n    */\r\n    demonstration(Arguments, A, Resolving, A) :-\r\n    \t\\+ bp_grounded::isArgumentInBurdenOfProof(A),\r\n    \t\\+ notEvaluatedSubArgument(Arguments, A, Resolving, _),\r\n    \tcontext_check(support(X, A)),\r\n        context_check(out(X)),\r\n        debug::writeDebug(['Adding argument: ', A, ' to OUT* (2.b.ii.2)']),\r\n        context_assert(out(A)).\r\n    /*\r\n        If above definitions do not apply try to decide on the arguments on which they depend\r\n    */\r\n    demonstration(Arguments, A, Resolving, Evaluated) :-\r\n        isComplementInBurdenOfProof(A),\r\n    \tnotEvaluatedSuperiorComplementArgument(Arguments, A, Resolving, B),\r\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\r\n    demonstration(Arguments, A, Resolving, Evaluated) :-\r\n    \tisComplementInBurdenOfProof(A),\r\n    \t\\+ notEvaluatedSuperiorComplementArgument(Arguments, A, Resolving, _),\r\n    \t\\+ (\r\n            superiorComplementArgument(A, X),\r\n            context_check(in(X))\r\n        ),\r\n        notEvaluatedSubArgument(Arguments, A, Resolving, B),\r\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\r\n    demonstration(Arguments, A, Resolving, Evaluated) :-\r\n        \\+ isComplementInBurdenOfProof(A),\r\n    \tnotEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, B),\r\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\r\n    demonstration(Arguments, A, Resolving, Evaluated) :-\r\n    \t\\+ isComplementInBurdenOfProof(A),\r\n    \t\\+ notEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, _),\r\n    \t\\+ (\r\n            superiorOrEqualComplementArgument(A, X),\r\n            \\+ context_check(out(X))\r\n        ),\r\n        notEvaluatedSubArgument(Arguments, A, Resolving, B),\r\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\r\n    demonstration(Arguments, A, Resolving, Evaluated) :-\r\n    \tbp_grounded::isArgumentInBurdenOfProof(A),\r\n    \tnotEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, B),\r\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\r\n    demonstration(Arguments, A, Resolving, Evaluated) :-\r\n    \tbp_grounded::isArgumentInBurdenOfProof(A),\r\n    \tnotEvaluatedSubArgument(Arguments, A, Resolving, B),\r\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\r\n    demonstration(Arguments, A, Resolving, Evaluated) :-\r\n    \t\\+ bp_grounded::isArgumentInBurdenOfProof(A),\r\n    \tnotEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, B),\r\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\r\n    demonstration(Arguments, A, Resolving, Evaluated) :-\r\n    \t\\+ bp_grounded::isArgumentInBurdenOfProof(A),\r\n    \tnotEvaluatedSubArgument(Arguments, A, Resolving, B),\r\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\r\n    /*\r\n        (c) A is labelled UND* otherwise.\r\n    */\r\n    demonstration(Arguments, A, Resolving, A) :-\r\n    \tdebug::writeDebug(['Adding argument: ', A, ' to UND* (2.c)']),\r\n        context_assert(und(A)).\r\n    isComplementInBurdenOfProof(A) :-\r\n        complement(A, Complement),\r\n        bp_grounded::isInBurdenOfProof(Complement), !.\r\n    mostGroundedArgument([], []).\r\n    mostGroundedArgument([X], X).\r\n    mostGroundedArgument([[L, _, _, _, _]|T], [L2, Q2, W2, B2, I2]) :-\r\n        mostGroundedArgument(T, [L2, Q2, W2, B2, I2]),\r\n        length(L, LN1),\r\n        length(L2, LN2),\r\n        LN1 > LN2, !.\r\n    mostGroundedArgument([A|_], A).\r\n    /*\r\n        Get a conclusion complement\r\n    */\r\n    complement([_, _, Conclusion, _, _], A) :-\r\n        standard_af::conflict(Conclusion, A).\r\n    notEvaluatedSubArgument(Arguments, A, Resolving, B) :-\r\n        context_check(support(B, A)),\r\n        member(B, Arguments),\r\n        \\+ member(B, Resolving).\r\n    notEvaluatedSuperiorComplementArgument(Arguments, A, Resolving, B) :-\r\n        superiorComplementArgument(A, B),\r\n        member(B, Arguments),\r\n        \\+ member(B, Resolving).\r\n    notEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, B) :-\r\n        superiorOrEqualComplementArgument(A, B),\r\n        member(B, Arguments),\r\n        \\+ member(B, Resolving).\r\n    superiorComplementArgument(A, [A, B, CA, BB, I]) :-\r\n        complement(A, CA),\r\n        context_check(argument([R, B, CA, BB, I])),\r\n        superiority::superiorArgument([R, B, CA, BB, I], A).\r\n    superiorOrEqualComplementArgument(A, [R, B, CA, BB, I]) :-\r\n        complement(A, CA),\r\n        context_check(argument([R, B, CA, BB, I])),\r\n        \\+ superiority::superiorArgument(A, [R, B, CA, BB, I]).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject BpPartialComplete {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    argumentBPLabelling([Arguments, Attacks, _], [BPIN, BPOUT, BPUND]) :-\r\n        reifyBurdenOfProofs(Arguments, [], []),\r\n        once(filterBpDefeat(Attacks, FilteredAttacks)),\r\n        smartBpLabelling(Arguments, FilteredAttacks, [], [], [], BPIN, BPOUT, BPUND), !.\r\n    filterBpDefeat([], []).\r\n    filterBpDefeat([(T, B, A)|Attacks], FilteredAttacks) :-\r\n        (T = rebut; T = undermine),\r\n        isArgumentInBurdenOfProof(B),\r\n        attack(T, B, A, C),\r\n        \\+ superiorArgument(B, A, C),\r\n        filterBpDefeat(Attacks, FilteredAttacks).\r\n    filterBpDefeat([A|Attacks], [A|FilteredAttacks]) :-\r\n        filterBpDefeat(Attacks, FilteredAttacks).\r\n    smartBpLabelling(Arguments, Attacks, IN, OUT, UND, ResultIN, ResultOUT, ResultUND) :-\r\n        member(A, Arguments),\r\n        allAttacksOUT(Attacks, A, OUT),\r\n        subtract(Arguments, [A], NewArguments),\r\n        smartBpLabelling(NewArguments, Attacks, [A|IN], OUT, UND, ResultIN, ResultOUT, ResultUND).\r\n    smartBpLabelling(Arguments, Attacks, IN, OUT, UND, ResultIN, ResultOUT, ResultUND) :-\r\n        member(A, Arguments),\r\n        \\+ isArgumentInBurdenOfProof(A),\r\n        oneAttackIN(Attacks, A, IN),\r\n        subtract(Arguments, [A], NewArguments),\r\n        smartBpLabelling(NewArguments, Attacks, IN, [A|OUT], UND, ResultIN, ResultOUT, ResultUND).\r\n    smartBpLabelling(Arguments, Attacks, IN, OUT, UND, ResultIN, ResultOUT, ResultUND) :-\r\n        mostGroundedBpUnd(Arguments, Attacks, A),\r\n        subtract(Arguments, [A], NewArguments),\r\n        smartBpLabelling(NewArguments, Attacks, IN, [A|OUT], UND, ResultIN, ResultOUT, ResultUND).\r\n    smartBpLabelling(Arguments, _, IN, OUT, _, IN, OUT, Arguments).\r\n    mostGroundedBpUnd(Arguments, Attacks, Arg) :-\r\n        member(Arg, Arguments),\r\n        isArgumentInBurdenOfProof(Arg),\r\n        \\+ (\r\n            (member(A, Arguments), Arg \\= A, isArgumentInBurdenOfProof(A)),\r\n            argumentChain(A, Arg, Attacks)\r\n        ).\r\n    writeDemonstration([]) :-\r\n        demonstration,\r\n        write('\\n').\r\n    writeDemonstration([X|T]) :-\r\n        demonstration,\r\n        write(X),\r\n        writeDemonstration(T).\r\n    writeDemonstration(_).\r\n    argumentBPLabelling(COMPLETION ,[IN, OUT, UND], [BPIN, BPOUT, BPUND]) :-\r\n        reifyBurdenOfProofs(IN, OUT, UND),\r\n        writeDemonstration(['=========================================>DEMONSTRATION']),\r\n        argumentBPLabelling(COMPLETION, IN, OUT, UND, BPIN, BPOUT, BPUND),\r\n        writeDemonstration(['=====================================>END DEMONSTRATION']), !.\r\n    argumentBPLabelling(partial, IN, OUT, UND, BPIN, BPOUT, BPUND) :-\r\n        partialHBPLabelling(UND, IN, OUT, [], BPIN, BPOUT, BPUND).\r\n    argumentBPLabelling(complete, IN, OUT, UND, BPIN, BPOUT, BPUND) :-\r\n        hbpComplete(go, IN, OUT, UND, BPIN, BPOUT, BPUND).\r\n    hbpComplete(stop, IN, OUT, UND, IN, OUT, UND).\r\n    hbpComplete(_, IN, OUT, UND, BPIN, BPOUT, BPUND) :-\r\n        writeDemonstration(['======================================================>']),\r\n        partialHBPLabelling(UND, IN, OUT, [], BaseIN, BaseOUT, BaseUND),\r\n        completeLabelling(BaseIN, BaseOUT, BaseUND, CompleteIN, CompleteOUT, CompleteUND),\r\n        stopCondition(FLAG, IN, CompleteIN, OUT, CompleteOUT, UND, CompleteUND),\r\n        hbpComplete(FLAG, CompleteIN, CompleteOUT, CompleteUND, BPIN, BPOUT, BPUND).\r\n    stopCondition(X, IN, CIN, OUT, COUT, UND, CUND) :-\r\n        sort(IN, SIN),\r\n        sort(CIN, SCIN),\r\n        sort(OUT, SOUT),\r\n        sort(COUT, SCOUT),\r\n        sort(UND, SUND),\r\n        sort(CUND, SCUND),\r\n        stopCondition_sorted(X, SIN, SCIN, SOUT, SCOUT, SUND, SCUND).\r\n    stopCondition_sorted(stop, IN, IN, OUT, OUT, UND, UND).\r\n    stopCondition_sorted(go, _, _, _, _, _, _).\r\n    partialHBPLabelling([], IN_STAR, OUT_STAR, UND_STAR, IN_STAR, OUT_STAR, UND_STAR).\r\n    partialHBPLabelling(UND, IN_STAR, OUT_STAR, UND_STAR, ResultIN, ResultOUT, ResultUND) :-\r\n        more_grounded_argument(UND, A),\r\n        writeDemonstration(['Evaluating ', A]),\r\n        demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, [A], NewUnd, TempIN, TempOUT, TempUND),\r\n        partialHBPLabelling(NewUnd, TempIN, TempOUT, TempUND, ResultIN, ResultOUT, ResultUND).\r\n    /*\r\n        (a.i) BP(neg(\u03c6)), and no argument B for neg(\u03c6) such that A < B is IN*, and no A1,...An is OUT*\r\n    */\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, OUT_STAR, UND_STAR) :-\r\n    \tisComplementInBurdenOfProof(A),\r\n    \t\\+ findSupUndComplargument(A, UND, RESOLVING, _, _),\r\n    \tnoSuperiorComplementInSet(A, IN_STAR),\r\n    \t\\+ findUndSubargument(A, UND, RESOLVING, _, _),\r\n    \tnoSubArgumentInSet(A, OUT_STAR),\r\n    \twriteDemonstration(['Adding argument: ', A, ' to IN* (2.a.i)']),\r\n        append(IN_STAR, [A], TempIN),\r\n        subtract(UND, [A], NewUnd).\r\n    /*\r\n        (a.ii) not BP(neg(\u03c6)) and every argument B for neg(\u03c6) such that B(not <)A is OUT*, and every A1,...An is IN*\r\n    */\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, OUT_STAR, UND_STAR) :-\r\n    \t\\+ isComplementInBurdenOfProof(A),\r\n    \t\\+ findSupOrEqualUndComplargument(A, UND, RESOLVING, _, _),\r\n    \tallComplementInSet(A, OUT_STAR),\r\n    \t\\+ findUndSubargument(A, UND, RESOLVING, _, _),\r\n    \tallSubArgumentInSet(A, IN_STAR),\r\n    \twriteDemonstration(['Adding argument: ', A, ' to IN* (2.a.ii)']),\r\n        append(IN_STAR, [A], TempIN),\r\n        subtract(UND, [A], NewUnd).\r\n    /*\r\n        (b.i.1) BP(\u03c6) and exists an argument B for neg(\u03c6) such that B(not <)A is not OUT*\r\n    */\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, IN_STAR, TempOUT, UND_STAR) :-\r\n    \tisArgumentInBurdenOfProof(A),\r\n    \t\\+ findSupOrEqualUndComplargument(A, UND, RESOLVING, _, _),\r\n    \toneOutSuperiorOrEqualComplementFromSet(A, UND, OUT_STAR),\r\n        writeDemonstration(['Adding argument: ', A, ' to OUT* (2.b.i.1)']),\r\n        append(OUT_STAR, [A], TempOUT),\r\n        subtract(UND, [A], NewUnd).\r\n    /*\r\n        (b.i.2) BP(\u03c6) and exist one of A1,...An is not IN*\r\n    */\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, IN_STAR, TempOUT, UND_STAR) :-\r\n    \tisArgumentInBurdenOfProof(A),\r\n    \t\\+ findUndSubargument(A, UND, RESOLVING, _, _),\r\n    \toneOutSubArgumentFromSet(A, UND, IN_STAR),\r\n        writeDemonstration(['Adding argument: ', A, ' to OUT* (2.b.i.2)']),\r\n        append(OUT_STAR, [A], TempOUT),\r\n        subtract(UND, [A], NewUnd).\r\n    /*\r\n        (b.ii.1) not BP(\u03c6) and an argument B for neg(\u03c6) such A < B is IN*\r\n    */\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, IN_STAR, TempOUT, UND_STAR) :-\r\n    \t\\+ isArgumentInBurdenOfProof(A),\r\n    \t\\+ findSupUndComplargument(A, UND, RESOLVING, _, _),\r\n    \toneInSuperiorOrEqualComplementFromSet(A, IN_STAR),\r\n        writeDemonstration(['Adding argument: ', A, ' to OUT* (2.b.ii.1)']),\r\n        append(OUT_STAR, [A], TempOUT),\r\n        subtract(UND, [A], NewUnd).\r\n    /*\r\n        (b.ii.2) not BP(\u03c6) and one of A1,...An is OUT*\r\n    */\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, IN_STAR, TempOUT, UND_STAR) :-\r\n    \t\\+ isArgumentInBurdenOfProof(A),\r\n    \t\\+ findUndSubargument(A, UND, RESOLVING, _, _),\r\n    \toneInSubArgumentFromSet(A, OUT_STAR),\r\n        writeDemonstration(['Adding argument: ', A, ' to OUT* (2.b.ii.2)']),\r\n        append(OUT_STAR, [A], TempOUT),\r\n        subtract(UND, [A], NewUnd).\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\r\n        isComplementInBurdenOfProof(A),\r\n    \tfindSupUndComplargument(A, UND, RESOLVING, NR, Compl),\r\n        demonstration(Compl, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\r\n    \tisComplementInBurdenOfProof(A),\r\n    \t\\+ findSupUndComplargument(A, UND, RESOLVING, _, _),\r\n    \tnoSuperiorComplementInSet(A, IN_STAR),\r\n        findUndSubargument(A, UND, RESOLVING, NR, Sub),\r\n        demonstration(Sub, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\r\n        \\+ isComplementInBurdenOfProof(A),\r\n    \tfindAllUndComplargument(A, UND, RESOLVING, NR, Compl),\r\n        demonstration(Compl, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\r\n    \t\\+ isComplementInBurdenOfProof(A),\r\n    \t\\+ findAllUndComplargument(A, UND, RESOLVING, _, _),\r\n    \tallComplementInSet(A, OUT_STAR),\r\n        findUndSubargument(A, UND, RESOLVING, NR, Sub),\r\n        demonstration(Sub, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\r\n    \tisArgumentInBurdenOfProof(A),\r\n    \tfindSupOrEqualUndComplargument(A, UND, RESOLVING, NR, Compl),\r\n        demonstration(Compl, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\r\n    \tisArgumentInBurdenOfProof(A),\r\n    \tfindUndSubargument(A, UND, RESOLVING, NR, Sub),\r\n        demonstration(Sub, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\r\n    \t\\+ isArgumentInBurdenOfProof(A),\r\n    \tfindSupOrEqualUndComplargument(A, UND, RESOLVING, NR, Compl),\r\n        demonstration(Compl, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\r\n    \t\\+ isArgumentInBurdenOfProof(A),\r\n    \tfindUndSubargument(A, UND, RESOLVING, NR, Sub),\r\n        demonstration(Sub, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\r\n    /*\r\n        (c) A is labelled UND* otherwise.\r\n    */\r\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, _, NewUnd, IN_STAR, OUT_STAR, TempUND) :-\r\n    \twriteDemonstration(['Adding argument: ', A, ' to UND* (2.c)']),\r\n        append(UND_STAR, [A], TempUND),\r\n        subtract(UND, [A], NewUnd).\r\n    /*\r\n        Load dependencies\r\n    */\r\n    findUndSubargument(A, UND, RESOLVING, NEW_RESOLVING, Sub) :-\r\n        support(Sub, A),\r\n        member(Sub, UND),\r\n        \\+ member(Sub, RESOLVING),\r\n        append(RESOLVING, [Sub], NEW_RESOLVING).\r\n    findAllUndComplargument(A, UND, RESOLVING, NEW_RESOLVING, Compl) :-\r\n        allComplArguments(A, List),\r\n        findAcceptable(A, List, UND, RESOLVING, NEW_RESOLVING, Compl).\r\n    findSupUndComplargument(A, UND, RESOLVING, NEW_RESOLVING, Compl) :-\r\n        superiorComplArguments(A, List),\r\n        findAcceptable(A, List, UND, RESOLVING, NEW_RESOLVING, Compl).\r\n    findSupOrEqualUndComplargument(A, UND, RESOLVING, NEW_RESOLVING, Compl) :-\r\n        superiorOrEqualComplArguments(A, List),\r\n        findAcceptable(A, List, UND, RESOLVING, NEW_RESOLVING, Compl).\r\n    findAcceptable(A, List, UND, RESOLVING, NEW_RESOLVING, Compl) :-\r\n        member(Compl, List),\r\n        member(Compl, UND),\r\n        \\+ member(Compl, RESOLVING),\r\n        append(RESOLVING, [Compl], NEW_RESOLVING).\r\n    /*\r\n        Conditions\r\n    */\r\n    noSuperiorComplementInSet(Argument, Set) :-\r\n        superiorComplArguments(Argument, LIST),\r\n        noInWithEmptyCheck(LIST, Set).\r\n    noSubArgumentInSet(Argument, Set) :-\r\n        allDirectsSubArguments(Argument, LIST),\r\n        noInWithEmptyCheck(LIST, Set).\r\n    allComplementInSet(Argument, Set) :-\r\n        allComplArguments(Argument, LIST),\r\n        allInWithEmptyCheck(LIST, Set).\r\n    allSubArgumentInSet(Argument, Set) :-\r\n        allDirectsSubArguments(Argument, LIST),\r\n        allInWithEmptyCheck(LIST, Set).\r\n    oneOutSuperiorOrEqualComplementFromSet(Argument, UND, Set) :-\r\n        superiorOrEqualComplArguments(Argument, LIST),\r\n        oneOut(LIST, UND, Set).\r\n    oneOutSubArgumentFromSet(Argument, UND, Set) :-\r\n        allDirectsSubArguments(Argument, LIST),\r\n        oneOut(LIST, UND, Set).\r\n    oneInSuperiorOrEqualComplementFromSet(Argument, Set) :-\r\n        superiorOrEqualComplArguments(Argument, LIST),\r\n        oneIn(LIST, Set).\r\n    oneInSubArgumentFromSet(Argument, Set) :-\r\n        allDirectsSubArguments(Argument, LIST),\r\n        oneIn(LIST, Set).\r\n    /*\r\n        Support\r\n    */\r\n    allDirectsSubArguments(Argument, LIST) :-\r\n        findall(Sub, support(Sub, Argument), LIST).\r\n    allComplArguments(Argument, LIST) :-\r\n        findall(X, (\r\n            complement(Argument, CA),\r\n            findall([A, B, CA], argument([A, B, CA]), X)\r\n        ), Y),\r\n        appendLists(Y, LIST).\r\n    superiorComplArguments(Argument, LIST) :-\r\n        findall(X, (\r\n            complement(Argument, CA),\r\n            findall([A, B, CA], (argument([A, B, CA]), superiorArgument([A, B, CA], Argument)), X)\r\n        ), Y),\r\n        appendLists(Y, LIST).\r\n    superiorOrEqualComplArguments(Argument, LIST) :-\r\n        findall(X, (\r\n            complement(Argument, CA),\r\n            findall([A, B, CA], (argument([A, B, CA]), \\+ superiorArgument(Argument, [A, B, CA])), X)\r\n        ), Y),\r\n        appendLists(Y, LIST).\r\n    noInWithEmptyCheck([], _).\r\n    noInWithEmptyCheck(List, Target) :- noIn(List, Target).\r\n    noIn(List, Target) :-\r\n        member(X, List),\r\n        \\+ member(X, Target).\r\n    allInWithEmptyCheck([], _).\r\n    allInWithEmptyCheck(List, Target) :- allIn(List, Target).\r\n    allIn(List, Target) :-\r\n        member(_, List),\r\n        \\+ (member(Y, List), \\+ member(Y, Target)).\r\n    oneInWithEmptyCheck([], _).\r\n    oneInWithEmptyCheck(List, Target) :- oneIn(List, Target).\r\n    oneIn(List, Target) :-\r\n        member(X, List),\r\n        member(X, Target).\r\n    oneOutWithEmptyCheck([], _, _).\r\n    oneOutWithEmptyCheck(List, UND, Target) :- oneOut(List, UND, Target).\r\n    oneOut(List, UND, Target) :-\r\n        member(X, List),\r\n        \\+ member(X, UND),\r\n        \\+ member(X, Target).\r\n    completeLabelling(IN, OUT, UND, ResultIN, ResultOUT, ResultUND) :-\r\n        findoneIn(IN, OUT, UND, A),\r\n        writeDemonstration(['Adding argument: ', A, ' to IN* (4.4)']),\r\n        append(IN, [A], NewIN),\r\n        subtract(UND, [A], NewUnd),\r\n        completeLabelling(NewIN, OUT, NewUnd, ResultIN, ResultOUT, ResultUND).\r\n    completeLabelling(IN, OUT, UND, ResultIN, ResultOUT, ResultUND) :-\r\n        findoneOut(IN, OUT, UND, A),\r\n        writeDemonstration(['Adding argument: ', A, ' to OUT* (4.4)']),\r\n        append(OUT, [A], NewOUT),\r\n        subtract(UND, [A], NewUnd),\r\n        completeLabelling(IN, NewOUT, NewUnd, ResultIN, ResultOUT, ResultUND).\r\n    completeLabelling(IN, OUT, UND, IN, OUT, UND).\r\n    findoneIn(IN, OUT, UND, A):-\r\n        member(A, UND),\r\n        completeIn(A, IN, OUT).\r\n    findoneOut(IN, OUT, UND, A):-\r\n        member(A, UND),\r\n        completeOut(A, IN, OUT).\r\n    completeIn(A, _, OUT) :- checkOutAttackers(A, OUT).\r\n    /*\r\n        If an attack exists, it should come from an OUT argument\r\n    */\r\n    checkOutAttackers(A, OUT) :-\r\n        \\+ ( attack(_, B, A), \\+ ( member(B, OUT)) ).\r\n    completeOut(A, IN, _) :- checkInAttacker(A, IN).\r\n    completeOut(A, IN, _) :- checkInAttecked(A, IN).\r\n    /*\r\n        Find an attack, if exists, from an IN argument, then ends\r\n    */\r\n    checkInAttacker(A, IN) :-\r\n        attack(_, B, A),\r\n        member(B, IN), !.\r\n    /*\r\n        If A attacks an IN argument, then A is OUT\r\n    */\r\n    checkInAttecked(A, IN) :-\r\n        attack(_, A, B),\r\n        member(B, IN), !.\r\n    /*\r\n        Checks Burden of proof membership\r\n    */\r\n    isInBurdenOfProof(Concl) :-\r\n        reifiedBp(Literals),\r\n        member(Concl, Literals), !.\r\n    isComplementInBurdenOfProof(A) :-\r\n        complement(A, Compl),\r\n        isInBurdenOfProof(Compl), !.\r\n    isArgumentInBurdenOfProof([_, _, Concl]) :-\r\n        isInBurdenOfProof(Concl).\r\n    more_grounded_argument([], []).\r\n    more_grounded_argument([X], X).\r\n    more_grounded_argument([[L,_,_]|T], [L2,Q2,W2]) :-\r\n        more_grounded_argument(T, [L2,Q2,W2]),\r\n        length(L, LN1),\r\n        length(L2, LN2),\r\n        LN1 > LN2.\r\n    more_grounded_argument([[L,Q,W]|_], [L,Q,W]).\r\n    /*\r\n        Get a conclusion complement\r\n    */\r\n    complement([_, _, Conc], A) :- conflict(Conc, A).\r\n    reifyBurdenOfProofs(IN, OUT, UND) :-\r\n        extractConclusions(IN, OUT, UND, Conclusions),\r\n        computeBp(Conclusions).\r\n    extractConclusions(IN, OUT, UND, SL) :-\r\n        findall(Conc, member([_, _, Conc], IN), In),\r\n        findall(Conc, member([_, _, Conc], OUT), Out),\r\n        findall(Conc, member([_, _, Conc], UND), Und),\r\n        appendLists([In, Out, Und], L),\r\n        sort(L, SL).\r\n    computeBp(Conclusions) :-\r\n        abstractBp(AbstractBp),\r\n        fillTemplate(AbstractBp, Conclusions, R),\r\n        \\+ reifiedBp(R),\r\n        asserta(reifiedBp(R)),\r\n        computeBp(Conclusions).\r\n    computeBp(_).\r\n    /*\r\n        Fill the template (first parameter) using predicates belonging\r\n        to the second list (second parameter)\r\n    */\r\n    fillTemplate([], _, []).\r\n    fillTemplate([H|T], C, [H|R]) :- member(H, C), fillTemplate(T, C, R).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject Complete {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    argumentLabelling :-\r\n        cache_retract(complete(_,_,_)),\r\n        grounded:::argumentLabelling,\r\n        context_active(Branch),\r\n        completeLabelling(Branch).\r\n    completeLabelling(_) :-\r\n        admissibleSet,\r\n        utils::recoverArgumentLabelling(In, Out, Und),\r\n        \\+ cache_check(complete(In, Out, Und)),\r\n        cache_assert(complete(In, Out, Und)).\r\n    completeLabelling(Branch) :-\r\n        context_check(und(X)),\r\n        context_branch(Branch, NewBranch),\r\n        findall(Y, (context_check(und(Y)), Y \\= X), Arguments),\r\n        context_retract(und(_)),\r\n        context_assert(in(X)),\r\n        grounded::groundedLabelling(Arguments),\r\n        completeLabelling(NewBranch).\r\n    admissibleSet :-\r\n        \\+ (context_check(in(H)), \\+ admissible(H)).\r\n    admissible(H) :-\r\n        \\+ (\r\n            context_check(attack(_, Attacker, H, _)),\r\n            \\+ (\r\n                context_check(attack(_, Defendant, Attacker, _)),\r\n                context_check(in(Defendant))\r\n            )\r\n        ).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject Debug {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    printTheory(Rules) :-\r\n        write('HERE THE THEORY:'),nl,\r\n        findall(rule([Id, Body, Head]), member(rule([Id, Body, Head]), Rules), ListRules),\r\n        utils::writeListNl(ListRules),\r\n        findall(premise([A, B]), member(premise([A, B]), Rules), ListPremises),\r\n        utils::writeListNl(ListPremises),\r\n        findall(sup(A, B), member(sup(A, B), Rules), ListSups),\r\n        utils::writeListNl(ListSups).\r\n    printArgumentationGraph(Arguments, Attacks, Supports) :-\r\n    \tfindall(\r\n    \t    [IDPremises, '\\n',  ' TOPRULE ',  TopRule, '\\n', ' CONCLUSION ', RuleHead, '\\n', ' BODY ', Body, '\\n', ' INFO ', Info, '\\n'],\r\n    \t    member([IDPremises, TopRule, RuleHead, Body, Info], Arguments),\r\n            ArgumentsToPrint\r\n        ),\r\n        findall((A1, ' SUPPORTS ', A2), member((A1, A2), Supports), SupportsToPrint),\r\n    \tfindall((A1, ' ', T, ' ', A2, ' ON ', A3),  member((T, A1, A2, A3), Attacks),  AttacksToPrint),\r\n        write('HERE THE GROUNDED SEMI-ABSTRACT ARGUMENTATION GRAPH'),nl,\r\n    \tutils::writeListNl(ArgumentsToPrint),\r\n    \tutils::writeListNl(SupportsToPrint),\r\n    \tutils::writeListNl(AttacksToPrint).\r\n    printArgumentLabelling([IN, OUT, UND]) :-\r\n        write('HERE THE ARGUMENTS LABELLED IN: '),nl,\r\n        utils::writeListNl(IN),\r\n        write('HERE THE ARGUMENTS LABELLED OUT: '),nl,\r\n        utils::writeListNl(OUT),\r\n        write('HERE THE ARGUMENTS LABELLED UND: '),nl,\r\n        utils::writeListNl(UND).\r\n    printStatementLabelling([In, Ni, Und]) :-\r\n        write('HERE THE STATEMENTS LABELLED IN: '),nl,\r\n        utils::writeListNl(In),\r\n        write('HERE THE STATEMENTS LABELLED NI: '),nl,\r\n        utils::writeListNl(Ni),\r\n        write('HERE THE STATEMENTS LABELLED UND: '),nl,\r\n        utils::writeListNl(Und).\r\n    debug.\r\n    writeDebug(List) :-\r\n        debug,\r\n        utils::writeList(List).\r\n    writeDebug(_) :- \\+ debug.\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject DefPreferences {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    modifyArgumentationGraph :-\r\n        assertAllSup,\r\n        findall((T, A, B, C), context_check(attack(T, A, B, C)), Attacks),\r\n        filterSupRelatedAttacks(Attacks, InvalidAttacks),\r\n        convertAttacks(InvalidAttacks),\r\n        buildPrefAttacks.\r\n    assertAllSup :-\r\n        context_retract(sup(_, _)),\r\n        findall(_,\r\n            (\r\n                context_check(argument([_, _, [sup(RuleOne, RuleTwo)], _, _])),\r\n                \\+ context_check(sup(RuleOne, RuleTwo)),\r\n                context_assert(sup(RuleOne, RuleTwo))\r\n            ),\r\n        _).\r\n    filterSupRelatedAttacks([], []).\r\n    filterSupRelatedAttacks([(T, A, B, C)|Attacks], [(T, A, B, C)|Invalid]) :-\r\n        invalid(T, A, B, C, _),\r\n        filterSupRelatedAttacks(Attacks, Invalid), !.\r\n    filterSupRelatedAttacks([_|Attacks], Invalid) :-\r\n        filterSupRelatedAttacks(Attacks, Invalid).\r\n    invalid(rebut, A, B, C, SupSet) :- superiority::superiorArgument(C, A, SupSet), !.\r\n    invalid(undermine, A, B, C, SupSet) :- superiority::superiorArgument(C, A, SupSet), !.\r\n    /*\r\n    *   Translates the attack relations identified during the building phase.\r\n    *   Attack from A to B -> Argument [[], attack, Attack]\r\n    *                         support(A, Argument)\r\n    *                         attack(Argument, B)\r\n    *   If an Argument A built in this way attacks the argument B, and this one also attacks a third argument C\r\n    *   through the argument B1 we have to consider an attack from A to B1 (transitive attack)\r\n    */\r\n    convertAttacks(Attacks) :-\r\n        conversion(Attacks),\r\n        standard_af::buildTransitiveAttacks.\r\n    conversion(List) :-\r\n        member((T, A, B, B), List),\r\n        generateDirectAttackArgument(T, A, B, B),\r\n        fail.\r\n    conversion(List) :-\r\n        member((T, A, B, C), List),\r\n        C \\= B,\r\n        generateTransitiveAttackArgument(T, A, B, C),\r\n        fail.\r\n    conversion(_).\r\n    generateTransitiveAttackArgument(T, A, B, C) :-\r\n        context_check(argument([Id, attack, [attack(T, A, C, C)], G, I])),\r\n        context_assert(attack(T, [Id, attack, [attack(T, A, C, C)], G, I], B, C)),\r\n        context_retract(attack(T, A, B, C)).\r\n    generateDirectAttackArgument(T, A, B, B) :-\r\n        RArgument = [[attack], attack, [attack(T, A, B, B)], [], [[attack], [attack], []]],\r\n        \\+ context_check(argument(RArgument)),\r\n        context_assert(argument(RArgument)),\r\n        context_assert(support(A, RArgument)),\r\n        context_assert(attack(T, RArgument, B, B)),\r\n        context_retract(attack(T, A, B, B)).\r\n    /*\r\n    *   Computes the pref attack. If an Argument A has a conclusion in the form sup(a, b), we verify if\r\n    *   the attacks involving arguments built on the rules a or b are compatible with this preference.\r\n    *   If there are some contradictions we add an attack from the argument A towards the incompatible attack\r\n    */\r\n    buildPrefAttacks :-\r\n        context_check(argument([IdB, attack, [attack(T, A, B, C)], G, I])),\r\n        invalid(T, A, B, C, SupSet),\r\n        member(X, SupSet),\r\n        context_check(argument([IdA, TRA, [X], GG, II])),\r\n        Attack = attack(pref, [IdA, TRA, [X], GG, II], [IdB, attack, [attack(T, A, B, C)], G, I], [IdB, attack, [attack(T, A, B, C)], G, I]),\r\n        \\+ context_check(Attack),\r\n        context_assert(Attack),\r\n        fail.\r\n    buildPrefAttacks.\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject GenericDefPreferences {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    modifyArgumentationGraph :-\r\n        defeasiblePref::assertAllSup,\r\n        findall((T, A, B, C), context_check(attack(T, A, B, C)), Attacks),\r\n        defeasiblePref::filterSupRelatedAttacks(Attacks, InvalidAttacks),\r\n        defeasiblePref::convertAttacks(InvalidAttacks),\r\n        buildPrefAttacks,\r\n        standard_af::buildTransitiveAttacks.\r\n    buildPrefAttacks :-\r\n        context_check(argument([IdB, attack, [attack(T, A, B, C)], G, I])),\r\n        defeasiblePref::invalid(T, A, B, C, SupSet),\r\n        createSuperiorityArgument(SupSet, Arg),\r\n        write(Arg), nl,\r\n        Attack = attack(pref, Arg, [IdB, attack, [attack(T, A, B, C)], G, I], [IdB, attack, [attack(T, A, B, C)], G, I]),\r\n        \\+ context_check(Attack),\r\n        context_assert(Attack),\r\n        fail.\r\n    buildPrefAttacks.\r\n    createSuperiorityArgument(SupSet, Argument) :-\r\n        findall([Id, TR, [X], G, I], (\r\n            member(X, SupSet),\r\n            context_check(argument([Id, TR, [X], G, I]))\r\n        ), SupportArguments),\r\n        mergeIds(SupportArguments, MergedId),\r\n        Argument = [MergedId, pref, [mergedPreference], [], [[pref], MergedId, []]],\r\n        \\+ context_check(argument(Argument)),\r\n        context_assert(argument(Argument)),\r\n        findall(_, (\r\n            member(A, SupportArguments),\r\n            \\+ context_check(support(A, Argument)),\r\n            context_assert(support(A, Argument))\r\n        ), _).\r\n    mergeIds([], [pref]).\r\n    mergeIds(Arguments, [pref|MergedId]) :-\r\n        findall(Id, member([Id, _, _, _, _], Arguments), Res),\r\n        utils::appendLists(Res, MergedId).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject Grounded {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    argumentLabelling :-\r\n        findall(X, context_check(argument(X)), Arguments),\r\n        groundedLabelling(Arguments).\r\n    groundedLabelling(UND) :-\r\n        member(A, UND), \r\n        allAttacksOUT(A), !,\r\n        utils::subtract(UND, [A], NewUND),\r\n        context_assert(in(A)),\r\n        groundedLabelling(NewUND).\r\n    groundedLabelling(UND) :-\r\n        member(A, UND),\r\n        oneAttackIN(A), !,\r\n        utils::subtract(UND, [A], NewUND),\r\n        context_assert(out(A)),\r\n        groundedLabelling(NewUND).\r\n    groundedLabelling(Args) :- findall(_, (member(A, Args), context_assert(und(A))), _).\r\n    allAttacksOUT(A) :-\r\n        \\+ ( context_check(attack(_, B, A, _)), \\+ (context_check(out(B)))).\r\n    oneAttackIN(A) :-\r\n        context_check(attack(_, B, A, _)),\r\n        context_check(in(B)), !.\r\n    oneAttackIN(A) :-\r\n        context_check(attack(_, A, B, _)),\r\n        context_check(in(B)), !.\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject Preferences {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    modifyArgumentationGraph :-\r\n        findall(_, (\r\n            context_check(attack(T, A, B, C)),\r\n            checkStandardPreference(T, A, B, C)\r\n        ), _).\r\n    checkStandardPreference(T, A, B, C) :-\r\n        \\+ standardPreferences(T, A, B, C),\r\n        context_retract(attack(T, A, B, C)).\r\n    standardPreferences(rebut, A, _, C) :- \\+ superiority::superiorArgument(C, A).\r\n    standardPreferences(undermine, A, _, C) :- \\+ superiority::superiorArgument(C, A).\r\n    standardPreferences(contrary_rebut, _, _, _).\r\n    standardPreferences(contrary_undermine, _, _, _).\r\n    standardPreferences(undercut, _, _, _).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject QueryMode {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    computeStatementAcceptance(Goal, YesResult, NoResult, UndResult) :-\r\n        \\+ queryMode,\r\n        abstract:::computeGlobalAcceptance,\r\n        mineResults(Goal, YesResult, NoResult, UndResult).\r\n    computeStatementAcceptance(Goal, YesResult, NoResult, UndResult) :-\r\n        queryMode,\r\n        argumentLabellingMode(grounded),\r\n        parser::check_modifiers_in_list(effects, [Goal], [X]),\r\n        findall(_, query(X, _), _),\r\n        statementLabellingMode(Y),\r\n        Y:::statementLabelling,\r\n        mineResults(Goal, YesResult, NoResult, UndResult).\r\n    mineResults(Goal, YesResult, NoResult, UndResult) :-\r\n        parser::check_modifiers_in_list(effects, [Goal], [X]),\r\n        findall(Goal, context_check(statIn(X)), In),\r\n        findall(Goal, context_check(statOut(X)), Out),\r\n        findall(Goal, context_check(statUnd(X)), Und),\r\n        utils::sort(In, YesResult),\r\n        utils::sort(Out, NoResult),\r\n        utils::sort(Und, UndResult).\r\n    query(Query, Res) :-\r\n        buildArgument(Query, Argument),\r\n        once(defend(Argument, [], Res)).\r\n    query(Query, und) :- \\+ buildArgument(Query, _).\r\n    defend(Argument, _, no) :- context_check(out(Argument)).\r\n    defend(Argument, _, und) :- context_check(und(Argument)).\r\n    defend(Argument, _, yes) :- context_check(in(Argument)).\r\n    defend(Argument, QueryChain, no) :-\r\n        findAttacker(Argument, QueryChain, Attacker, yes),\r\n        once(defend(Attacker, [Argument|QueryChain], X)),\r\n        X == yes,\r\n        bufferResult(Argument, no), !.\r\n    defend(Argument, QueryChain, und) :-\r\n        findAttacker(Argument, QueryChain, Attacker, no),\r\n        bufferResult(Argument, und), !.\r\n    defend(Argument, QueryChain, und) :-\r\n        findAttacker(Argument, QueryChain, Attacker, yes),\r\n        once(defend(Attacker, [Argument|QueryChain], X)),\r\n        X == und,\r\n        bufferResult(Argument, und), !.\r\n    defend(Argument, QueryChain, yes) :- bufferResult(Argument, yes).\r\n    bufferResult(Argument, no) :- \\+ context_check(out(Argument)), context_assert(out(Argument)), !.\r\n    bufferResult(Argument, yes) :- \\+ context_check(in(Argument)), context_assert(in(Argument)), !.\r\n    bufferResult(Argument, und) :- \\+ context_check(und(Argument)), context_assert(und(Argument)), !.\r\n    bufferResult(_, _).\r\n    findAttacker(Target, QueryChain, Attacker, IsValid) :-\r\n        attacker(Target, Attacker),\r\n        bufferAttacker(Attacker, Target),\r\n        detectCycle(Attacker, QueryChain, IsValid).\r\n    bufferAttacker(Attacker, Target) :-\r\n        \\+ context_check(attack(none, Attacker, Target, none)),\r\n        context_assert(attack(none, Attacker, Target, none)), !.\r\n    bufferAttacker(_, _).\r\n    detectCycle(Attacker, QueryChain, yes) :- \\+ member(Attacker, QueryChain).\r\n    detectCycle(Attacker, QueryChain, no) :- member(Attacker, QueryChain).\r\n    attacker([Rules, TopRule, Conclusion, Groundings, ArgInfo], Argument) :-\r\n        member(X, Rules),\r\n        \\+ context_check(strict(X)),\r\n        attackerOnRule(X, [Rules, TopRule, Conclusion, Groundings, ArgInfo], Argument).\r\n    attacker([Rules, TopRule, Conclusion, Groundings, ArgInfo], Argument) :-\r\n        member(X, Groundings),\r\n        attackerOnTerm(X, [Rules, TopRule, Conclusion, Groundings, ArgInfo], Argument).\r\n    attackerOnRule(Rule, _, Argument) :-\r\n        buildArgument([undercut(Rule)], Argument).\r\n    attackerOnTerm(Term, [TargetRules, TopRule, Conclusion, Groundings, ArgInfo], Attacker) :-\r\n        Term \\= [unless, _],\r\n        \\+ strict([TargetRules, TopRule, Conclusion, Groundings, ArgInfo]),\r\n        buildSubArgument(Term, TargetRules, SubArgument),\r\n        rebutRestriction(SubArgument),\r\n        standard_af::conflict(Term, X),\r\n        buildArgument(X, Attacker),\r\n        \\+ superiorArgument(SubArgument, Attacker).\r\n    attackerOnTerm([unless, X], _, Attacker) :-\r\n        buildArgument(X, Attacker).\r\n    strict([_, _, _, _, [_, [], []]]).\r\n    rebutRestriction([TargetRules, none, Conclusion, Groundings, ArgInfo]) :-\r\n        graphExtension(rebutRestriction).\r\n    rebutRestriction([TargetRules, TopRule, Conclusion, Groundings, ArgInfo]) :-\r\n        graphExtension(rebutRestriction),\r\n        TopRule \\= none,\r\n        rebutRestriction::restrict([TargetRules, TopRule, Conclusion, Groundings, ArgInfo]).\r\n    rebutRestriction(_) :- \\+ graphExtension(rebutRestriction).\r\n    superiorArgument(SubArgument, Attacker) :-\r\n        superiority::superiorArgument(SubArgument, Attacker).\r\n    buildSubArgument(Term, Rules, [SubRules, SubTopRule, SubConclusion, SubGrounds, Info]) :-\r\n        buildArgument(Term, [SubRules, SubTopRule, SubConclusion, SubGrounds, Info]),\r\n        contained(SubRules, Rules).\r\n    contained([], _).\r\n    contained([H|T], Target) :- member(H, Target), contained(T, Target).\r\n    buildArgument(Query, Argument) :-\r\n        \\+ context_check(explored(Query)),\r\n        findall(_, (\r\n            buildSingleArgument(Query, Argument),\r\n            context_assert(argument(Argument))\r\n        ), _),\r\n        context_assert(explored(Query)),\r\n        fail.\r\n    buildArgument(Query, [R, T, Query, B, I]) :- context_check(argument([R, T, Query, B, I])).\r\n    buildSingleArgument(Query, Argument) :-\r\n        build(Query, Groundings, [AllRules, TopRule, LastDefRules, DefRules, DefPremises]),\r\n        utils::deduplicate(DefRules, CDefRules),\r\n        utils::deduplicate(DefPremises, CDefPremises),\r\n        utils::deduplicate(Groundings, CGroundings),\r\n        Argument = [AllRules, TopRule, Query, CGroundings, [LastDefRules, CDefRules, CDefPremises]].\r\n    build(Conclusion, [Conclusion], Rules) :-\r\n        context_check(premise([Id, Conclusion])),\r\n        premiseRules(Id, Rules).\r\n    build(Conclusion, [Conclusion|Conclusions], Rules) :-\r\n        context_check(rule([Id, Premises, Conclusion])),\r\n        buildPremises(Premises, Conclusions, ResRules),\r\n        ruleRules(Id, ResRules, Rules).\r\n    build([prolog(Check)], [], []) :- (callable(Check) -> call(Check); Check).\r\n    build([unless, Atom], [[unless, Atom]], []).\r\n    buildPremises([], [], [[], [], [], []]).\r\n    buildPremises([H|T], Conclusions, Rules) :-\r\n        build(H, HConclusions, HRules),\r\n        buildPremises(T, TConclusions, TRules),\r\n        utils::appendLists([HConclusions, TConclusions], Conclusions),\r\n        mergeRules(HRules, TRules, Rules).\r\n    premiseRules(Id, [[Id], none, [], [], [Id]]) :- \\+ context_check(strict(Id)).\r\n    premiseRules(Id, [[Id], none, [], [], []]) :- context_check(strict(Id)).\r\n    ruleRules(Id, [AllRules, _, DefRules, DefPremises], \r\n        [[Id|AllRules], Id, [Id], [Id|DefRules], DefPremises]) :- \\+ context_check(strict(Id)).\r\n    ruleRules(Id, [AllRules, LastDefRules, DefRules, DefPremises], \r\n        [[Id|AllRules], Id, LastDefRules, DefRules, DefPremises]) :- context_check(strict(Id)).\r\n    mergeRules([], [AllRules, LastDefRules, DefRules, DefPremises], [AllRules, LastDefRules, DefRules, DefPremises]).\r\n    mergeRules([HAR, _, HLDR, HDR, HDP], [TAR, TLDR, TDR, TDP], [AR, LDR, DR, DP]) :-\r\n       utils::appendLists([HAR, TAR], AR),\r\n       utils::appendLists([HLDR, TLDR], LDR),\r\n       utils::appendLists([HDR, TDR], DR),\r\n       utils::appendLists([HDP, TDP], DP).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject RuleTranslator {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    /*\r\n     *  Main directive. Find all the rules in the theory in the format (Name : Preconditions => Conclusion)\r\n     *  or (Name : Effects) and then if:\r\n     *  - It is a standard rule, translate it in the standard format (rule([Name, Preconditions, Conclusions]));\r\n     *  - It is a bp rule, translate it to (abstractBp([Effects]))\r\n     *  During the process, clean them from the unallowed symbols (-, o, p).\r\n     */\r\n    convertAllRules(ArgRules) :-\r\n        defeasibleRules(DefeasibleRules),\r\n        strictRules(StrictRules, RulesIds),\r\n        ordinaryPremises(Premises),\r\n        axiomPremises(Axioms, AxiomsIds),\r\n        specialRules(SpecialRules),\r\n        utils::appendLists([DefeasibleRules, StrictRules, Premises, Axioms, SpecialRules], L),\r\n        convertAllRules(L, Rules), !,\r\n        findall(sup(X, Y), sup(X, Y), Sups),\r\n        utils::appendLists([Rules, AxiomsIds, RulesIds, Sups], ArgRules),\r\n        findall(_, (member(X, ArgRules), context_assert(X)), _).\r\n    defeasibleRules(DefeasibleRules) :-\r\n        findall([RuleName, Preconditions, Effect], (RuleName : Preconditions => Effect), DefeasibleRulesOld),\r\n        prologDefeasibleRules(DefeasibleRulesNew),\r\n        append(DefeasibleRulesOld, DefeasibleRulesNew, DefeasibleRules).\r\n    strictRules(CtrRules, Ids) :-\r\n        findall([RuleName, Preconditions, Effect], (RuleName : Preconditions -> Effect), StrictRulesOld),\r\n        prologStrictRules(StrictRulesNew),\r\n        append(StrictRulesOld, StrictRulesNew, StrictRules),\r\n        transpose(StrictRules, StrictRules, CtrRules),\r\n        findall(strict(RN), member([RN, _, _], CtrRules), Ids).\r\n    ordinaryPremises(Premises) :-\r\n        findall([RuleName, Effect], ((RuleName :=> Effect), atom(RuleName)), PremisesOld),\r\n        prologPremises(PremisesNew),\r\n        append(PremisesOld, PremisesNew, Premises).\r\n    axiomPremises(Axioms, Ids) :-\r\n        findall([RuleName, Effect], ((RuleName :-> Effect), atom(RuleName)), AxiomsOld),\r\n        prologAxioms(AxiomsNew),\r\n        append(AxiomsOld, AxiomsNew, Axioms),\r\n        findall(strict(RN), member([RN, _], Axioms), Ids).\r\n    specialRules(SpecialRules) :-\r\n        bpsNew(SpecialRules).\r\n    transpose(_, CtrRules, CtrRules) :- \\+ autoTransposition. \r\n    transpose([], CtrRules, CtrRules).\r\n    transpose([H|T], TempCtrRules, CtrRules) :-\r\n        transpose(T, TempCtrRules, CR),\r\n        findall(TrH, transposition(H, TrH), Tran),\r\n        mergeCtrRules(CR, Tran, CtrRules).\r\n    mergeCtrRules(All, ToMerge, X) :-\r\n        append(All, ToMerge, XT),\r\n        deduplicate(XT, X).\r\n    deduplicate([], []).\r\n    deduplicate([[RN,A,B]|T], X) :- deduplicate(T, TT), (member([RN,_,_], TT) -> X = TT; X = [[RN,A,B]|TT]). \r\n    transposition([Id, Prec, Effect], [Id, Prec, Effect]).\r\n    transposition([Id, Prec, Effect], [NewId, NewPrec ,XNegated]) :-\r\n        compound(Prec),\r\n        tuple_to_list(Prec, LPrec),!,\r\n        transposition_sequential(LPrec, LPrec, Effect, Id, [], NewPrec, XNegated, NewId).\r\n    transposition([Id, Prec, Effect], [NewId, EffectNegated ,XNegated]) :-\r\n        \\+ compound(Prec),\r\n        Prec \\== [],\r\n        prologEscape(Prec),\r\n        negate(Prec, XNegated),\r\n        negate(Effect, EffectNegated),\r\n        atom_concat(Id, '_i', NewId).\r\n    transposition_sequential(LPrec, [H|T], Effect, Id, Skipped, NewPrec, XNegated, NewId) :-\r\n        transposition_sequential(LPrec, T, Effect, Id, [H|Skipped], NewPrec, XNegated, NewId).\r\n    transposition_sequential(LPrec, [X|T], Effect, Id, Skipped, NewPrec, XNegated, NewId) :-\r\n        prologEscape(X),\r\n        append(Skipped, T, CleanedPrec),\r\n        negate(X, XNegated),\r\n        negate(Effect, EffectNegated),\r\n        list_to_tuple([EffectNegated|CleanedPrec], NewPrec),\r\n        newIdentifier(Skipped, Id, NewId).\r\n    newIdentifier(List, OldId, NewId) :-\r\n        modifier(List, Mod),\r\n        atom_concat(OldId, Mod, NewId).\r\n    modifier([], '_i').\r\n    modifier([_|Tail], Index):-\r\n        modifier(Tail, Index1),\r\n        atom_concat(Index1, 'i', Index).\r\n    negate(X, Arg) :-\r\n        functor(X, '-', _) -> (\r\n            arg(1, X, Arg));\r\n        functor(X, 'p', _) -> (\r\n            arg(1, X, PX),\r\n            (functor(PX, '-', _) -> (\r\n                arg(1, PX, PNX),\r\n                Arg = o(PNX)\r\n            );\r\n            Arg = o(-(PX))));\r\n        Arg = -(X).\r\n    prologEscape(X) :- \\+ functor(X, 'prolog', _), \\+ functor(X, '~', _).\r\n    /*\r\n     *   Standard rules (RuleName : Preconditions => Effects)\r\n     *   Special rules (RuleName : Effects)\r\n     */\r\n    convertAllRules([], []).\r\n    convertAllRules([[H,P,E]|T], [R|Rules]) :- convertRule(H, P, E, R), convertAllRules(T, Rules).\r\n    convertAllRules([[H,E]|T], [R|Rules]) :- convertRule(H, E, R), convertAllRules(T, Rules).\r\n    /*\r\n     *   Convert the given rule to the standard format\r\n     *   Example:\r\n     *   r2: followedGuidelines(X), doctor(X) => -liable(X)\r\n     *   rule([r2,[[followedGuidelines(X_e4149)],[doctor(X_e4149)]],[neg,liable(X_e4149)]]).\r\n     */\r\n    convertRule(RuleName, Preconditions, Effects, rule(List)) :-\r\n        tuple_to_list(Preconditions, Lprecond),\r\n        tuple_to_list(Effects, Leffects),\r\n        check_modifiers_in_list(preconditions, Lprecond, LprecondChecked),\r\n        check_modifiers_in_list(effects, Leffects, LeffectsChecked),\r\n        flatten_first_level(LeffectsChecked, LeffectsCheckedFlattened),\r\n        List = [RuleName, LprecondChecked, LeffectsCheckedFlattened].\r\n    /*\r\n     *   Convert the given special rule\r\n     *   Example:\r\n     *   bp(-liable(X)).\r\n     *   abastractBp([[neg, liable(X_e4149)]]).\r\n     */\r\n    convertRule(bps, Effects, abstractBp(Checked)) :-\r\n        functor(Effects, 'bp', _),\r\n        Effects =.. L,\r\n        removehead(L, LC),\r\n        check_modifiers_in_list(effects, LC, Checked).\r\n    convertRule(Name, Effects, premise([Name, LeffectsCheckedFlattened])) :-\r\n        tuple_to_list(Effects, Leffects),\r\n        check_modifiers_in_list(effects, Leffects, LeffectsChecked),\r\n        flatten_first_level(LeffectsChecked, LeffectsCheckedFlattened).\r\n    /*\r\n     *   Find negations(-), obligations(o), permissions(p) on a list of preconditions/effects and\r\n     *   raplace them with the assigned literal (neg, obl, perm)\r\n     */\r\n    check_modifiers_in_list(MODE, [], []).\r\n    check_modifiers_in_list(MODE, [H|T], L) :- H == [], L = [].\r\n    check_modifiers_in_list(MODE, [H|T], L) :- H \\== [],\r\n                                check_modifiers(H, LH),\r\n                                check_admissibility(MODE, H, LH),\r\n                                check_modifiers_in_list(MODE, T, LT),\r\n                                append([LH], LT, L).\r\n    check_admissibility(preconditions, H, LH) :-\r\n        \\+ defeasible_admissible(LH),\r\n        throw(['Premise  ', H, '  is not a well formed member of the argumentation language.']).\r\n    check_admissibility(effects, H, LH) :-\r\n        \\+ admissible(LH),\r\n        throw(['Conclusion  ', H, '  is not a well formed member of the argumentation language.']).\r\n    check_admissibility(_, _, _).\r\n    check_modifiers([], []).\r\n    check_modifiers(H, List) :-\r\n        functor(H, '-', _) -> (\r\n            arg(1, H, Arg),\r\n            check_modifiers(Arg, Lobl),\r\n            append([neg], Lobl, Lf),\r\n            List = Lf);\r\n        functor(H, 'o', _) -> (\r\n            arg(1, H, Arg),\r\n            check_modifiers(Arg, Lobl),\r\n            List = [obl|[Lobl]]);\r\n        functor(H, 'p', _) -> (\r\n            arg(1, H, Arg),\r\n            check_modifiers(Arg, Lper),\r\n            List = [perm|[Lper]]);\r\n        functor(H, '~', _) -> (\r\n            arg(1, H, Arg),\r\n            check_modifiers(Arg, Lper),\r\n            List = [unless|[Lper]]);\r\n        functor(H, 'bp', _) -> (\r\n            H =.. [_|Arg],\r\n            check_modifiers_in_list(effects, Arg, Lper),\r\n            List = [bp|[Lper]]);\r\n        List = [H].\r\n    /*\r\n     *   Convert the given tuple to list\r\n     */\r\n    tuple_to_list((A,B),L) :- tuple_to_list(A, La), tuple_to_list(B, Lb), append(La, Lb,L).\r\n    tuple_to_list(A,[A]) :- nonvar(A), A \\= (_ , _).\r\n    list_to_tuple([H], (H)).\r\n    list_to_tuple([H|T], (H,TT)) :- list_to_tuple(T,TT).\r\n    /*\r\n     *   Replace all the occurences of a given element with the given argument\r\n     */\r\n    replace(_, _, [],[]).\r\n    replace(O, R, [O|T], [R|T2]) :- replace(O, R, T, T2).\r\n    replace(O, R, [H|T], [H|T2]) :- H \\= O, replace(O, R, T, T2).\r\n    flatten_first_level([X], X).\r\n    flatten_first_level.\r\n    removehead([_|Tail], Tail).\r\n    in(A, A) :- nonvar(A), A \\= (_ , _).\r\n    in(A, (A, _)).\r\n    in(A, (_ , Cs)) :- in(A, Cs).\r\n    defeasible_admissible([unless, Term]) :- admissible(Term).\r\n    defeasible_admissible(Term) :- admissible(Term).\r\n    admissible([neg, bp, Term]) :- admissible_terms_complete(Term).\r\n    admissible([bp, Term]) :- admissible_terms_complete(Term).\r\n    admissible([neg, Term]) :- admissible_term(Term).\r\n    admissible([obl, [Term]]) :- admissible_term(Term).\r\n    admissible([obl, [neg, Term]]) :- admissible_term(Term).\r\n    admissible([neg, obl, [Term]]) :- admissible_term(Term).\r\n    admissible([neg, obl, [neg, Term]]) :- admissible_term(Term).\r\n    admissible([perm, [Term]]) :- admissible_term(Term).\r\n    admissible([perm, [neg, Term]]) :- admissible_term(Term).\r\n    admissible([Term]) :- admissible_term(Term).\r\n    admissible_term(Term) :-\r\n        atomic(Term),\r\n        Term \\== neg,\r\n        Term \\== obl,\r\n        Term \\== perm,\r\n        Term \\== unless,\r\n        Term \\== bp.\r\n    admissible_term(Term) :- var(Term).\r\n    admissible_term(Term) :-\r\n        compound(Term),\r\n        \\+ functor(Term, 'o', _),\r\n        \\+ functor(Term, 'p', _),\r\n        \\+ functor(Term, '-', _),\r\n        \\+ functor(Term, '~', _),\r\n        \\+ functor(Term, 'bp', _),\r\n        Term =.. [_|Args],\r\n        admissible_terms(Args).\r\n    admissible_terms([]).\r\n    admissible_terms([H|T]) :-\r\n        admissible_term(H),\r\n        admissible_terms(T).\r\n    admissible_terms_complete([]).\r\n    admissible_terms_complete([H|T]) :-\r\n        admissible(H),\r\n        admissible_terms_complete(T).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject StatementLabelling {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    statementLabelling :-\r\n        findall(_, (\r\n            context_check(in([_, _, Conc, _, _])),\r\n            \\+ context_check(statIn(Conc)),\r\n            context_assert(statIn(Conc))\r\n        ), _),\r\n        findall(_, (\r\n            context_check(out([_, _, Conc, _, _])),\r\n            \\+ context_check(statIn(Conc)),\r\n            \\+ context_check(statOut(Conc)),\r\n            context_assert(statOut(Conc))\r\n        ), _),\r\n        findall(_, (\r\n            context_check(und([_, _, Conc, _, _])),\r\n            \\+ context_check(statIn(Conc)),\r\n            \\+ context_check(statOut(Conc)),\r\n            \\+ context_check(statUnd(Conc)),\r\n            context_assert(statUnd(Conc))\r\n        ), _).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject SuperiorityRelation {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    superiorArgument(A, B) :- superiorArgumentSupportBuffered(A, B, _).\r\n    superiorArgument(A, B, SupSet) :- superiorArgumentSupportBuffered(A, B, SupSet).\r\n    superiorArgumentSupportBuffered(A, B, SupSet) :-\r\n        context_check(superior(A, B, SupSet, true)), !.\r\n    superiorArgumentSupportBuffered(A, B, SupSet) :-\r\n        context_check(superior(A, B, SupSet, false)),\r\n        fail, !.\r\n    superiorArgumentSupportBuffered(A, B, SupSet) :-\r\n        \\+ context_check(superior(A, B, _, _)),\r\n        superiorArgumentSupport(A, B, SupSet),\r\n        context_assert(superior(A, B, SupSet, true)), !.\r\n    superiorArgumentSupportBuffered(A, B, SupSet) :-\r\n        \\+ cache_check(superior(A, B, _, _)),\r\n        context_assert(superior(A, B, [], false)),\r\n        fail, !.\r\n    superiorArgumentSupport([_, _, _, _, [LastDefRulesA, DefRulesA, DefPremisesA]], [_, _, _, _, [LastDefRulesB, DefRulesB, DefPremisesB]], SupSet) :-\r\n    \tsuperiorArgumentSupport(LastDefRulesA, DefRulesA, DefPremisesA, LastDefRulesB, DefRulesB, DefPremisesB, SupSet).\r\n    superiorArgumentSupport(LastDefRulesA, _, DefPremisesA, LastDefRulesB, _, DefPremisesB, SupSet) :-\r\n        orderingPrinciple(last),\r\n    \tsuperior(LastDefRulesA, DefPremisesA, LastDefRulesB, DefPremisesB, SupSet).\r\n    superiorArgumentSupport(_, DefRulesA, DefPremisesA, _, DefRulesB, DefPremisesB, SupSet) :-\r\n        orderingPrinciple(weakest),\r\n    \tsuperior(DefRulesA, DefPremisesA, DefRulesB, DefPremisesB, SupSet).\r\n    superior([], PremisesA, [], PremisesB, SupSet) :-\r\n    \tweaker(PremisesB, PremisesA, SupSet).\r\n    superior(DefRulesA, _, DefRulesB, _, SupSet) :-\r\n    \torderingPrinciple(last),\r\n    \t(DefRulesA \\== []; DefRulesB \\== []),\r\n    \tweaker(DefRulesB, DefRulesA, SupSet).\r\n    superior(DefRulesA, [], DefRulesB, [], SupSet) :-\r\n    \torderingPrinciple(weakest),\r\n    \tweaker(DefRulesB, DefRulesA, SupSet).\r\n    superior(DefRulesA, PremisesA, DefRulesB, PremisesB, SupSet) :-\r\n    \torderingPrinciple(weakest),\r\n    \t(DefRulesA \\== []; DefRulesB \\== []),\r\n    \t(PremisesA \\== []; PremisesB \\== []),\r\n    \tweaker(DefRulesB, DefRulesA, SupSetA),\r\n    \tweaker(PremisesB, PremisesA, SupSetB),\r\n    \tutils::appendLists([SupSetA, SupSetB], SupSet).\r\n    weaker(RulesA, [], []) :-\r\n    \tRulesA \\== [].\r\n    weaker(RulesA, RulesB, SupSet) :-\r\n    \tRulesA \\== [],\r\n    \tRulesB \\== [],\r\n    \torderingComparator(elitist),\r\n    \tmember(Rule, RulesA),\r\n    \tallStronger(Rule, RulesB, SupSet), !.\r\n    weaker(RulesA, RulesB, SupSet) :-\r\n    \tRulesA \\== [],\r\n    \tRulesB \\== [],\r\n    \torderingComparator(democrat),\r\n    \tweakerDemo(RulesA, RulesB, SupSet).\r\n    weaker(RulesA, RulesB, [sup(X, W)]) :-\r\n    \tRulesA \\== [],\r\n    \tRulesB \\== [],\r\n    \torderingComparator(normal),\r\n    \tmember(W, RulesA),\r\n    \tmember(X, RulesB),\r\n    \tcontext_check(sup(X, W)), !.\r\n    weakerDemo([], _, []).\r\n    weakerDemo([H|T], Rules, [Sup|SupSet]) :-\r\n    \tsingleStronger(H, Rules, Sup),\r\n    \tweakerDemo(T, Rules, SupSet).\r\n    singleStronger(Target, Rules, sup(Rule, Target)) :-\r\n    \tmember(Rule, Rules),\r\n    \tcontext_check(sup(Rule, Target)), !.\r\n    allStronger(_, [], []).\r\n    allStronger(Target, [Rule|Rules], [sup(Rule, Target)|SupSet]) :-\r\n    \tcontext_check(sup(Rule, Target)),\r\n    \tallStronger(Target, Rules, SupSet).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.sources\r\n\r\nobject Utils {\r\n    val theoryCode: String =\r\n        \"\"\"\r\n    writeList([]) :- nl.\r\n    writeList([X|Others]) :-\r\n    \twrite(X),\r\n    \twriteList(Others).\r\n    writeListNl([]).\r\n    writeListNl([X|Others]) :-\r\n    \twrite(X),nl,\r\n    \twriteListNl(Others).\r\n    sortDistinct(List, Sorted) :-\r\n        deduplicate(List, Deduplicated),\r\n        sort(Deduplicated, Sorted).\r\n    deduplicate([], []).\r\n    deduplicate(List, Output) :-\r\n        List \\== [],\r\n        setof(X, member(X, List), Output).\r\n    sort(List,Sorted) :- q_sort(List, [], Sorted).\r\n    q_sort([], Acc, Acc).\r\n    q_sort([H|T], Acc, Sorted) :-\r\n    \tpivoting(H, T, L1, L2),\r\n    \tq_sort(L1, Acc, Sorted1),\r\n    \tq_sort(L2, [H|Sorted1], Sorted).\r\n    pivoting(H,[],[],[]).\r\n    pivoting(H, [X|T], [X|L], G) :-\r\n        H @>= X,\r\n        pivoting(H, T, L, G).\r\n    pivoting(H, [X|T], L, [X|G]) :-\r\n        X @> H,\r\n        pivoting(H, T, L, G).\r\n    subtract([], _, []).\r\n    subtract([Head|Tail], L2, L3) :-\r\n            member(Head, L2), !,\r\n            subtract(Tail, L2, L3).\r\n    subtract([Head|Tail1], L2, [Head|Tail3]) :-\r\n            subtract(Tail1, L2, Tail3).\r\n    isEmptyList([]).\r\n    appendLists([], []).\r\n    appendLists([H|T], R) :-\r\n        appendLists(T, AT),\r\n        append(H, AT, R).\r\n    search(F, L, S) :-\r\n       between(1, L, N),\r\n       functor(S, F, N),\r\n       call(S).\r\n    between(N, M, K) :- N < M, K = N.\r\n    between(N, M, K) :- N == M, !, K = N.\r\n    between(N, M, K) :- N < M, N1 is N+1, between(N1, M, K).\r\n    recoverGraph(Args, Attacks, Supports) :-\r\n            findall(X, context_check(argument(X)), TempArgs),\r\n            findall((T, A, B, C), context_check(attack(T, A, B, C)), TempAttacks),\r\n            findall((A, B), context_check(support(A, B)), TempSupports),\r\n            utils::sort(TempArgs, Args),\r\n            utils::sort(TempAttacks, Attacks),\r\n            utils::sort(TempSupports, Supports).\r\n    recoverArgumentLabelling(ArgsIn, ArgsOut, ArgsUnd) :-\r\n            findall(X, context_check(in(X)), TempArgsIn),\r\n            findall(X, context_check(out(X)), TempArgsOut),\r\n            findall(X, context_check(und(X)), TempArgsUnd),\r\n            utils::sort(TempArgsIn, ArgsIn),\r\n            utils::sort(TempArgsOut, ArgsOut),\r\n            utils::sort(TempArgsUnd, ArgsUnd).\r\n    recoverStatementLabelling(In, Out, Und) :-\r\n            findall(X, context_check(statIn(X)), TempIn),\r\n            findall(X, context_check(statOut(X)), TempOut),\r\n            findall(X, context_check(statUnd(X)), TempUnd),\r\n            utils::sort(TempIn, In),\r\n            utils::sort(TempOut, Out),\r\n            utils::sort(TempUnd, Und).\r\n        \"\"\".trimIndent()\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.structured\r\n\r\nactual object StructuredMode : StructuredModeBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.QueryMode.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.utils\r\n\r\nactual object Debug : DebugBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.Debug.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.utils\r\n\r\nactual object SuperiorityRelation : SuperiorityRelationBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.SuperiorityRelation.theoryCode\r\n}\r\n","package it.unibo.tuprolog.argumentation.core.libs.utils\r\n\r\nactual object Utils : UtilsBase() {\r\n    override val prologRawTheory: String\r\n        get() = it.unibo.tuprolog.argumentation.core.libs.sources.Utils.theoryCode\r\n}\r\n"],"names":[],"mappings":"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AAA,qB;IAAA,mD;G;oDAAA,Y;IAAA,2C;G;kDAAA,+B;IAAA,4D;G;+CAAA,qC;IAAA,+D;G;kDAAA,kB;IAAA,+C;G;mDAAA,kB;IAAA,gD;G;mDAAA,kB;IAAA,gD;G;4DAAA,iB;IAAA,wD;G;gDAAA,gB;IAAA,2C;G;iDAAA,iB;IAAA,6C;G;sDAAA,uB;IAAA,wD;G;sDAAA,uB;IAAA,wD;G;uDAAA,iC;IAAA,mE;G;uDAAA,wB;IAAA,0D;G;kDAAA,kB;IAAA,+C;G;iDAAA,+B;IAAA,2D;G;mDAAA,4B;IAAA,0D;G;gDAAA,iB;IAAA,4C;G;kDAAA,iB;IAAA,8C;G;wDAAA,iB;IAAA,oD;G;wDAAA,iB;IAAA,oD;G;gDAAA,gB;IAAA,2C;G;oDAAA,gB;IAAA,+C;G;iDAAA,qC;IAAA,iE;G;qDAAA,sB;IAAA,sD;G;yDAAA,sB;IAAA,0D;G;kDAAA,sB;IAAA,mD;G;mDAAA,sB;IAAA,oD;G;oDAAA,kB;IAAA,iD;G;iDAAA,sB;IAAA,kD;G;oDAAA,sB;IAAA,qD;G;mDAAA,e;IAAA,6C;G;sDAAA,oB;IAAA,qD;G;mDAAA,oB;IAAA,kD;G;qDAAA,sB;IAAA,sD;G;wDAAA,uB;IAAA,0D;G;sDAAA,0C;IAAA,2E;G;+DAAA,uB;IAAA,iE;G;oDAAA,sB;IAAA,qD;G;sDAAA,uB;IAAA,wD;G;yDAAA,uB;IAAA,2D;G;mDAAA,qB;IAAA,mD;G;+CAAA,sB;IAAA,gD;G;iDAAA,gB;IAAA,4C;G;oDAAA,gB;IAAA,+C;G;mDAAA,+B;IAAA,6D;G;iDAAA,kB;IAAA,8C;G;mDAAA,kC;IAAA,gE;G;8CAAA,oB;IAAA,6C;G;kDAAA,gB;IAAA,6C;G;mDAAA,e;IAAA,6C;G;sDAAA,uB;IAAA,wD;G;+DAAA,uB;IAAA,iE;G;0DAAA,gB;IAAA,qD;G;oDAAA,iB;IAAA,gD;G;gDAAA,iB;IAAA,4C;G;oDAAA,iB;IAAA,gD;G;qDAAA,iB;IAAA,iD;G;mDAAA,iB;IAAA,+C;G;wDAAA,wB;IAAA,2D;G;0DAAA,iB;IAAA,sD;G;mDAAA,kB;IAAA,gD;G;sDAAA,Y;IAAA,6C;G;qDAAA,Y;IAAA,4C;G;mDAAA,iB;IAAA,+C;G;kDAAA,iB;IAAA,8C;G;uDAAA,uB;IAAA,yD;G;2DAAA,uB;IAAA,6D;G;mEAAA,uB;IAAA,qE;G;mEAAA,uB;IAAA,qE;G;iDAAA,iB;IAAA,6C;G;oDAAA,iB;IAAA,gD;G;yDAAA,iB;IAAA,qD;G;yDAAA,iB;IAAA,qD;G;gDAAA,e;IAAA,0C;G;kDAAA,sB;IAAA,mD;G;+CAAA,gB;IAAA,0C;G;kDAAA,kB;IAAA,+C;G;kDAAA,kB;IAAA,+C;G;+CAAA,gB;IAAA,0C;G;oDAAA,iB;IAAA,gD;G;sDAAA,iB;IAAA,kD;G;qDAAA,iB;IAAA,iD;G;mDAAA,iB;IAAA,+C;G;oDAAA,iB;IAAA,gD;G;gDAAA,iB;IAAA,4C;G;qDAAA,iB;IAAA,iD;G;mDAAA,iB;IAAA,+C;G;0DAAA,iB;IAAA,sD;G;0DAAA,iB;IAAA,sD;G;kDAAA,kB;IAAA,+C;G;wDAAA,yB;IAAA,4D;G;wDAAA,yB;IAAA,4D;G;8CAAA,0C;IAAA,mE;G;iDAAA,iB;IAAA,6C;G;sDAAA,iB;IAAA,kD;G;oDAAA,iB;IAAA,gD;G;2DAAA,iB;IAAA,uD;G;mDAAA,kB;IAAA,gD;G;sDAAA,kB;IAAA,mD;G;+CAAA,sB;IAAA,gD;G;iDAAA,6B;IAAA,yD;G;gDAAA,sB;IAAA,iD;G;oDAAA,uB;IAAA,sD;G;2DAAA,uB;IAAA,6D;G;iDAAA,+B;IAAA,2D;G;iDAAA,gB;IAAA,4C;G;kDAAA,qB;IAAA,kD;G;mDAAA,yB;IAAA,uD;G;sDAAA,yB;IAAA,0D;G;2DAAA,yB;IAAA,+D;G;uDAAA,yB;IAAA,2D;G;2DAAA,yB;IAAA,+D;G;oDAAA,iD;IAAA,gF;G;iDAAA,iB;IAAA,6C;G;kDAAA,iB;IAAA,8C;G;kDAAA,iB;IAAA,8C;G;qDAAA,iB;IAAA,iD;G;0DAAA,iB;IAAA,sD;G;0DAAA,iB;IAAA,sD;G;+CAAA,gB;IAAA,0C;G;gDAAA,gB;IAAA,2C;G;mDAAA,Y;IAAA,0C;G;gDAAA,kB;IAAA,6C;G;+CAAA,kB;IAAA,4C;G;iDAAA,gB;IAAA,4C;G;+CAAA,4B;IAAA,sD;G;+CAAA,4B;IAAA,sD;G;gDAAA,4B;IAAA,uD;G;8CAAA,4B;IAAA,qD;G;oDAAA,4B;IAAA,2D;G;8CAAA,4B;IAAA,qD;G;mDAAA,4B;IAAA,0D;G;8CAAA,4B;IAAA,qD;G;iDAAA,4B;IAAA,wD;G;iDAAA,kC;IAAA,8D;G;iDAAA,4B;IAAA,wD;G;+DAAA,2B;IAAA,qE;G;kEAAA,2B;IAAA,wE;G;oEAAA,2B;IAAA,0E;G;iDAAA,4B;IAAA,wD;G;sDAAA,4B;IAAA,6D;G;0DAAA,2B;IAAA,gE;G;yDAAA,4B;IAAA,gE;G;mEAAA,4B;IAAA,0E;G;gDAAA,4B;IAAA,uD;G;sDAAA,4B;IAAA,6D;G;uDAAA,4B;IAAA,8D;G;6DAAA,4B;IAAA,oE;G;oDAAA,4B;IAAA,2D;G;uDAAA,kC;IAAA,oE;G;gDAAA,4B;IAAA,uD;G;uDAAA,4B;IAAA,8D;G;iEAAA,4B;IAAA,wE;G;mDAAA,4B;IAAA,0D;G;4DAAA,4B;IAAA,mE;G;0DAAA,4B;IAAA,iE;G;yDAAA,4B;IAAA,gE;G;gDAAA,4B;IAAA,uD;G;kDAAA,4B;IAAA,yD;G;iDAAA,4B;IAAA,wD;G;iDAAA,4B;IAAA,wD;G;iDAAA,4B;IAAA,wD;G;kDAAA,4B;IAAA,yD;G;mDAAA,4B;IAAA,0D;G;gDAAA,iC;IAAA,4D;G;mDAAA,iC;IAAA,+D;G;oDAAA,qB;IAAA,oD;G;gDAAA,4B;IAAA,uD;G;;;SAAoC,Y;MAAA,uC;K;;gDAAA,wB;IAAA,mD;G;8DAAA,2C;IAAA,oF;G;gDAAA,wC;IAAA,mE;G;8DAAA,2D;IAAA,oG;G;8CAAA,wB;IAAA,iD;G;oEAAA,2C;IAAA,0F;G;gDAAA,wB;IAAA,mD;G;8DAAA,2C;IAAA,oF;G;;;;;;EAEjE,gC;IAAmE,OAA8B,WAA9B,iCAA8B,C;G;;;+BCG7F,Y;IAAc,qB;G;iCACd,Y;IAAgB,uB;G;;;;;;EAGpB,0B;IACI,iCAA4C,qBAAY,Q;G;;;SACpD,Y;MAAqC,Q;MAA7B,OAAA,qBAAY,QAAQ,iBAAK,CAAI,8DAAS,qBAAY,QAArB,QAAJ,IAAkC,8BAAlC,GAA6C,qBAAY,QAAQ,iB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xD,M;EACX,C;6BAEA,Y;IACI,OAAc,QAAP,gBAAO,EAAM,IAAK,WAAX,C;EAClB,C;;;;;;iCAPJ,Y;IAAmB,qB;G;iCAAnB,Y;IAA4C,qB;G;mCAA5C,gC;IAAA,mBAAmB,iDAAnB,EAA4C,iDAA5C,C;G;+BAAA,Y;IAAA,c;IAAmB,0D;IAAyB,0D;IAA5C,a;G;6BAAA,iB;IAAA,4IAAmB,8CAAnB,IAA4C,8CAA5C,I;G;ECFA,2B;IAAA,+B;IAAgC,8B;G;;;SAExB,Y;MAAQ,OAAA,0CAA6B,W;K;;;;;;;;EAF7C,uC;IAAA,sC;MAAA,qB;KAAA,+B;G;ECFA,wB;IAAA,4B;IAA6B,2B;G;;;SAErB,Y;MAAQ,OAA+D,uC;K;;;;;;;;EAF/E,oC;IAAA,mC;MAAA,kB;KAAA,4B;G;ECAA,qC;IAAA,yC;IAA0C,wC;G;;;SAElC,Y;MAAQ,OAAqE,2C;K;;;;;;;;EAFrF,iD;IAAA,gD;MAAA,+B;KAAA,yC;G;ECAA,oC;IAAA,wC;IAAyC,uC;G;;;SAEjC,Y;MAAQ,OAAoE,0C;K;;;;;;;;EAFpF,gD;IAAA,+C;MAAA,8B;KAAA,wC;G;ECAA,8B;IAAA,kC;IAAmC,iC;G;;;SAE3B,Y;MAAQ,OAAqD,2B;K;;;;;;;;EAFrE,0C;IAAA,yC;MAAA,wB;KAAA,kC;G;ECAA,wC;IAAA,4C;IAA6C,2C;G;;;SAErC,Y;MAAQ,OAAiE,uC;K;;;;;;;;EAFjF,oD;IAAA,mD;MAAA,kC;KAAA,4C;G;ECAA,+C;IAAA,mD;IAAoD,kD;G;;;SAE5C,Y;MAAQ,OAAwE,8C;K;;;;;;;;EAFxF,2D;IAAA,0D;MAAA,yC;KAAA,mD;G;ECAA,oC;IAAA,wC;IAAyC,uC;G;;;SAEjC,Y;MAAQ,OAA8D,oC;K;;;;;;;;EAF9E,gD;IAAA,+C;MAAA,8B;KAAA,wC;G;ECAA,8B;IAAA,kC;IAAmC,iC;G;;;SAE3B,Y;MAAQ,OAAqE,2C;K;;;;;;;;EAFrF,0C;IAAA,yC;MAAA,wB;KAAA,kC;G;ECAA,sB;IAAA,0B;IAA2B,yB;G;;;SAEnB,Y;MAAQ,OAA6D,mC;K;;;;;;;;EAF7E,kC;IAAA,iC;MAAA,gB;KAAA,0B;G;ECAA,6B;IAAA,iC;IAAkC,gC;G;;;SAE1B,Y;MAAQ,OAAoE,0C;K;;;;;;;;EAFpF,yC;IAAA,wC;MAAA,uB;KAAA,iC;G;ECAA,4B;IAAA,gC;IAAiC,+B;G;;;SAEzB,Y;MAAQ,OAA2D,iC;K;;;;;;;;EAF3E,wC;IAAA,uC;MAAA,sB;KAAA,gC;G;ECAA,4B;IAAA,gC;IAAiC,+B;G;;;SAEzB,Y;MAAQ,OAA2D,iC;K;;;;;;;;EAF3E,wC;IAAA,uC;MAAA,sB;KAAA,gC;G;ECAA,6B;IAAA,iC;IAAkC,gC;G;;;SAE1B,Y;MAAQ,OAAqE,2C;K;;;;;;;;EAFrF,yC;IAAA,wC;MAAA,uB;KAAA,iC;G;ECEA,sB;IAAA,0B;IAA2B,yB;G;;;SAEnB,Y;MAAQ,OAAA,4BAAe,W;K;;;;;;;;EAF/B,kC;IAAA,iC;MAAA,gB;KAAA,0B;G;ECFA,0B;IAAA,8B;IACI,kBA4BQ,WA3BJ,s+BA2BI,C;G;;;;;;;EA7BZ,sC;IAAA,qC;MAAA,oB;KAAA,8B;G;ECAA,wC;IAAA,4C;IACI,kBAqBQ,WApBJ,8/BAoBI,C;G;;;;;;;EAtBZ,oD;IAAA,mD;MAAA,kC;KAAA,4C;G;ECAA,8B;IAAA,kC;IACI,kBAiIQ,WAhIJ,uuMAgII,C;G;;;;;;;EAlIZ,0C;IAAA,yC;MAAA,wB;KAAA,kC;G;ECAA,6B;IAAA,iC;IACI,kBAgBQ,WAfJ,+mBAeI,C;G;;;;;;;EAjBZ,yC;IAAA,wC;MAAA,uB;KAAA,iC;G;ECAA,c;IAAA,kB;IACI,kBAiDQ,WAhDJ,o2EAgDI,C;G;;;;;;;EAlDZ,0B;IAAA,yB;MAAA,Q;KAAA,kB;G;ECAA,sB;IAAA,0B;IACI,kBAiFQ,WAhFJ,quFAgFI,C;G;;;;;;;EAlFZ,kC;IAAA,iC;MAAA,gB;KAAA,0B;G;ECAA,8B;IAAA,kC;IACI,kBAkBQ,WAjBJ,uyBAiBI,C;G;;;;;;;EAnBZ,0C;IAAA,yC;MAAA,wB;KAAA,kC;G;ECAA,6B;IAAA,iC;IACI,kBA8KQ,WA7KJ,+qPA6KI,C;G;;;;;;;EA/KZ,yC;IAAA,wC;MAAA,uB;KAAA,iC;G;ECAA,6B;IAAA,iC;IACI,kBA0WQ,WAzWJ,wniBAyWI,C;G;;;;;;;EA3WZ,yC;IAAA,wC;MAAA,uB;KAAA,iC;G;ECAA,oB;IAAA,wB;IACI,kBA8BQ,WA7BJ,4hCA6BI,C;G;;;;;;;EA/BZ,gC;IAAA,+B;MAAA,c;KAAA,wB;G;ECAA,iB;IAAA,qB;IACI,kBAyCQ,WAxCJ,i4DAwCI,C;G;;;;;;;EA1CZ,6B;IAAA,4B;MAAA,W;KAAA,qB;G;ECAA,0B;IAAA,8B;IACI,kBAwEQ,WAvEJ,k1GAuEI,C;G;;;;;;;EAzEZ,sC;IAAA,qC;MAAA,oB;KAAA,8B;G;ECAA,iC;IAAA,qC;IACI,kBAqCQ,WApCJ,4lDAoCI,C;G;;;;;;;EAtCZ,6C;IAAA,4C;MAAA,2B;KAAA,qC;G;ECAA,oB;IAAA,wB;IACI,kBA0BQ,WAzBJ,k6BAyBI,C;G;;;;;;;EA3BZ,gC;IAAA,+B;MAAA,c;KAAA,wB;G;ECAA,uB;IAAA,2B;IACI,kBAeQ,WAdJ,ioBAcI,C;G;;;;;;;EAhBZ,mC;IAAA,kC;MAAA,iB;KAAA,2B;G;ECAA,uB;IAAA,2B;IACI,kBAqIQ,WApIJ,qkOAoII,C;G;;;;;;;EAtIZ,mC;IAAA,kC;MAAA,iB;KAAA,2B;G;ECAA,0B;IAAA,8B;IACI,kBAiOQ,WAhOJ,o7TAgOI,C;G;;;;;;;EAlOZ,sC;IAAA,qC;MAAA,oB;KAAA,8B;G;ECAA,8B;IAAA,kC;IACI,kBAqBQ,WApBJ,8sBAoBI,C;G;;;;;;;EAtBZ,0C;IAAA,yC;MAAA,wB;KAAA,kC;G;ECAA,+B;IAAA,mC;IACI,kBAwEQ,WAvEJ,0wGAuEI,C;G;;;;;;;EAzEZ,2C;IAAA,0C;MAAA,yB;KAAA,mC;G;ECAA,iB;IAAA,qB;IACI,kBAqEQ,WApEJ,0iFAoEI,C;G;;;;;;;EAtEZ,6B;IAAA,4B;MAAA,W;KAAA,qB;G;ECAA,0B;IAAA,8B;IAA+B,6B;G;;;SAEvB,Y;MAAQ,OAA4D,oC;K;;;;;;;;EAF5E,sC;IAAA,qC;MAAA,oB;KAAA,8B;G;ECAA,mB;IAAA,uB;IAAsB,oB;G;;;SAEd,Y;MAAQ,OAAwD,8B;K;;;;;;;;EAFxE,+B;IAAA,8B;MAAA,a;KAAA,uB;G;ECAA,iC;IAAA,qC;IAAoC,kC;G;;;SAE5B,Y;MAAQ,OAAsE,4C;K;;;;;;;;EAFtF,6C;IAAA,4C;MAAA,2B;KAAA,qC;G;ECAA,mB;IAAA,uB;IAAsB,oB;G;;;SAEd,Y;MAAQ,OAAwD,8B;K;;;;;;;;EAFxE,+B;IAAA,8B;MAAA,a;KAAA,uB;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}