(self.webpackChunk_tuprolog_arg2p_playground=self.webpackChunk_tuprolog_arg2p_playground||[]).push([[541],{3874:t=>{function e(t){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}e.keys=()=>[],e.resolve=e,e.id=3874,t.exports=e},2277:function(t,e,n){var r,o,i;function a(t){return a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},a(t)}o=[e,n(7252),n(5751),n(9245),n(3205),n(3954),n(8931),n(4135),n(441),n(7428),n(8879)],void 0===(i="function"==typeof(r=function(t,e,n,r,o,i,s,u,p,l,c){"use strict";var d=n.it.unibo.tuprolog.solve.library.Libraries,f=e.kotlin.collections.listOf_mh5how$,m=e.kotlin.collections.plus_mydzjv$,g=e.Kind.CLASS,y=e.Kind.OBJECT,h=e.Kind.INTERFACE,_=e.kotlin.collections.listOf_i5x0yv$,b=e.kotlin.collections.collectionSizeOrDefault_ba2ldo$,A=e.kotlin.collections.ArrayList_init_ww73n8$,$=e.kotlin.UnsupportedOperationException_init_pdl1vj$,O=r.it.unibo.tuprolog.dsl.theory.PrologScopeWithTheories,T=o.it.unibo.tuprolog.dsl.PrologScope,R=i.it.unibo.tuprolog.unify.Unificator,N=s.it.unibo.tuprolog.core.operators.OperatorSet,S=e.kotlin.collections.union_q4559j$,v=n.it.unibo.tuprolog.solve.library.Library,k=u.it.unibo.tuprolog.theory.Theory,C=p.it.unibo.tuprolog.theory.parsing.parseTheoryWithOperators,P=e.kotlin.lazy_klfg04$,B=n.it.unibo.tuprolog.solve.primitive.Primitive,I=e.kotlin.sequences.sequenceOf_i5x0yv$,x=n.it.unibo.tuprolog.solve.Signature,L=e.kotlin.sequences.map_z5avom$,D=e.kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED,U=e.kotlin.coroutines.CoroutineImpl,w=e.kotlin.sequences.sequence_o0x0bg$,j=e.kotlin.collections.emptyList_287e2$,E=n.it.unibo.tuprolog.solve.MutableSolver,z=u.it.unibo.tuprolog.theory.MutableTheory,G=l.it.unibo.tuprolog.solve.classic.classicMutableSolver,X=n.it.unibo.tuprolog.solve.flags,q=e.kotlin.collections.mapCapacity_za3lpa$,H=e.kotlin.ranges.coerceAtLeast_dqglrj$,M=e.kotlin.collections.LinkedHashMap_init_bwtc7$,F=s.it.unibo.tuprolog.core.Substitution,W=s.it.unibo.tuprolog.core.Numeric,V=e.ensureNotNull,Y=e.kotlin.to_ujzrz7$,Q=e.kotlin.collections.mutableMapOf_qfcya0$,K=s.it.unibo.tuprolog.core.Atom,Z=n.it.unibo.tuprolog.solve.exception.error.TypeError,J=n.it.unibo.tuprolog.solve.exception.error.TypeError.Expected,tt=s.it.unibo.tuprolog.core.Struct,et=e.throwCCE,nt=e.equals,rt=n.it.unibo.tuprolog.solve.exception.error.DomainError,ot=n.it.unibo.tuprolog.solve.exception.error.DomainError.Expected,it=e.kotlin.Unit,at=e.kotlin.sequences.filter_euau3h$,st=e.kotlin.sequences.first_veqyi0$,ut=o.it.unibo.tuprolog.dsl.prolog,pt=s.it.unibo.tuprolog.core.operators.Specifier,lt=s.it.unibo.tuprolog.core.operators.Operator,ct=s.it.unibo.tuprolog.core.operators.OperatorSet_init_1gzv2l$,dt=e.kotlin.collections.ArrayList_init_287e2$,ft=s.it.unibo.tuprolog.core.Clause,mt=c.it.unibo.tuprolog.core.parsing.parseClause,gt=c.it.unibo.tuprolog.core.parsing.parseStruct,yt=e.kotlin.text.trimIndent_pdl1vz$,ht=p.it.unibo.tuprolog.theory.parsing.parseTheory,_t=e.kotlin.collections.mapOf_x2b85n$,bt=s.it.unibo.tuprolog.core.List,At=n.it.unibo.tuprolog.solve.Solution.Yes,$t=n.it.unibo.tuprolog.solve.Solver,Ot=l.it.unibo.tuprolog.solve.classic.classicSolver,Tt=e.toString,Rt=r.it.unibo.tuprolog.dsl.theory.prolog,Nt=e.kotlin.text.contains_li3zpu$,St=e.kotlin.text.removeSurrounding_gsj5wt$,vt=e.kotlin.sequences.toList_veqyi0$,kt=e.getPropertyCallableRef,Ct=e.kotlin.collections.mapOf_qfcya0$,Pt=s.it.unibo.tuprolog.core.Var,Bt=e.kotlin.collections.first_2p1efm$,It=n.it.unibo.tuprolog.solve.primitive.PrimitiveWrapper,xt=e.kotlin.random.Random,Lt=s.it.unibo.tuprolog.core.listToTerm,Dt=n.it.unibo.tuprolog.solve.primitive.UnaryPredicate.WithoutSideEffects,Ut=e.kotlin.collections.copyToArray,wt=e.kotlin.comparisons.compareBy_bvgy4j$,jt=e.kotlin.sequences.sortedWith_vjgqpk$,Et=e.kotlin.sequences.mapIndexed_b7yuyq$,zt=e.kotlin.sequences.firstOrNull_veqyi0$,Gt=e.kotlin.NoSuchElementException,Xt=e.kotlin.collections.addAll_ipc267$,qt=e.kotlin.collections.firstOrNull_2p1efm$,Ht=e.kotlin.collections.plus_qloxvw$,Mt=s.it.unibo.tuprolog.core.Cons;function Ft(){Qt()}function Wt(){Yt=this}function Vt(t,e){this.closure$staticLibs=t,this.closure$dynamicLibs=e,this.loader_gxu4sn$_0=new Se(this);var n,r,o=this.operators();for(n=t.iterator();n.hasNext();)n.next().theoryOperators=o;for(r=e.iterator();r.hasNext();)r.next().theoryOperators=o}re.prototype=Object.create(te.prototype),re.prototype.constructor=re,se.prototype=Object.create(te.prototype),se.prototype.constructor=se,fe.prototype=Object.create(te.prototype),fe.prototype.constructor=fe,Pe.prototype=Object.create(ve.prototype),Pe.prototype.constructor=Pe,Be.prototype=Object.create(ve.prototype),Be.prototype.constructor=Be,Se.prototype=Object.create(te.prototype),Se.prototype.constructor=Se,xe.prototype=Object.create(re.prototype),xe.prototype.constructor=xe,je.prototype=Object.create(te.prototype),je.prototype.constructor=je,Ee.prototype=Object.create(te.prototype),Ee.prototype.constructor=Ee,Xe.prototype=Object.create(te.prototype),Xe.prototype.constructor=Xe,tn.prototype=Object.create(re.prototype),tn.prototype.constructor=tn,mn.prototype=Object.create(re.prototype),mn.prototype.constructor=mn,gn.prototype=Object.create(re.prototype),gn.prototype.constructor=gn,yn.prototype=Object.create(re.prototype),yn.prototype.constructor=yn,hn.prototype=Object.create(re.prototype),hn.prototype.constructor=hn,_n.prototype=Object.create(re.prototype),_n.prototype.constructor=_n,bn.prototype=Object.create(re.prototype),bn.prototype.constructor=bn,An.prototype=Object.create(re.prototype),An.prototype.constructor=An,$n.prototype=Object.create(re.prototype),$n.prototype.constructor=$n,On.prototype=Object.create(re.prototype),On.prototype.constructor=On,Tn.prototype=Object.create(re.prototype),Tn.prototype.constructor=Tn,Rn.prototype=Object.create(re.prototype),Rn.prototype.constructor=Rn,Nn.prototype=Object.create(re.prototype),Nn.prototype.constructor=Nn,Sn.prototype=Object.create(re.prototype),Sn.prototype.constructor=Sn,wn.prototype=Object.create(Dt.prototype),wn.prototype.constructor=wn,zn.prototype=Object.create(Dt.prototype),zn.prototype.constructor=zn,Hn.prototype=Object.create(Dt.prototype),Hn.prototype.constructor=Hn,Vn.prototype=Object.create(Dt.prototype),Vn.prototype.constructor=Vn,Kn.prototype=Object.create(Dt.prototype),Kn.prototype.constructor=Kn,er.prototype=Object.create(re.prototype),er.prototype.constructor=er,ir.prototype=Object.create(re.prototype),ir.prototype.constructor=ir,ar.prototype=Object.create(re.prototype),ar.prototype.constructor=ar,fr.prototype=Object.create(re.prototype),fr.prototype.constructor=fr,Qr.prototype=Object.create(xe.prototype),Qr.prototype.constructor=Qr,Jr.prototype=Object.create(tn.prototype),Jr.prototype.constructor=Jr,no.prototype=Object.create(mn.prototype),no.prototype.constructor=no,io.prototype=Object.create(gn.prototype),io.prototype.constructor=io,uo.prototype=Object.create(yn.prototype),uo.prototype.constructor=uo,co.prototype=Object.create(hn.prototype),co.prototype.constructor=co,go.prototype=Object.create(_n.prototype),go.prototype.constructor=go,_o.prototype=Object.create(bn.prototype),_o.prototype.constructor=_o,$o.prototype=Object.create(An.prototype),$o.prototype.constructor=$o,Ro.prototype=Object.create($n.prototype),Ro.prototype.constructor=Ro,vo.prototype=Object.create(On.prototype),vo.prototype.constructor=vo,Po.prototype=Object.create(Tn.prototype),Po.prototype.constructor=Po,xo.prototype=Object.create(Rn.prototype),xo.prototype.constructor=xo,Uo.prototype=Object.create(Nn.prototype),Uo.prototype.constructor=Uo,Eo.prototype=Object.create(Sn.prototype),Eo.prototype.constructor=Eo,Wi.prototype=Object.create(er.prototype),Wi.prototype.constructor=Wi,Qi.prototype=Object.create(ir.prototype),Qi.prototype.constructor=Qi,Ji.prototype=Object.create(ar.prototype),Ji.prototype.constructor=Ji,na.prototype=Object.create(fr.prototype),na.prototype.constructor=na,Ft.prototype.to2pLibraries=function(){var t,e=d.Companion,n=m(f(this.loader),this.staticLibraries()),r=A(b(n,10));for(t=n.iterator();t.hasNext();){var o=t.next();r.add_11rb$(o.content())}return e.ofIterable(r)},Ft.prototype.operators=function(){var t,e=m(f(this.loader),this.staticLibraries()),n=A(b(e,10));for(t=e.iterator();t.hasNext();){var r=t.next();n.add_11rb$(r.theoryOperators)}var o=n.iterator();if(!o.hasNext())throw $("Empty collection can't be reduced.");for(var i=o.next();o.hasNext();)i=i.plusOperatorSet(o.next());return i},Object.defineProperty(Vt.prototype,"loader",{configurable:!0,get:function(){return this.loader_gxu4sn$_0}}),Vt.prototype.staticLibraries=function(){return this.closure$staticLibs},Vt.prototype.dynamicLibraries=function(){return this.closure$dynamicLibs},Vt.$metadata$={kind:g,interfaces:[Ft]},Wt.prototype.of_gdqvf0$=function(t,e){return new Vt(t,e)},Wt.$metadata$={kind:y,simpleName:"Companion",interfaces:[]};var Yt=null;function Qt(){return null===Yt&&new Wt,Yt}function Kt(){}function Zt(){this.$delegate_38xz9p$_0=T.Companion.empty(),this.$delegate_38xz9p$_1=R.Companion.default}function Jt(){}function te(){this.theoryOperators_ahsrz3$_0=N.Companion.DEFAULT}function ee(){}function ne(){}function re(){var t;te.call(this),this.prologTheory_8ne57d$_0=P((t=this,function(){return C(k.Companion,t.prologRawTheory,t.theoryOperators)}))}function oe(){}function ie(){}function ae(){}function se(){te.call(this);var t=G(E.Companion,void 0,void 0,k.Companion.empty(),z.Companion.empty());t.setFlag(X.Unknown.name,X.Unknown.FAIL),this.solver_0=t,this.alias_9zj9cx$_0="prolog.argumentation.cache"}function ue(t){this.$outer=t,this.signature_rygzz7$_0=new x("cache_assert",1)}function pe(t){this.$outer=t,this.signature_v7ocho$_0=new x("cache_retract",1)}function le(t){this.$outer=t,this.signature_ctt1s7$_0=new x("cache_check",1)}function ce(t){return function(e){return t.replyWith(e.substitution,void 0,[])}}function de(t,e,n,r,o,i){U.call(this,i),this.$controller=o,this.exceptionState_0=1,this.local$this$Cache=t,this.local$closure$term=e,this.local$closure$request=n,this.local$$receiver=r}function fe(){te.call(this),this.nextSolver_0=1,this.selectedSolver_0=0;var t=G(E.Companion,void 0,void 0,k.Companion.empty(),z.Companion.empty());t.setFlag(X.Unknown.name,X.Unknown.FAIL),this.dynamicSolver_0=Q([Y(0,t)]),this.alias_476cz2$_0="prolog.argumentation.context"}function me(t){this.$outer=t,this.signature_2h7q5o$_0=new x("context_reset",0)}function ge(t){this.$outer=t,this.signature_mutw6$_0=new x("context_active",1)}function ye(t){this.$outer=t,this.signature_i9b2qn$_0=new x("context_checkout",1)}function he(t){this.$outer=t,this.signature_m17fgj$_0=new x("context_branch",2)}function _e(t){this.$outer=t,this.signature_t5avxd$_0=new x("context_assert",1)}function be(t){this.$outer=t,this.signature_5o25xi$_0=new x("context_retract",1)}function Ae(t){this.$outer=t,this.signature_g5067v$_0=new x("context_check",1)}function $e(t){return function(e){return t.replyWith(e.substitution,void 0,[])}}function Oe(t,e,n,r,o,i){U.call(this,i),this.$controller=o,this.exceptionState_0=1,this.local$this$Context=t,this.local$closure$term=e,this.local$closure$request=n,this.local$$receiver=r}function Te(t){this.$outer=t,this.signature_abym9i$_0=new x("context_check",2)}function Re(t){return function(e){return t.replyWith(e.substitution,void 0,[])}}function Ne(t,e,n,r,o,i,a){U.call(this,a),this.$controller=i,this.exceptionState_0=1,this.local$this$Context=t,this.local$closure$index=e,this.local$closure$term=n,this.local$closure$request=r,this.local$$receiver=o}function Se(t){te.call(this),this.solver_0=t,this.alias_wn4lox$_0="prolog.argumentation.loader",this.theoryOperators=ct([new lt("::",pt.XFX,700),new lt(":::",pt.XFX,700)])}function ve(t){this.$outer=t}function ke(t){return function(e){return t.replyWith(e.substitution,void 0,[])}}function Ce(t,e,n,r,o,i){U.call(this,i),this.$controller=o,this.exceptionState_0=1,this.local$closure$solver=t,this.local$closure$goal=e,this.local$closure$request=n,this.local$$receiver=r}function Pe(t){this.$outer=t,ve.call(this,this.$outer),this.signature_il52vq$_0=new x("::",2)}function Be(t){this.$outer=t,ve.call(this,this.$outer),this.signature_6wblmq$_0=new x(":::",2)}function Ie(t){return t.isYes}function xe(){re.call(this),this.alias_6anqe1$_0="prolog.argumentation.interface",this.theoryOperators=ct([new lt("=>",pt.XFX,1199),new lt(":=>",pt.XFX,1199),new lt(":->",pt.XFX,1199),new lt(":",pt.XFX,1001),new lt(":=",pt.XFX,1199)])}function Le(t,e,n,r,o,i,a,s,u,p){we(),void 0===t&&(t=or().default()),void 0===e&&(e=Cn().default()),void 0===n&&(n=In().default()),void 0===r&&(r=fn().default()),void 0===o&&(o=sn().default()),void 0===i&&(i=ln().default()),void 0===a&&(a=pr().default()),void 0===s&&(s=dr().default()),void 0===u&&(u=We().default()),void 0===p&&(p=rn().default()),this.queryMode=t,this.autoTransposition=e,this.prologStrictCompatibility=n,this.graphBuildMode=r,this.argumentLabellingMode=o,this.statementLabellingMode=i,this.orderingPrinciple=a,this.orderingComparator=s,this.modulesPath=u,this.graphExtensions=p}function De(){Ue=this}Ft.$metadata$={kind:h,simpleName:"Arg2pSolver",interfaces:[]},Kt.prototype.call_k9kufj$=function(t,e){return this.structOf("::",[this.anyToTerm(t),this.anyToTerm(e)])},Kt.$metadata$={kind:h,simpleName:"PrologWithArgumentation",interfaces:[O]},Object.defineProperty(Zt.prototype,"A",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.A}}),Object.defineProperty(Zt.prototype,"B",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.B}}),Object.defineProperty(Zt.prototype,"C",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.C}}),Object.defineProperty(Zt.prototype,"D",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.D}}),Object.defineProperty(Zt.prototype,"E",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.E}}),Object.defineProperty(Zt.prototype,"F",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.F}}),Object.defineProperty(Zt.prototype,"G",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.G}}),Object.defineProperty(Zt.prototype,"H",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.H}}),Object.defineProperty(Zt.prototype,"I",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.I}}),Object.defineProperty(Zt.prototype,"J",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.J}}),Object.defineProperty(Zt.prototype,"K",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.K}}),Object.defineProperty(Zt.prototype,"L",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.L}}),Object.defineProperty(Zt.prototype,"M",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.M}}),Object.defineProperty(Zt.prototype,"N",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.N}}),Object.defineProperty(Zt.prototype,"O",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.O}}),Object.defineProperty(Zt.prototype,"P",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.P}}),Object.defineProperty(Zt.prototype,"Q",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.Q}}),Object.defineProperty(Zt.prototype,"R",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.R}}),Object.defineProperty(Zt.prototype,"S",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.S}}),Object.defineProperty(Zt.prototype,"T",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.T}}),Object.defineProperty(Zt.prototype,"U",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.U}}),Object.defineProperty(Zt.prototype,"V",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.V}}),Object.defineProperty(Zt.prototype,"W",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.W}}),Object.defineProperty(Zt.prototype,"X",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.X}}),Object.defineProperty(Zt.prototype,"Y",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.Y}}),Object.defineProperty(Zt.prototype,"Z",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.Z}}),Object.defineProperty(Zt.prototype,"_",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0._}}),Object.defineProperty(Zt.prototype,"at_end_of_stream",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.at_end_of_stream}}),Object.defineProperty(Zt.prototype,"cut",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.cut}}),Object.defineProperty(Zt.prototype,"emptyBlock",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.emptyBlock}}),Object.defineProperty(Zt.prototype,"emptyList",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.emptyList}}),Object.defineProperty(Zt.prototype,"fail",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.fail}}),Object.defineProperty(Zt.prototype,"halt",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.halt}}),Object.defineProperty(Zt.prototype,"nl",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.nl}}),Object.defineProperty(Zt.prototype,"repeat",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.repeat}}),Object.defineProperty(Zt.prototype,"variables",{configurable:!0,get:function(){return this.$delegate_38xz9p$_0.variables}}),Zt.prototype.abolish1=function(t){return this.$delegate_38xz9p$_0.abolish1(t)},Zt.prototype.anonymous=function(){return this.$delegate_38xz9p$_0.anonymous()},Zt.prototype.append3=function(t,e,n){return this.$delegate_38xz9p$_0.append3(t,e,n)},Zt.prototype.arg3=function(t,e,n){return this.$delegate_38xz9p$_0.arg3(t,e,n)},Zt.prototype.assert1=function(t){return this.$delegate_38xz9p$_0.assert1(t)},Zt.prototype.asserta1=function(t){return this.$delegate_38xz9p$_0.asserta1(t)},Zt.prototype.assertz1=function(t){return this.$delegate_38xz9p$_0.assertz1(t)},Zt.prototype.at_end_of_stream1=function(t){return this.$delegate_38xz9p$_0.at_end_of_stream1(t)},Zt.prototype.atom1=function(t){return this.$delegate_38xz9p$_0.atom1(t)},Zt.prototype.atomOf=function(t){return this.$delegate_38xz9p$_0.atomOf(t)},Zt.prototype.atom_chars2=function(t,e){return this.$delegate_38xz9p$_0.atom_chars2(t,e)},Zt.prototype.atom_codes2=function(t,e){return this.$delegate_38xz9p$_0.atom_codes2(t,e)},Zt.prototype.atom_concat3=function(t,e,n){return this.$delegate_38xz9p$_0.atom_concat3(t,e,n)},Zt.prototype.atom_length2=function(t,e){return this.$delegate_38xz9p$_0.atom_length2(t,e)},Zt.prototype.atomic1=function(t){return this.$delegate_38xz9p$_0.atomic1(t)},Zt.prototype.bagof3=function(t,e,n){return this.$delegate_38xz9p$_0.bagof3(t,e,n)},Zt.prototype.between3=function(t,e,n){return this.$delegate_38xz9p$_0.between3(t,e,n)},Zt.prototype.setOf=function(t){return this.$delegate_38xz9p$_0.setOf(t)},Zt.prototype.blockOf=function(t){return this.$delegate_38xz9p$_0.blockOf(t)},Zt.prototype.setOfIterable=function(t){return this.$delegate_38xz9p$_0.setOfIterable(t)},Zt.prototype.setOfSequence=function(t){return this.$delegate_38xz9p$_0.setOfSequence(t)},Zt.prototype.call1=function(t){return this.$delegate_38xz9p$_0.call1(t)},Zt.prototype.callable1=function(t){return this.$delegate_38xz9p$_0.callable1(t)},Zt.prototype.catch3=function(t,e,n){return this.$delegate_38xz9p$_0.catch3(t,e,n)},Zt.prototype.char_code2=function(t,e){return this.$delegate_38xz9p$_0.char_code2(t,e)},Zt.prototype.clause_fzbqwd$=function(t){return this.$delegate_38xz9p$_0.clause_fzbqwd$(t)},Zt.prototype.clause2=function(t,e){return this.$delegate_38xz9p$_0.clause2(t,e)},Zt.prototype.clauseOf=function(t,e){return this.$delegate_38xz9p$_0.clauseOf(t,e)},Zt.prototype.compound1=function(t){return this.$delegate_38xz9p$_0.compound1(t)},Zt.prototype.consOf=function(t,e){return this.$delegate_38xz9p$_0.consOf(t,e)},Zt.prototype.consOfAny=function(t,e){return this.$delegate_38xz9p$_0.consOfAny(t,e)},Zt.prototype.consult1=function(t){return this.$delegate_38xz9p$_0.consult1(t)},Zt.prototype.containsVar=function(t){return this.$delegate_38xz9p$_0.containsVar(t)},Zt.prototype.contains=function(t){return this.$delegate_38xz9p$_0.contains(t)},Zt.prototype.copy_term2=function(t,e){return this.$delegate_38xz9p$_0.copy_term2(t,e)},Zt.prototype.current_flag2=function(t,e){return this.$delegate_38xz9p$_0.current_flag2(t,e)},Zt.prototype.current_op3=function(t,e,n){return this.$delegate_38xz9p$_0.current_op3(t,e,n)},Zt.prototype.current_prolog_flag2=function(t,e){return this.$delegate_38xz9p$_0.current_prolog_flag2(t,e)},Zt.prototype.directive=function(t){return this.$delegate_38xz9p$_0.directive(t)},Zt.prototype.directiveOf=function(t,e){return this.$delegate_38xz9p$_0.directiveOf(t,e)},Zt.prototype.directiveOfAny=function(t,e){return this.$delegate_38xz9p$_0.directiveOfAny(t,e)},Zt.prototype.dynamic1=function(t){return this.$delegate_38xz9p$_0.dynamic1(t)},Zt.prototype.fact=function(t){return this.$delegate_38xz9p$_0.fact(t)},Zt.prototype.factOf=function(t){return this.$delegate_38xz9p$_0.factOf(t)},Zt.prototype.factOfAny=function(t){return this.$delegate_38xz9p$_0.factOfAny(t)},Zt.prototype.findall3=function(t,e,n){return this.$delegate_38xz9p$_0.findall3(t,e,n)},Zt.prototype.float1=function(t){return this.$delegate_38xz9p$_0.float1(t)},Zt.prototype.functor3=function(t,e,n){return this.$delegate_38xz9p$_0.functor3(t,e,n)},Zt.prototype.get=function(t){return this.$delegate_38xz9p$_0.get(t)},Zt.prototype.ground1=function(t){return this.$delegate_38xz9p$_0.ground1(t)},Zt.prototype.include1=function(t){return this.$delegate_38xz9p$_0.include1(t)},Zt.prototype.indicatorOf=function(t,e){return this.$delegate_38xz9p$_0.indicatorOf(t,e)},Zt.prototype.indicatorOfStringInt=function(t,e){return this.$delegate_38xz9p$_0.indicatorOfStringInt(t,e)},Zt.prototype.initialization1=function(t){return this.$delegate_38xz9p$_0.initialization1(t)},Zt.prototype.intOfByte=function(t){return this.$delegate_38xz9p$_0.intOfByte(t)},Zt.prototype.intOf=function(t){return this.$delegate_38xz9p$_0.intOf(t)},Zt.prototype.intOfLong=function(t){return this.$delegate_38xz9p$_0.intOfLong(t)},Zt.prototype.intOfShort=function(t){return this.$delegate_38xz9p$_0.intOfShort(t)},Zt.prototype.parseInt=function(t){return this.$delegate_38xz9p$_0.parseInt(t)},Zt.prototype.parseIntRadix=function(t,e){return this.$delegate_38xz9p$_0.parseIntRadix(t,e)},Zt.prototype.intOfBigInteger=function(t){return this.$delegate_38xz9p$_0.intOfBigInteger(t)},Zt.prototype.integer1=function(t){return this.$delegate_38xz9p$_0.integer1(t)},Zt.prototype.ktEmptyList=function(){return this.$delegate_38xz9p$_0.ktEmptyList()},Zt.prototype.ktEmptySet=function(){return this.$delegate_38xz9p$_0.ktEmptySet()},Zt.prototype.ktListOf=function(t){return this.$delegate_38xz9p$_0.ktListOf(t)},Zt.prototype.ktSetOf=function(t){return this.$delegate_38xz9p$_0.ktSetOf(t)},Zt.prototype.list$default=function(t,e){return this.$delegate_38xz9p$_0.list$default(t,e)},Zt.prototype.listFrom$default=function(t,e){return this.$delegate_38xz9p$_0.listFrom$default(t,e)},Zt.prototype.listFromIterable$default=function(t,e){return this.$delegate_38xz9p$_0.listFromIterable$default(t,e)},Zt.prototype.listFromSequence$default=function(t,e){return this.$delegate_38xz9p$_0.listFromSequence$default(t,e)},Zt.prototype.listOf=function(t){return this.$delegate_38xz9p$_0.listOf(t)},Zt.prototype.listOfAny=function(t){return this.$delegate_38xz9p$_0.listOfAny(t)},Zt.prototype.listOfIterable=function(t){return this.$delegate_38xz9p$_0.listOfIterable(t)},Zt.prototype.listOfSequence=function(t){return this.$delegate_38xz9p$_0.listOfSequence(t)},Zt.prototype.load1=function(t){return this.$delegate_38xz9p$_0.load1(t)},Zt.prototype.member2=function(t,e){return this.$delegate_38xz9p$_0.member2(t,e)},Zt.prototype.naf1=function(t){return this.$delegate_38xz9p$_0.naf1(t)},Zt.prototype.natural=function(t){return this.$delegate_38xz9p$_0.natural(t)},Zt.prototype.nonvar1=function(t){return this.$delegate_38xz9p$_0.nonvar1(t)},Zt.prototype.not1=function(t){return this.$delegate_38xz9p$_0.not1(t)},Zt.prototype.numOfByte=function(t){return this.$delegate_38xz9p$_0.numOfByte(t)},Zt.prototype.numOfDouble=function(t){return this.$delegate_38xz9p$_0.numOfDouble(t)},Zt.prototype.numOfFloat=function(t){return this.$delegate_38xz9p$_0.numOfFloat(t)},Zt.prototype.numOfInt=function(t){return this.$delegate_38xz9p$_0.numOfInt(t)},Zt.prototype.numOfLong=function(t){return this.$delegate_38xz9p$_0.numOfLong(t)},Zt.prototype.numOf=function(t){return this.$delegate_38xz9p$_0.numOf(t)},Zt.prototype.numOfShort=function(t){return this.$delegate_38xz9p$_0.numOfShort(t)},Zt.prototype.parseNum=function(t){return this.$delegate_38xz9p$_0.parseNum(t)},Zt.prototype.numOfBigDecimal=function(t){return this.$delegate_38xz9p$_0.numOfBigDecimal(t)},Zt.prototype.numOfBigInteger=function(t){return this.$delegate_38xz9p$_0.numOfBigInteger(t)},Zt.prototype.number1=function(t){return this.$delegate_38xz9p$_0.number1(t)},Zt.prototype.number_chars2=function(t,e){return this.$delegate_38xz9p$_0.number_chars2(t,e)},Zt.prototype.number_codes2=function(t,e){return this.$delegate_38xz9p$_0.number_codes2(t,e)},Zt.prototype.op3=function(t,e,n){return this.$delegate_38xz9p$_0.op3(t,e,n)},Zt.prototype.realOf=function(t){return this.$delegate_38xz9p$_0.realOf(t)},Zt.prototype.realOfFloat=function(t){return this.$delegate_38xz9p$_0.realOfFloat(t)},Zt.prototype.parseReal=function(t){return this.$delegate_38xz9p$_0.parseReal(t)},Zt.prototype.realOfBigDecimal=function(t){return this.$delegate_38xz9p$_0.realOfBigDecimal(t)},Zt.prototype.retract1=function(t){return this.$delegate_38xz9p$_0.retract1(t)},Zt.prototype.retractall1=function(t){return this.$delegate_38xz9p$_0.retractall1(t)},Zt.prototype.rule=function(t){return this.$delegate_38xz9p$_0.rule(t)},Zt.prototype.ruleOf=function(t,e,n){return this.$delegate_38xz9p$_0.ruleOf(t,e,n)},Zt.prototype.scope=function(t){return this.$delegate_38xz9p$_0.scope(t)},Zt.prototype.set_flag2=function(t,e){return this.$delegate_38xz9p$_0.set_flag2(t,e)},Zt.prototype.set_prolog_flag2=function(t,e){return this.$delegate_38xz9p$_0.set_prolog_flag2(t,e)},Zt.prototype.setof3=function(t,e,n){return this.$delegate_38xz9p$_0.setof3(t,e,n)},Zt.prototype.solve1=function(t){return this.$delegate_38xz9p$_0.solve1(t)},Zt.prototype.static1=function(t){return this.$delegate_38xz9p$_0.static1(t)},Zt.prototype.structOf=function(t,e){return this.$delegate_38xz9p$_0.structOf(t,e)},Zt.prototype.structOfAny=function(t,e){return this.$delegate_38xz9p$_0.structOfAny(t,e)},Zt.prototype.structOfIterable=function(t,e){return this.$delegate_38xz9p$_0.structOfIterable(t,e)},Zt.prototype.structOfList=function(t,e){return this.$delegate_38xz9p$_0.structOfList(t,e)},Zt.prototype.structOfSequence=function(t,e){return this.$delegate_38xz9p$_0.structOfSequence(t,e)},Zt.prototype.sub_atom5=function(t,e,n,r,o){return this.$delegate_38xz9p$_0.sub_atom5(t,e,n,r,o)},Zt.prototype.throw1=function(t){return this.$delegate_38xz9p$_0.throw1(t)},Zt.prototype.truthOf=function(t){return this.$delegate_38xz9p$_0.truthOf(t)},Zt.prototype.tupleOf=function(t){return this.$delegate_38xz9p$_0.tupleOf(t)},Zt.prototype.tupleOfAny=function(t){return this.$delegate_38xz9p$_0.tupleOfAny(t)},Zt.prototype.tupleOfIterable=function(t){return this.$delegate_38xz9p$_0.tupleOfIterable(t)},Zt.prototype.tupleOfSequence=function(t){return this.$delegate_38xz9p$_0.tupleOfSequence(t)},Zt.prototype.var1=function(t){return this.$delegate_38xz9p$_0.var1(t)},Zt.prototype.varOf=function(t){return this.$delegate_38xz9p$_0.varOf(t)},Zt.prototype.whatever=function(){return this.$delegate_38xz9p$_0.whatever()},Zt.prototype.where=function(t){return this.$delegate_38xz9p$_0.where(t)},Zt.prototype.with=function(t){return this.$delegate_38xz9p$_0.with(t)},Zt.prototype.write1=function(t){return this.$delegate_38xz9p$_0.write1(t)},Zt.prototype.neq2=function(t,e){return this.$delegate_38xz9p$_0.neq2(t,e)},Zt.prototype.nid2=function(t,e){return this.$delegate_38xz9p$_0.nid2(t,e)},Zt.prototype.power=function(t,e){return this.$delegate_38xz9p$_0.power(t,e)},Zt.prototype.eq2=function(t,e){return this.$delegate_38xz9p$_0.eq2(t,e)},Zt.prototype.arithNeq2=function(t,e){return this.$delegate_38xz9p$_0.arithNeq2(t,e)},Zt.prototype.id2=function(t,e){return this.$delegate_38xz9p$_0.id2(t,e)},Zt.prototype.arithEq2=function(t,e){return this.$delegate_38xz9p$_0.arithEq2(t,e)},Zt.prototype.pow=function(t,e){return this.$delegate_38xz9p$_0.pow(t,e)},Zt.prototype.anyAnd=function(t,e){return this.$delegate_38xz9p$_0.anyAnd(t,e)},Zt.prototype.append=function(t,e,n){return this.$delegate_38xz9p$_0.append(t,e,n)},Zt.prototype.concat=function(t,e){return this.$delegate_38xz9p$_0.concat(t,e)},Zt.prototype.substitutionContains=function(t,e){return this.$delegate_38xz9p$_0.substitutionContains(t,e)},Zt.prototype.substitutionContainsKey=function(t,e){return this.$delegate_38xz9p$_0.substitutionContainsKey(t,e)},Zt.prototype.substitutionContainsValue=function(t,e){return this.$delegate_38xz9p$_0.substitutionContainsValue(t,e)},Zt.prototype.anyDiv=function(t,e){return this.$delegate_38xz9p$_0.anyDiv(t,e)},Zt.prototype.anyEqualsTo=function(t,e){return this.$delegate_38xz9p$_0.anyEqualsTo(t,e)},Zt.prototype.substitutionGet=function(t,e){return this.$delegate_38xz9p$_0.substitutionGet(t,e)},Zt.prototype.anyGreaterThan=function(t,e){return this.$delegate_38xz9p$_0.anyGreaterThan(t,e)},Zt.prototype.anyGreaterThanOrEqualsTo=function(t,e){return this.$delegate_38xz9p$_0.anyGreaterThanOrEqualsTo(t,e)},Zt.prototype.anyIf=function(t,e){return this.$delegate_38xz9p$_0.anyIf(t,e)},Zt.prototype.anyIfVararg=function(t,e){return this.$delegate_38xz9p$_0.anyIfVararg(t,e)},Zt.prototype.anyImpliedBy=function(t,e){return this.$delegate_38xz9p$_0.anyImpliedBy(t,e)},Zt.prototype.anyImpliedByVararg=function(t,e){return this.$delegate_38xz9p$_0.anyImpliedByVararg(t,e)},Zt.prototype.anyIntDiv=function(t,e){return this.$delegate_38xz9p$_0.anyIntDiv(t,e)},Zt.prototype.stringInvoke=function(t,e,n){return this.$delegate_38xz9p$_0.stringInvoke(t,e,n)},Zt.prototype.anyIs=function(t,e){return this.$delegate_38xz9p$_0.anyIs(t,e)},Zt.prototype.anyLowerThan=function(t,e){return this.$delegate_38xz9p$_0.anyLowerThan(t,e)},Zt.prototype.anyLowerThanOrEqualsTo=function(t,e){return this.$delegate_38xz9p$_0.anyLowerThanOrEqualsTo(t,e)},Zt.prototype.anyMinus=function(t,e){return this.$delegate_38xz9p$_0.anyMinus(t,e)},Zt.prototype.anyNonGreaterThan=function(t,e){return this.$delegate_38xz9p$_0.anyNonGreaterThan(t,e)},Zt.prototype.anyNonLowerThan=function(t,e){return this.$delegate_38xz9p$_0.anyNonLowerThan(t,e)},Zt.prototype.anyNotEqualsTo=function(t,e){return this.$delegate_38xz9p$_0.anyNotEqualsTo(t,e)},Zt.prototype.anyOr=function(t,e){return this.$delegate_38xz9p$_0.anyOr(t,e)},Zt.prototype.anyPlus=function(t,e){return this.$delegate_38xz9p$_0.anyPlus(t,e)},Zt.prototype.anyPow=function(t,e){return this.$delegate_38xz9p$_0.anyPow(t,e)},Zt.prototype.anyRem=function(t,e){return this.$delegate_38xz9p$_0.anyRem(t,e)},Zt.prototype.anySup=function(t,e){return this.$delegate_38xz9p$_0.anySup(t,e)},Zt.prototype.anyThen=function(t,e){return this.$delegate_38xz9p$_0.anyThen(t,e)},Zt.prototype.anyTimes=function(t,e){return this.$delegate_38xz9p$_0.anyTimes(t,e)},Zt.prototype.varTo=function(t,e){return this.$delegate_38xz9p$_0.varTo(t,e)},Zt.prototype.stringTo=function(t,e){return this.$delegate_38xz9p$_0.stringTo(t,e)},Zt.prototype.anyToTerm=function(t){return this.$delegate_38xz9p$_0.anyToTerm(t)},Zt.prototype.univ2=function(t,e){return this.$delegate_38xz9p$_0.univ2(t,e)},Object.defineProperty(Zt.prototype,"context",{configurable:!0,get:function(){return this.$delegate_38xz9p$_1.context}}),Zt.prototype.match=function(t,e){return this.$delegate_38xz9p$_1.match(t,e)},Zt.prototype.matchWithOccurCheck=function(t,e,n){return this.$delegate_38xz9p$_1.matchWithOccurCheck(t,e,n)},Zt.prototype.merge=function(t,e){return this.$delegate_38xz9p$_1.merge(t,e)},Zt.prototype.mergeWithOccurCheck=function(t,e,n){return this.$delegate_38xz9p$_1.mergeWithOccurCheck(t,e,n)},Zt.prototype.mgu=function(t,e){return this.$delegate_38xz9p$_1.mgu(t,e)},Zt.prototype.mguWithOccurCheck$default=function(t,e,n){return this.$delegate_38xz9p$_1.mguWithOccurCheck$default(t,e,n)},Zt.prototype.unify=function(t,e){return this.$delegate_38xz9p$_1.unify(t,e)},Zt.prototype.unifyWithOccurCheck=function(t,e,n){return this.$delegate_38xz9p$_1.unifyWithOccurCheck(t,e,n)},Zt.$metadata$={kind:g,simpleName:"PrologWithArgumentationImpl",interfaces:[Kt,R,T]},Jt.prototype.flags=function(){return this.baseFlags},Jt.prototype.content=function(){return this.baseContent},Jt.$metadata$={kind:h,simpleName:"ArgLibrary",interfaces:[]},Object.defineProperty(te.prototype,"theoryOperators",{configurable:!0,get:function(){var t;return N.Companion.DEFAULT.plusOperatorSet(null!=(t=this.theoryOperators_ahsrz3$_0)&&t.equals(N.Companion.DEFAULT)?this.theoryOperators_ahsrz3$_0:N.Companion.DEFAULT.plusOperatorSet(this.theoryOperators_ahsrz3$_0))},set:function(t){this.theoryOperators_ahsrz3$_0=t}}),te.$metadata$={kind:g,simpleName:"BaseArgLibrary",interfaces:[Jt]},ee.prototype.flags=function(){return S(this.baseFlags,this.parentLibrary.flags())},ee.prototype.content=function(){return v.Companion.aliased(this.baseContent.alias,void 0,this.baseContent.theory.plusTheory(this.parentLibrary.content().theory))},ee.$metadata$={kind:h,simpleName:"UnionArgLibrary",interfaces:[Jt]},ne.$metadata$={kind:h,simpleName:"RawPrologContent",interfaces:[]},Object.defineProperty(re.prototype,"prologTheory",{configurable:!0,get:function(){return this.prologTheory_8ne57d$_0.value}}),re.$metadata$={kind:g,simpleName:"LazyRawPrologContent",interfaces:[ne,te]},oe.$metadata$={kind:h,simpleName:"Loadable",interfaces:[]},ie.$metadata$={kind:h,simpleName:"ArgsFlag",interfaces:[]},ae.$metadata$={kind:h,simpleName:"PrimitiveWithSignature",interfaces:[B]},Object.defineProperty(ue.prototype,"signature",{configurable:!0,get:function(){return this.signature_rygzz7$_0}}),ue.prototype.solve=function(t){var e=t.arguments.get_za3lpa$(0);return this.$outer.solver_0.assertAFact(e.castToStruct()),I([t.replyWithCondition(!0,void 0,[])])},ue.$metadata$={kind:g,simpleName:"CacheAssert",interfaces:[ae]},Object.defineProperty(pe.prototype,"signature",{configurable:!0,get:function(){return this.signature_v7ocho$_0}}),pe.prototype.solve=function(t){var e=t.arguments.get_za3lpa$(0);return this.$outer.solver_0.retractAllBeHead(e.castToStruct()),I([t.replyWithCondition(!0,void 0,[])])},pe.$metadata$={kind:g,simpleName:"CacheRetract",interfaces:[ae]},Object.defineProperty(le.prototype,"signature",{configurable:!0,get:function(){return this.signature_ctt1s7$_0}}),de.$metadata$={kind:e.Kind.CLASS,simpleName:null,interfaces:[U]},de.prototype=Object.create(U.prototype),de.prototype.constructor=de,de.prototype.doResume=function(){for(;;)try{switch(this.state_0){case 0:if(this.state_0=2,this.result_0=this.local$$receiver.yieldAll_swo9gw$(L(this.local$this$Cache.solver_0.solve(this.local$closure$term.castToStruct()),ce(this.local$closure$request)),this),this.result_0===D)return D;continue;case 1:throw this.exception_0;case 2:return this.result_0;default:throw this.state_0=1,new Error("State Machine Unreachable execution")}}catch(t){if(1===this.state_0)throw this.exceptionState_0=this.state_0,t;this.state_0=this.exceptionState_0,this.exception_0=t}},le.prototype.solve=function(t){var e,n,r,o=t.arguments.get_za3lpa$(0);return w((e=this.$outer,n=o,r=t,function(t,o,i){var a=new de(e,n,r,t,this,o);return i?a:a.doResume(null)}))},le.$metadata$={kind:g,simpleName:"CacheGet",interfaces:[ae]},Object.defineProperty(se.prototype,"alias",{configurable:!0,get:function(){return this.alias_9zj9cx$_0}}),Object.defineProperty(se.prototype,"baseContent",{configurable:!0,get:function(){var t,e=_([new ue(this),new pe(this),new le(this)]),n=v.Companion,r=this.alias,o=H(q(b(e,10)),16),i=M(o);for(t=e.iterator();t.hasNext();){var a=t.next();i.put_xwzc9p$(a.signature,a)}return n.aliased(r,i)}}),Object.defineProperty(se.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),se.$metadata$={kind:g,simpleName:"Cache",interfaces:[te]},Object.defineProperty(me.prototype,"signature",{configurable:!0,get:function(){return this.signature_2h7q5o$_0}}),me.prototype.solve=function(t){this.$outer.selectedSolver_0=0,this.$outer.nextSolver_0=1,this.$outer.dynamicSolver_0.clear();var e=this.$outer.dynamicSolver_0,n=G(E.Companion,void 0,void 0,k.Companion.empty(),z.Companion.empty());return n.setFlag(X.Unknown.name,X.Unknown.FAIL),e.put_xwzc9p$(0,n),I([t.replyWithCondition(!0,void 0,[])])},me.$metadata$={kind:g,simpleName:"DynamicCacheReset",interfaces:[ae]},Object.defineProperty(ge.prototype,"signature",{configurable:!0,get:function(){return this.signature_mutw6$_0}}),ge.prototype.solve=function(t){var e=t.arguments.get_za3lpa$(0);return I([t.replyWith(F.Companion.of(e.castToVar(),W.Companion.ofInteger(this.$outer.selectedSolver_0)),void 0,[])])},ge.$metadata$={kind:g,simpleName:"DynamicCacheSelected",interfaces:[ae]},Object.defineProperty(ye.prototype,"signature",{configurable:!0,get:function(){return this.signature_i9b2qn$_0}}),ye.prototype.solve=function(t){var e=t.arguments.get_za3lpa$(0).castToInteger().intValue.toInt(),n=this.$outer.dynamicSolver_0.keys.contains_11rb$(e);return this.$outer.selectedSolver_0=e,I([t.replyWithCondition(n,void 0,[])])},ye.$metadata$={kind:g,simpleName:"DynamicCacheCheckout",interfaces:[ae]},Object.defineProperty(he.prototype,"signature",{configurable:!0,get:function(){return this.signature_m17fgj$_0}}),he.prototype.solve=function(t){var e,n,r,o=t.arguments.get_za3lpa$(0).castToInteger().intValue.toInt(),i=t.arguments.get_za3lpa$(1),a=this.$outer.dynamicSolver_0,s=this.$outer.nextSolver_0,u=G(E.Companion,void 0,void 0,k.Companion.empty(),z.Companion.ofIterable(V(this.$outer.dynamicSolver_0.get_11rb$(o)).dynamicKb));return u.setFlag(X.Unknown.name,X.Unknown.FAIL),a.put_xwzc9p$(s,u),n=this.$outer,e=(r=this.$outer).nextSolver_0,r.nextSolver_0=e+1|0,n.selectedSolver_0=e,I([t.replyWith(F.Companion.of(i.castToVar(),W.Companion.ofInteger(this.$outer.selectedSolver_0)),void 0,[])])},he.$metadata$={kind:g,simpleName:"DynamicCacheBranch",interfaces:[ae]},Object.defineProperty(_e.prototype,"signature",{configurable:!0,get:function(){return this.signature_t5avxd$_0}}),_e.prototype.solve=function(t){var e=t.arguments.get_za3lpa$(0);return V(this.$outer.dynamicSolver_0.get_11rb$(this.$outer.selectedSolver_0)).assertAFact(e.castToStruct()),I([t.replyWithCondition(!0,void 0,[])])},_e.$metadata$={kind:g,simpleName:"DynamicCacheAssert",interfaces:[ae]},Object.defineProperty(be.prototype,"signature",{configurable:!0,get:function(){return this.signature_5o25xi$_0}}),be.prototype.solve=function(t){var e=t.arguments.get_za3lpa$(0);return V(this.$outer.dynamicSolver_0.get_11rb$(this.$outer.selectedSolver_0)).retractAllBeHead(e.castToStruct()),I([t.replyWithCondition(!0,void 0,[])])},be.$metadata$={kind:g,simpleName:"DynamicCacheRetract",interfaces:[ae]},Object.defineProperty(Ae.prototype,"signature",{configurable:!0,get:function(){return this.signature_g5067v$_0}}),Oe.$metadata$={kind:e.Kind.CLASS,simpleName:null,interfaces:[U]},Oe.prototype=Object.create(U.prototype),Oe.prototype.constructor=Oe,Oe.prototype.doResume=function(){for(;;)try{switch(this.state_0){case 0:if(this.state_0=2,this.result_0=this.local$$receiver.yieldAll_swo9gw$(L(V(this.local$this$Context.dynamicSolver_0.get_11rb$(this.local$this$Context.selectedSolver_0)).solve(this.local$closure$term.castToStruct()),$e(this.local$closure$request)),this),this.result_0===D)return D;continue;case 1:throw this.exception_0;case 2:return this.result_0;default:throw this.state_0=1,new Error("State Machine Unreachable execution")}}catch(t){if(1===this.state_0)throw this.exceptionState_0=this.state_0,t;this.state_0=this.exceptionState_0,this.exception_0=t}},Ae.prototype.solve=function(t){var e,n,r,o=t.arguments.get_za3lpa$(0);return w((e=this.$outer,n=o,r=t,function(t,o,i){var a=new Oe(e,n,r,t,this,o);return i?a:a.doResume(null)}))},Ae.$metadata$={kind:g,simpleName:"DynamicCacheGet",interfaces:[ae]},Object.defineProperty(Te.prototype,"signature",{configurable:!0,get:function(){return this.signature_abym9i$_0}}),Ne.$metadata$={kind:e.Kind.CLASS,simpleName:null,interfaces:[U]},Ne.prototype=Object.create(U.prototype),Ne.prototype.constructor=Ne,Ne.prototype.doResume=function(){for(;;)try{switch(this.state_0){case 0:if(this.state_0=2,this.result_0=this.local$$receiver.yieldAll_swo9gw$(L(V(this.local$this$Context.dynamicSolver_0.get_11rb$(this.local$closure$index)).solve(this.local$closure$term.castToStruct()),Re(this.local$closure$request)),this),this.result_0===D)return D;continue;case 1:throw this.exception_0;case 2:return this.result_0;default:throw this.state_0=1,new Error("State Machine Unreachable execution")}}catch(t){if(1===this.state_0)throw this.exceptionState_0=this.state_0,t;this.state_0=this.exceptionState_0,this.exception_0=t}},Te.prototype.solve=function(t){var e,n,r,o,i=V(t.arguments.get_za3lpa$(0).asNumeric()).intValue.toInt(),a=t.arguments.get_za3lpa$(1);return w((e=this.$outer,n=i,r=a,o=t,function(t,i,a){var s=new Ne(e,n,r,o,t,this,i);return a?s:s.doResume(null)}))},Te.$metadata$={kind:g,simpleName:"DynamicCacheGetIndexed",interfaces:[ae]},Object.defineProperty(fe.prototype,"alias",{configurable:!0,get:function(){return this.alias_476cz2$_0}}),Object.defineProperty(fe.prototype,"baseContent",{configurable:!0,get:function(){var t,e=_([new me(this),new ye(this),new ge(this),new he(this),new _e(this),new be(this),new Ae(this),new Te(this)]),n=v.Companion,r=this.alias,o=H(q(b(e,10)),16),i=M(o);for(t=e.iterator();t.hasNext();){var a=t.next();i.put_xwzc9p$(a.signature,a)}return n.aliased(r,i)}}),Object.defineProperty(fe.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),fe.$metadata$={kind:g,simpleName:"Context",interfaces:[te]},Ce.$metadata$={kind:e.Kind.CLASS,simpleName:null,interfaces:[U]},Ce.prototype=Object.create(U.prototype),Ce.prototype.constructor=Ce,Ce.prototype.doResume=function(){for(;;)try{switch(this.state_0){case 0:if(this.state_0=2,this.result_0=this.local$$receiver.yieldAll_swo9gw$(L(this.local$closure$solver.solve(this.local$closure$goal),ke(this.local$closure$request)),this),this.result_0===D)return D;continue;case 1:throw this.exception_0;case 2:return this.result_0;default:throw this.state_0=1,new Error("State Machine Unreachable execution")}}catch(t){if(1===this.state_0)throw this.exceptionState_0=this.state_0,t;this.state_0=this.exceptionState_0,this.exception_0=t}},ve.prototype.solve=function(t){var n,r=t.arguments.get_za3lpa$(0),o=t.arguments.get_za3lpa$(1);if(!e.isType(r,K))throw Z.Companion.forGoal(t.context,t.signature,J.LIST,r);if(!e.isType(o,tt))throw Z.Companion.forGoal(t.context,t.signature,J.CALLABLE,o);var i,a=this.$outer.solver_0.dynamicLibraries();t:do{var s;for(s=a.iterator();s.hasNext();){var u,p=s.next();if(nt((e.isType(u=p,oe)?u:et()).identifier(),r.toString())){i=p;break t}}i=null}while(0);if(null==(n=i))throw rt.Companion.forGoal(t.context,t.signature,ot.Companion.of("Loadable Lib"),r);this.$outer;var l,c=this.$outer,f=t.context,m=d.Companion,g=t.context.libraries.libraries,y=dt();for(l=g.iterator();l.hasNext();){var h,_=l.next(),$=c.solver_0.dynamicLibraries(),O=A(b($,10));for(h=$.iterator();h.hasNext();){var T=h.next();O.add_11rb$(T.alias)}O.contains_11rb$(_.alias)||y.add_11rb$(_)}var R,N,S,v=f.createMutableSolver(m.ofIterable(y).plus(n.content()),void 0,t.context.staticKb);return this.execute_khyi1m$(r.toString(),v),w((R=v,N=o,S=t,function(t,e,n){var r=new Ce(R,N,S,t,this,e);return n?r:r.doResume(null)}))},ve.$metadata$={kind:g,simpleName:"AbstractWithLib",interfaces:[B]},Object.defineProperty(Pe.prototype,"signature",{configurable:!0,get:function(){return this.signature_il52vq$_0}}),Pe.prototype.execute_khyi1m$=function(t,e){},Pe.$metadata$={kind:g,simpleName:"WithLib",interfaces:[ve]},Object.defineProperty(Be.prototype,"signature",{configurable:!0,get:function(){return this.signature_6wblmq$_0}}),Be.prototype.execute_khyi1m$=function(t,e){var n;ut((n=e,function(t){var e;for(e=at(n.solve(t.stringInvoke("context_active",t.X,[])),Ie).iterator();e.hasNext();){var r=e.next();st(n.solve(t.stringInvoke("context_branch",V(r.substitution.get_11rb$(t.X)),[t._])))}return it}))},Be.$metadata$={kind:g,simpleName:"WithLibInNewContext",interfaces:[ve]},Object.defineProperty(Se.prototype,"alias",{configurable:!0,get:function(){return this.alias_wn4lox$_0}}),Object.defineProperty(Se.prototype,"baseContent",{configurable:!0,get:function(){var t,e=_([new Pe(this),new Be(this)]),n=v.Companion,r=this.alias,o=H(q(b(e,10)),16),i=M(o);for(t=e.iterator();t.hasNext();){var a=t.next();i.put_xwzc9p$(a.signature,a)}return n.aliased(r,i,void 0,ct([new lt("::",pt.XFX,700),new lt(":::",pt.XFX,700)]))}}),Object.defineProperty(Se.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),Se.$metadata$={kind:g,simpleName:"DynamicLoader",interfaces:[te]},Object.defineProperty(xe.prototype,"alias",{configurable:!0,get:function(){return this.alias_6anqe1$_0}}),Object.defineProperty(xe.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory,ct([new lt("=>",pt.XFX,1199),new lt(":=>",pt.XFX,1199),new lt(":->",pt.XFX,1199),new lt(":",pt.XFX,1001),new lt(":=",pt.XFX,1199)]))}}),Object.defineProperty(xe.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),xe.$metadata$={kind:g,simpleName:"EngineInterfaceBase",interfaces:[re,Jt]},De.prototype.setupSolver_ds05wj$=function(t){var e,n=z.Companion.empty();for(e=t.graphExtensions.iterator();e.hasNext();){var r=e.next();n.assertA(mt(ft.Companion,rn().predicate()+"(X) :- X = "+r))}return t.queryMode&&n.assertAFact(gt(tt.Companion,or().predicate())),t.autoTransposition&&n.assertAFact(gt(tt.Companion,Cn().predicate())),t.prologStrictCompatibility&&n.assertAFact(gt(tt.Companion,In().predicate())),n.assertAFact(gt(tt.Companion,fn().predicate()+"("+t.graphBuildMode+")")),n.assertAFact(gt(tt.Companion,sn().predicate()+"("+t.argumentLabellingMode+")")),n.assertAFact(gt(tt.Companion,ln().predicate()+"("+t.statementLabellingMode+")")),n.assertAFact(gt(tt.Companion,pr().predicate()+"("+t.orderingPrinciple+")")),n.assertAFact(gt(tt.Companion,dr().predicate()+"("+t.orderingComparator+")")),n.assertAFact(gt(tt.Companion,We().predicate()+"("+t.modulesPath+")")),n},De.$metadata$={kind:y,simpleName:"Companion",interfaces:[]};var Ue=null;function we(){return null===Ue&&new De,Ue}function je(t){this.this$FlagsBuilder=t,te.call(this),this.alias_jy93v2$_0="prolog.argumentation.flags"}function Ee(){ze=this,te.call(this),this.alias_j6xthy$_0="prolog.argumentation.meta.crossjustice"}Le.prototype.queryMode_6taknv$=function(t){return this.queryMode=t,this},Le.prototype.prologStrictCompatibility_6taknv$=function(t){return this.prologStrictCompatibility=t,this},Le.prototype.graphBuildMode_61zpoe$=function(t){return this.graphBuildMode=t,this},Le.prototype.argumentLabellingMode_61zpoe$=function(t){return this.argumentLabellingMode=t,this},Le.prototype.statementLabellingMode_61zpoe$=function(t){return this.statementLabellingMode=t,this},Le.prototype.orderingPrinciple_61zpoe$=function(t){return this.orderingPrinciple=t,this},Le.prototype.orderingComparator_61zpoe$=function(t){return this.orderingComparator=t,this},Le.prototype.modulesPath_61zpoe$=function(t){return this.modulesPath=t,this},Le.prototype.graphExtensions_upaayv$=function(t){return this.graphExtensions=t,this},Object.defineProperty(je.prototype,"alias",{configurable:!0,get:function(){return this.alias_jy93v2$_0}}),Object.defineProperty(je.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,we().setupSolver_ds05wj$(this.this$FlagsBuilder))}}),Object.defineProperty(je.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),je.$metadata$={kind:g,interfaces:[te]},Le.prototype.create=function(){return new je(this)},Le.$metadata$={kind:g,simpleName:"FlagsBuilder",interfaces:[]},Le.prototype.component1=function(){return this.queryMode},Le.prototype.component2=function(){return this.autoTransposition},Le.prototype.component3=function(){return this.prologStrictCompatibility},Le.prototype.component4=function(){return this.graphBuildMode},Le.prototype.component5=function(){return this.argumentLabellingMode},Le.prototype.component6=function(){return this.statementLabellingMode},Le.prototype.component7=function(){return this.orderingPrinciple},Le.prototype.component8=function(){return this.orderingComparator},Le.prototype.component9=function(){return this.modulesPath},Le.prototype.component10=function(){return this.graphExtensions},Le.prototype.copy_myjohq$=function(t,e,n,r,o,i,a,s,u,p){return new Le(void 0===t?this.queryMode:t,void 0===e?this.autoTransposition:e,void 0===n?this.prologStrictCompatibility:n,void 0===r?this.graphBuildMode:r,void 0===o?this.argumentLabellingMode:o,void 0===i?this.statementLabellingMode:i,void 0===a?this.orderingPrinciple:a,void 0===s?this.orderingComparator:s,void 0===u?this.modulesPath:u,void 0===p?this.graphExtensions:p)},Le.prototype.toString=function(){return"FlagsBuilder(queryMode="+e.toString(this.queryMode)+", autoTransposition="+e.toString(this.autoTransposition)+", prologStrictCompatibility="+e.toString(this.prologStrictCompatibility)+", graphBuildMode="+e.toString(this.graphBuildMode)+", argumentLabellingMode="+e.toString(this.argumentLabellingMode)+", statementLabellingMode="+e.toString(this.statementLabellingMode)+", orderingPrinciple="+e.toString(this.orderingPrinciple)+", orderingComparator="+e.toString(this.orderingComparator)+", modulesPath="+e.toString(this.modulesPath)+", graphExtensions="+e.toString(this.graphExtensions)+")"},Le.prototype.hashCode=function(){var t=0;return 31*(t=31*(t=31*(t=31*(t=31*(t=31*(t=31*(t=31*(t=31*(t=31*t+e.hashCode(this.queryMode)|0)+e.hashCode(this.autoTransposition)|0)+e.hashCode(this.prologStrictCompatibility)|0)+e.hashCode(this.graphBuildMode)|0)+e.hashCode(this.argumentLabellingMode)|0)+e.hashCode(this.statementLabellingMode)|0)+e.hashCode(this.orderingPrinciple)|0)+e.hashCode(this.orderingComparator)|0)+e.hashCode(this.modulesPath)|0)+e.hashCode(this.graphExtensions)|0},Le.prototype.equals=function(t){return this===t||null!==t&&"object"===a(t)&&Object.getPrototypeOf(this)===Object.getPrototypeOf(t)&&e.equals(this.queryMode,t.queryMode)&&e.equals(this.autoTransposition,t.autoTransposition)&&e.equals(this.prologStrictCompatibility,t.prologStrictCompatibility)&&e.equals(this.graphBuildMode,t.graphBuildMode)&&e.equals(this.argumentLabellingMode,t.argumentLabellingMode)&&e.equals(this.statementLabellingMode,t.statementLabellingMode)&&e.equals(this.orderingPrinciple,t.orderingPrinciple)&&e.equals(this.orderingComparator,t.orderingComparator)&&e.equals(this.modulesPath,t.modulesPath)&&e.equals(this.graphExtensions,t.graphExtensions)},Object.defineProperty(Ee.prototype,"alias",{configurable:!0,get:function(){return this.alias_j6xthy$_0}}),Object.defineProperty(Ee.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,ht(k.Companion,yt("\n                % with_facts_and_length/3\n                with_facts_and_length(X, Y, L) :-\n                    solve(X, R),\n                    recover_facts(R, Y),\n                    length(Y, L).\n        \n                % lenght/2\n        \n                length([], 0).\n                length([_|T], X) :- length(T, Y), X is Y + 1.\n        \n                % recover_facts/2\n        \n                recover_facts([], []) :- !.\n                recover_facts([H|T], C) :-\n                    is_list(H), !,\n                    recover_facts(T, TC),\n                    recover_facts(H, HC),\n                    append(TC, HC, C).\n                recover_facts([H|T], C) :-\n                    \\+ is_list(H),\n                    recover_facts(T, TC),\n                    evaluate(H, HC),\n                    append(TC, HC, C).\n        \n                evaluate(user_fact(X), [X]) :- !.\n                evaluate(_, []) :- !.\n        \n                % solve/2\n        \n                solve((A,B), Result) :- !,\n                    solve(A, ARes),\n                    solve(B, BRes),\n                    append(ARes, BRes, Result).\n        \n                solve((A;B), Result) :- !,\n                    solve(A, Result);\n                    solve(B, Result).\n        \n                solve(member(A, B), [system_predicate]) :- !,\n                    call(member(A, B)).\n        \n                solve(\\+(A), [not(A)]) :- !,\n                    call(\\+(A)).\n        \n                solve((A)\\=(B), [doNotUnify(A, B)]) :- !,\n                    call((A)\\=(B)).\n        \n                solve(A, [system_predicate]) :-\n                    catch(clause(A, _), B, true),\n                    \\+ var(B), !,\n                    call(A).\n        \n                solve(A, [A]) :-\n                    \\+ clause(A, B), !,\n                    call(A).\n        \n                solve(A, [A|[Res]]) :-\n                    clause(A, B),\n                    solve(B, Res).\n        \n                % is_list/1\n        \n                is_list(X) :- var(X), !, fail.\n                is_list([]).\n                is_list([_|T]) :- is_list(T).\n                ")))}}),Object.defineProperty(Ee.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),Ee.prototype.identifier=function(){return"interpreter"},Ee.$metadata$={kind:y,simpleName:"MetaInterpreter",interfaces:[oe,te]};var ze=null;function Ge(){return null===ze&&new Ee,ze}function Xe(){qe=this,te.call(this),this.alias_46d2ju$_0="prolog.argumentation.modularity"}Object.defineProperty(Xe.prototype,"alias",{configurable:!0,get:function(){return this.alias_46d2ju$_0}}),Object.defineProperty(Xe.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,_t(Y(Je().signature,Je())))}}),Object.defineProperty(Xe.prototype,"baseFlags",{configurable:!0,get:function(){return f(We())}}),Xe.prototype.identifier=function(){return"module"},Xe.$metadata$={kind:y,simpleName:"ModuleCalls",interfaces:[oe,te]};var qe=null;function He(){return null===qe&&new Xe,qe}function Me(){Fe=this}Me.prototype.predicate=function(){return"modulesPath"},Me.prototype.default=function(){return"none"},Me.prototype.values=function(){return it},Me.$metadata$={kind:y,simpleName:"ModulesPath",interfaces:[ie]};var Fe=null;function We(){return null===Fe&&new Me,Fe}function Ve(){Ze=this,this.signature=new x("call_module",2)}function Ye(t){return function(n){return e.isType(n,At)?t.replySuccess(n.substitution,void 0,[]):t.replyFail(void 0,[])}}function Qe(t,e,n,r,o,i){U.call(this,i),this.$controller=o,this.exceptionState_0=1,this.local$closure$solver=t,this.local$closure$goal=e,this.local$closure$request=n,this.local$$receiver=r}function Ke(t){return function(n){return st(L(Ot($t.Companion,t.libraries).solve(n.stringInvoke("modulesPath",n.X,[])),(r=n,function(t){return e.isType(t,At)?Tt(t.substitution.get_11rb$(r.X)):""})));var r}}Qe.$metadata$={kind:e.Kind.CLASS,simpleName:null,interfaces:[U]},Qe.prototype=Object.create(U.prototype),Qe.prototype.constructor=Qe,Qe.prototype.doResume=function(){for(;;)try{switch(this.state_0){case 0:if(this.state_0=2,this.result_0=this.local$$receiver.yieldAll_swo9gw$(L(this.local$closure$solver.solve(this.local$closure$goal),Ye(this.local$closure$request)),this),this.result_0===D)return D;continue;case 1:throw this.exception_0;case 2:return this.result_0;default:throw this.state_0=1,new Error("State Machine Unreachable execution")}}catch(t){if(1===this.state_0)throw this.exceptionState_0=this.state_0,t;this.state_0=this.exceptionState_0,this.exception_0=t}},Ve.prototype.solve=function(t){var n=t.arguments.get_za3lpa$(0),r=t.arguments.get_za3lpa$(1);if(!e.isType(n,bt))throw Z.Companion.forGoal(t.context,t.signature,J.LIST,n);if(!e.isType(r,tt))throw Z.Companion.forGoal(t.context,t.signature,J.CALLABLE,r);var o,i=t.context,a=this.mineModulesPath_0(t.context),s=n.toList(),u=A(b(s,10));for(o=s.iterator();o.hasNext();){var p=o.next();u.add_11rb$(p.toString())}var l,c,d,f=this.getCleanSolver_0(i,a,u);return w((l=f,c=r,d=t,function(t,e,n){var r=new Qe(l,c,d,t,this,e);return n?r:r.doResume(null)}))},Ve.prototype.mineModulesPath_0=function(t){return Rt(Ke(t))},Ve.prototype.getCleanSolver_0=function(t,e,n){var r,o,i,a,s=(r=e,function(t){return Nt(t,".pl")?t:St(r,"'")+"/"+t+".pl"});return Rt((o=t,i=n,a=s,function(t){var e,n=Ot($t.Companion,o.libraries),r=a;for(e=i.iterator();e.hasNext();){var s=e.next();vt(n.solve(t.stringInvoke("consult",r(s),[])))}return n}))},Ve.$metadata$={kind:y,simpleName:"ModuleCall",interfaces:[B]};var Ze=null;function Je(){return null===Ze&&new Ve,Ze}function tn(){re.call(this),this.alias_20vdh5$_0="prolog.argumentation.abstract"}function en(){nn=this}Object.defineProperty(tn.prototype,"alias",{configurable:!0,get:function(){return this.alias_20vdh5$_0}}),Object.defineProperty(tn.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(tn.prototype,"baseFlags",{configurable:!0,get:function(){return _([rn(),sn(),ln(),fn()])}}),tn.prototype.identifier=function(){return"abstract"},tn.$metadata$={kind:g,simpleName:"AbstractModeBase",interfaces:[oe,re,Jt]},en.prototype.predicate=function(){return"graphExtension"},en.prototype.default=function(){return f("standardPref")},en.prototype.values=function(){return _(["rebutRestriction","bp","standardPref","defeasiblePref","defeasibleAllPref"])},en.$metadata$={kind:y,simpleName:"GraphExtension",interfaces:[ie]};var nn=null;function rn(){return null===nn&&new en,nn}function on(){an=this}on.prototype.predicate=function(){return"argumentLabellingMode"},on.prototype.default=function(){return"grounded"},on.prototype.values=function(){return _(["grounded","complete","bp_grounded","bp_grounded_partial","bp_grounded_complete"])},on.$metadata$={kind:y,simpleName:"ArgumentLabellingMode",interfaces:[ie]};var an=null;function sn(){return null===an&&new on,an}function un(){pn=this}un.prototype.predicate=function(){return"statementLabellingMode"},un.prototype.default=function(){return"statement"},un.prototype.values=function(){return f("statement")},un.$metadata$={kind:y,simpleName:"StatementLabellingMode",interfaces:[ie]};var pn=null;function ln(){return null===pn&&new un,pn}function cn(){dn=this}cn.prototype.predicate=function(){return"graphBuildMode"},cn.prototype.default=function(){return"standard_af"},cn.prototype.values=function(){return f("standard_af")},cn.$metadata$={kind:y,simpleName:"GraphBuildMode",interfaces:[ie]};var dn=null;function fn(){return null===dn&&new cn,dn}function mn(){re.call(this),this.alias_97o1eq$_0="prolog.argumentation.graph"}function gn(){re.call(this),this.alias_adfudl$_0="prolog.argumentation.graph.rebutrestriction"}function yn(){re.call(this),this.alias_vy9s00$_0="prolog.argumentation.graph.meta.bp"}function hn(){re.call(this),this.alias_4iduyv$_0="prolog.argumentation.graph.preferences.defeasible"}function _n(){re.call(this),this.alias_h4h2we$_0="prolog.argumentation.graph.preferences.defeasible.generic"}function bn(){re.call(this),this.alias_t055po$_0="prolog.argumentation.graph.preferences.strict"}function An(){re.call(this),this.alias_ct2pe$_0="prolog.argumentation.graph.labelling.bpgroundedcomplete"}function $n(){re.call(this),this.alias_bxcq2h$_0="prolog.argumentation.graph.labelling.bpgrounded"}function On(){re.call(this),this.alias_p5bkbg$_0="prolog.argumentation.graph.labelling.bpgroundedpartial"}function Tn(){re.call(this),this.alias_qi88w4$_0="prolog.argumentation.graph.labelling.complete"}function Rn(){re.call(this),this.alias_6e4o5t$_0="prolog.argumentation.graph.labelling.grounded"}function Nn(){re.call(this),this.alias_8wmdq8$_0="prolog.argumentation.graph.labelling.statement"}function Sn(){re.call(this),this.alias_ax3va9$_0="prolog.argumentation.parser"}function vn(){kn=this}Object.defineProperty(mn.prototype,"alias",{configurable:!0,get:function(){return this.alias_97o1eq$_0}}),Object.defineProperty(mn.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(mn.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),mn.prototype.identifier=function(){return"standard_af"},mn.$metadata$={kind:g,simpleName:"ArgumentationGraphBuilderBase",interfaces:[oe,re,Jt]},Object.defineProperty(gn.prototype,"alias",{configurable:!0,get:function(){return this.alias_adfudl$_0}}),Object.defineProperty(gn.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(gn.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),gn.prototype.identifier=function(){return"rebutRestriction"},gn.$metadata$={kind:g,simpleName:"AttackRestrictionHandlerBase",interfaces:[oe,re,Jt]},Object.defineProperty(yn.prototype,"alias",{configurable:!0,get:function(){return this.alias_vy9s00$_0}}),Object.defineProperty(yn.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(yn.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),yn.prototype.identifier=function(){return"bp"},yn.$metadata$={kind:g,simpleName:"BpMetaGraphHandlerBase",interfaces:[oe,re,Jt]},Object.defineProperty(hn.prototype,"alias",{configurable:!0,get:function(){return this.alias_4iduyv$_0}}),Object.defineProperty(hn.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(hn.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),hn.prototype.identifier=function(){return"defeasiblePref"},hn.$metadata$={kind:g,simpleName:"DefeasiblePreferencesHandlerBase",interfaces:[oe,re,Jt]},Object.defineProperty(_n.prototype,"alias",{configurable:!0,get:function(){return this.alias_h4h2we$_0}}),Object.defineProperty(_n.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(_n.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),_n.prototype.identifier=function(){return"defeasibleAllPref"},_n.$metadata$={kind:g,simpleName:"GenericDefeasiblePreferencesHandlerBase",interfaces:[oe,re,Jt]},Object.defineProperty(bn.prototype,"alias",{configurable:!0,get:function(){return this.alias_t055po$_0}}),Object.defineProperty(bn.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(bn.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),bn.prototype.identifier=function(){return"standardPref"},bn.$metadata$={kind:g,simpleName:"StrictPreferencesHandlerBase",interfaces:[oe,re,Jt]},Object.defineProperty(An.prototype,"alias",{configurable:!0,get:function(){return this.alias_ct2pe$_0}}),Object.defineProperty(An.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(An.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),An.prototype.identifier=function(){return"bp_grounded_complete"},An.$metadata$={kind:g,simpleName:"BpCompleteLabellerBase",interfaces:[oe,re,Jt]},Object.defineProperty($n.prototype,"alias",{configurable:!0,get:function(){return this.alias_bxcq2h$_0}}),Object.defineProperty($n.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty($n.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),$n.prototype.identifier=function(){return"bp_grounded"},$n.$metadata$={kind:g,simpleName:"BpLabellerBase",interfaces:[oe,re,Jt]},Object.defineProperty(On.prototype,"alias",{configurable:!0,get:function(){return this.alias_p5bkbg$_0}}),Object.defineProperty(On.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(On.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),On.prototype.identifier=function(){return"bp_grounded_partial"},On.$metadata$={kind:g,simpleName:"BpPartialLabellerBase",interfaces:[oe,re,Jt]},Object.defineProperty(Tn.prototype,"alias",{configurable:!0,get:function(){return this.alias_qi88w4$_0}}),Object.defineProperty(Tn.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(Tn.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),Tn.prototype.identifier=function(){return"complete"},Tn.$metadata$={kind:g,simpleName:"CompleteLabellerBase",interfaces:[oe,re,Jt]},Object.defineProperty(Rn.prototype,"alias",{configurable:!0,get:function(){return this.alias_6e4o5t$_0}}),Object.defineProperty(Rn.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(Rn.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),Rn.prototype.identifier=function(){return"grounded"},Rn.$metadata$={kind:g,simpleName:"GroundedLabellerBase",interfaces:[oe,re,Jt]},Object.defineProperty(Nn.prototype,"alias",{configurable:!0,get:function(){return this.alias_8wmdq8$_0}}),Object.defineProperty(Nn.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(Nn.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),Nn.prototype.identifier=function(){return"statement"},Nn.$metadata$={kind:g,simpleName:"StatementLabellerBase",interfaces:[oe,re,Jt]},Object.defineProperty(Sn.prototype,"alias",{configurable:!0,get:function(){return this.alias_ax3va9$_0}}),Object.defineProperty(Sn.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,Ct([kt("descriptionPair",0,function(t){return t.descriptionPair}.bind(null,En())).get(),kt("descriptionPair",0,function(t){return t.descriptionPair}.bind(null,qn())).get(),kt("descriptionPair",0,function(t){return t.descriptionPair}.bind(null,tr())).get(),kt("descriptionPair",0,function(t){return t.descriptionPair}.bind(null,Wn())).get(),kt("descriptionPair",0,function(t){return t.descriptionPair}.bind(null,Qn())).get()]),this.prologTheory)}}),Object.defineProperty(Sn.prototype,"baseFlags",{configurable:!0,get:function(){return _([Cn(),In()])}}),Sn.prototype.identifier=function(){return"parser"},Sn.$metadata$={kind:g,simpleName:"RuleParserBase",interfaces:[oe,re,Jt]},vn.prototype.predicate=function(){return"autoTransposition"},vn.prototype.default=function(){return!1},vn.prototype.values=function(){return it},vn.$metadata$={kind:y,simpleName:"AutoTransposition",interfaces:[ie]};var kn=null;function Cn(){return null===kn&&new vn,kn}function Pn(){Bn=this}Pn.prototype.predicate=function(){return"prologStrictCompatibility"},Pn.prototype.default=function(){return!0},Pn.prototype.values=function(){return it},Pn.$metadata$={kind:y,simpleName:"PrologStrictCompatibility",interfaces:[ie]};var Bn=null;function In(){return null===Bn&&new Pn,Bn}function xn(){Dn=this}function Ln(t,e,n,r){return function(o){var i,a,s;return s=F.Companion,i=t.castToVar(),a=e||st(n.solve(gt(tt.Companion,"prologStrictCompatibility"))).isYes?r(n.context.staticKb.clauses,o):o.emptyList,I([s.of(i,a)])}}xn.prototype.modifiers_3bh3rj$=function(t,e){return Rt((n=t,r=e,function(t){var e,o=n.bodyItems,i=A(b(o,10));for(e=o.iterator();e.hasNext();){var a,s=e.next(),u=i.add_11rb$,p=r;u.call(i,s.isStruct&&nt(null!=(a=s.asStruct())?a.functor:null,"\\+")?t.stringInvoke("~",V(s.asStruct()).argsList.get_za3lpa$(0),[]):st(p.solve(t.stringInvoke("clause",s,[Pt.Companion.ANONYMOUS_NAME]))).isHalt?t.stringInvoke("prolog",s,[]):s)}return i.size>1?t.tupleOfIterable(i):Bt(i)}));var n,r},xn.prototype.commonMap_sg2xgv$=function(t,e,n,r){return void 0===n&&(n=!1),It.Companion.ensuringArgumentIsVariable_3adri$(t,0),Rt(Ln(e,n,t,r))},xn.$metadata$={kind:y,simpleName:"ConversionUtils",interfaces:[]};var Dn=null;function Un(){return null===Dn&&new xn,Dn}function wn(){jn=this,Dt.call(this,"prologStrictRules")}wn.prototype.computeAllSubstitutions_jktvg7$=function(t,e){return Un().commonMap_sg2xgv$(t,e,void 0,(n=t,function(t,e){var r,o=dt();for(r=t.iterator();r.hasNext();){var i=r.next();i.isFact||o.add_11rb$(i)}var a,s=A(b(o,10));for(a=o.iterator();a.hasNext();){var u=a.next(),p=s.add_11rb$,l=n;p.call(s,e.listOfAny(["rule_"+xt.Default.nextInt_vux9f0$(0,2147483647),Un().modifiers_3bh3rj$(u,l),V(u.head)]))}return Lt(s)}));var n},wn.$metadata$={kind:y,simpleName:"StrictRules",interfaces:[Dt]};var jn=null;function En(){return null===jn&&new wn,jn}function zn(){Xn=this,Dt.call(this,"prologAxioms")}function Gn(t,e){var n,r=dt();for(n=t.iterator();n.hasNext();){var o=n.next();o.isFact&&!_([":->","->","=>",":=>",":",":=",","]).contains_11rb$(V(o.head).functor)&&r.add_11rb$(o)}var i,a=A(b(r,10));for(i=r.iterator();i.hasNext();){var s=i.next();a.add_11rb$(e.listOfAny(["rule_"+xt.Default.nextInt_vux9f0$(0,2147483647),V(s.head)]))}return Lt(a)}zn.prototype.computeAllSubstitutions_jktvg7$=function(t,e){return Un().commonMap_sg2xgv$(t,e,void 0,Gn)},zn.$metadata$={kind:y,simpleName:"Axioms",interfaces:[Dt]};var Xn=null;function qn(){return null===Xn&&new zn,Xn}function Hn(){Fn=this,Dt.call(this,"prologPremises")}function Mn(t,e){var n,r=dt();for(n=t.iterator();n.hasNext();){var o=n.next();o.isFact&&nt(V(o.head).functor,":=")&&1===V(o.head).arity&&r.add_11rb$(o)}var i,a=A(b(r,10));for(i=r.iterator();i.hasNext();){var s=i.next();a.add_11rb$(e.listOfAny(["rule_"+xt.Default.nextInt_vux9f0$(0,2147483647),V(s.head).argsList.get_za3lpa$(0)]))}return Lt(a)}Hn.prototype.computeAllSubstitutions_jktvg7$=function(t,e){return Un().commonMap_sg2xgv$(t,e,void 0,Mn)},Hn.$metadata$={kind:y,simpleName:"Premises",interfaces:[Dt]};var Fn=null;function Wn(){return null===Fn&&new Hn,Fn}function Vn(){Yn=this,Dt.call(this,"prologDefeasibleRules")}Vn.prototype.computeAllSubstitutions_jktvg7$=function(t,e){return Un().commonMap_sg2xgv$(t,e,void 0,(n=t,function(t,e){var r,o=dt();for(r=t.iterator();r.hasNext();){var i,a=r.next();a.isFact&&(nt(V(a.head).functor,":=")||nt(V(a.head).functor,",")&&nt(null!=(i=V(a.head).argsList.get_za3lpa$(0).asStruct())?i.functor:null,":="))&&2===V(a.head).arity&&o.add_11rb$(a)}var s,u=A(b(o,10));for(s=o.iterator();s.hasNext();){var p,l,c,d=s.next(),g=u.add_11rb$,y=n;if(nt(V(d.head).functor,",")){var h=V(d.head).argsList.get_za3lpa$(0).asStruct(),_=Ut(m(f(V(h).get(1)),null!=(l=null!=(p=V(d.head).argsList.get_za3lpa$(1).asTuple())?p.argsList:null)?l:f(V(d.head).argsList.get_za3lpa$(1))));c=e.clauseOf(h.get(0).asStruct(),_.slice())}else c=e.clauseOf(V(d.head).argsList.get_za3lpa$(0).asStruct(),[V(d.head).argsList.get_za3lpa$(1)]);var $=c;g.call(u,e.listOfAny(["rule_"+xt.Default.nextInt_vux9f0$(0,2147483647),Un().modifiers_3bh3rj$($,y),V($.head)]))}return Lt(u)}));var n},Vn.$metadata$={kind:y,simpleName:"DefeasibleRules",interfaces:[Dt]};var Yn=null;function Qn(){return null===Yn&&new Vn,Yn}function Kn(){Jn=this,Dt.call(this,"bpsNew")}function Zn(t,e){var n,r=dt();for(n=t.iterator();n.hasNext();){var o,i=n.next();i.isFact&&nt(null!=(o=i.head)?o.functor:null,"bp")&&r.add_11rb$(i)}var a,s=A(b(r,10));for(a=r.iterator();a.hasNext();){var u=a.next();s.add_11rb$(e.listOfAny(["bps",V(u.head)]))}return Lt(s)}Kn.prototype.computeAllSubstitutions_jktvg7$=function(t,e){return Un().commonMap_sg2xgv$(t,e,!0,Zn)},Kn.$metadata$={kind:y,simpleName:"Bps",interfaces:[Dt]};var Jn=null;function tr(){return null===Jn&&new Kn,Jn}function er(){re.call(this),this.alias_k0m5up$_0="prolog.argumentation.structured"}function nr(){rr=this}Object.defineProperty(er.prototype,"alias",{configurable:!0,get:function(){return this.alias_k0m5up$_0}}),Object.defineProperty(er.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(er.prototype,"baseFlags",{configurable:!0,get:function(){return f(or())}}),er.prototype.identifier=function(){return"structured"},er.$metadata$={kind:g,simpleName:"StructuredModeBase",interfaces:[oe,re,Jt]},nr.prototype.predicate=function(){return"queryMode"},nr.prototype.default=function(){return!0},nr.prototype.values=function(){return it},nr.$metadata$={kind:y,simpleName:"QueryMode",interfaces:[ie]};var rr=null;function or(){return null===rr&&new nr,rr}function ir(){re.call(this),this.alias_kdrkna$_0="prolog.argumentation.debug"}function ar(){re.call(this),this.alias_cczqdw$_0="prolog.argumentation.superiority"}function sr(){ur=this}Object.defineProperty(ir.prototype,"alias",{configurable:!0,get:function(){return this.alias_kdrkna$_0}}),Object.defineProperty(ir.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(ir.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),ir.prototype.identifier=function(){return"debug"},ir.$metadata$={kind:g,simpleName:"DebugBase",interfaces:[oe,re,Jt]},Object.defineProperty(ar.prototype,"alias",{configurable:!0,get:function(){return this.alias_cczqdw$_0}}),Object.defineProperty(ar.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(ar.prototype,"baseFlags",{configurable:!0,get:function(){return _([pr(),dr()])}}),ar.prototype.identifier=function(){return"superiority"},ar.$metadata$={kind:g,simpleName:"SuperiorityRelationBase",interfaces:[oe,re,Jt]},sr.prototype.predicate=function(){return"orderingPrinciple"},sr.prototype.default=function(){return"last"},sr.prototype.values=function(){return _(["last","weakest"])},sr.$metadata$={kind:y,simpleName:"OrderingPrinciple",interfaces:[ie]};var ur=null;function pr(){return null===ur&&new sr,ur}function lr(){cr=this}lr.prototype.predicate=function(){return"orderingComparator"},lr.prototype.default=function(){return"elitist"},lr.prototype.values=function(){return _(["elitist","democrat","normal"])},lr.$metadata$={kind:y,simpleName:"OrderingComparator",interfaces:[ie]};var cr=null;function dr(){return null===cr&&new lr,cr}function fr(){re.call(this),this.alias_7qdeho$_0="prolog.argumentation.utils"}function mr(t){return t.isYes}function gr(t){return Er().of_z0t4vt$(t)}function yr(t){return t.supports.size}function hr(t){return t.rules.size}function _r(t){return t.conclusion}function br(t){return t.topRule}function Ar(t,e){return e.identifier="A"+t,e}function $r(t,e){return function(n){return Et(jt(L(L(at(t.solve(n.stringInvoke("context_check",e,[n.stringInvoke("argument",n.X,[])])),mr),(r=n,function(t){return V(t.substitution.get_11rb$(r.X))})),gr),wt([yr,hr,_r,br])),Ar);var r}}function Or(t,e){return vt(ut($r(t,e)))}function Tr(t){return t.isYes}function Rr(t,e,n){return function(r){return L(at(t.solve(r.stringInvoke("context_check",e,[r.stringInvoke("attack",r._,[r.X,r.Y,r._])])),Tr),function(t,e){return function(n){var r,o=t;t:do{var i;for(i=o.iterator();i.hasNext();){var a=i.next(),s=e;if(R.Companion.default.match(a.termRepresentation(),V(n.substitution.get_11rb$(s.X)))){r=a;break t}}throw new Gt("Collection contains no element matching the predicate.")}while(0);var u,p=r,l=t;t:do{var c;for(c=l.iterator();c.hasNext();){var d=c.next(),f=e;if(R.Companion.default.match(d.termRepresentation(),V(n.substitution.get_11rb$(f.Y)))){u=d;break t}}throw new Gt("Collection contains no element matching the predicate.")}while(0);return new zr(p,u)}}(n,r))}}function Nr(t,e,n){return n.isEmpty()?j():vt(ut(Rr(t,e,n)))}function Sr(t){return t.isYes}function vr(t,e,n,r){return function(o){return vt(L(L(at(t.solve(o.stringInvoke("context_check",e,[o.stringInvoke("support",o.X,[n.termRepresentation()])])),Sr),(i=o,function(t){return V(t.substitution.get_11rb$(i.X))})),function(t,e){return function(n){var r,o=t;t:do{var i;for(i=o.iterator();i.hasNext();){var a=i.next();if(R.Companion.default.match(a.termRepresentation(),n)){r=a;break t}}throw new Gt("Collection contains no element matching the predicate.")}while(0);var s=new Yr(r,e);return e.supports.add_11rb$(s.supporter),s}}(r,n)));var i}}function kr(t,e,n){var r,o=dt();for(r=n.iterator();r.hasNext();){var i=r.next(),a=ut(vr(t,e,i,n));Xt(o,a)}return o}function Cr(t){return t.isYes}function Pr(t,e){return function(n,r){return ut(function(t,e,n,r){return function(o){return zt(L(at(t.solve(o.stringInvoke("context_check",e,[o.stringInvoke(n,r.termRepresentation(),[])])),Cr),function(t){return function(e){return t}}(n)))}}(t,e,n,r))}}function Br(t,e,n){var r,o=Pr(t,e),i=A(b(n,10));for(r=n.iterator();r.hasNext();){var a,s,u=r.next();i.add_11rb$(new Mr(u,null!=(s=null!=(a=o("in",u))?a:o("out",u))?s:"und"))}return i}function Ir(t,e,n,r,o,i,a){Er(),void 0===r&&(r=j()),void 0===o&&(o=j()),void 0===i&&(i=j()),void 0===a&&(a=j()),this.rules=t,this.topRule=e,this.conclusion=n,this.groundings=r,this.defeasibleRules=o,this.defeasiblePremises=i,this.lastDefeasibleRules=a,this.identifier="",this.supports=dt()}function xr(){jr=this}function Lr(t){var n;return(e.isType(n=t,Mt)?n:et()).toList()}function Dr(t,n){var r,o,i=t.get_za3lpa$(n).isEmptyList?j():(e.isType(r=t.get_za3lpa$(n),Mt)?r:et()).toList(),a=A(b(i,10));for(o=i.iterator();o.hasNext();){var s=o.next();a.add_11rb$(s.toString())}return a}function Ur(t){return t.get_za3lpa$(1).toString()}function wr(t){return t.get_za3lpa$(2).toString()}Object.defineProperty(fr.prototype,"alias",{configurable:!0,get:function(){return this.alias_7qdeho$_0}}),Object.defineProperty(fr.prototype,"baseContent",{configurable:!0,get:function(){return v.Companion.aliased(this.alias,void 0,this.prologTheory)}}),Object.defineProperty(fr.prototype,"baseFlags",{configurable:!0,get:function(){return j()}}),fr.prototype.identifier=function(){return"utils"},fr.$metadata$={kind:g,simpleName:"UtilsBase",interfaces:[oe,re,Jt]},Object.defineProperty(Ir.prototype,"descriptor",{configurable:!0,get:function(){var t,e,n;if(n=this.identifier+" : ",nt(this.topRule,"none"))e=null!=(t=qt(this.rules))?t:"";else{var r,o=this.supports,i=A(b(o,10));for(r=o.iterator();r.hasNext();){var a=r.next();i.add_11rb$(a.identifier)}var s=Ht(i,this.topRule).iterator();if(!s.hasNext())throw $("Empty collection can't be reduced.");for(var u=s.next();s.hasNext();)u=u+","+s.next();e=u}return n+e+" : "+this.conclusion}}),Ir.prototype.termRepresentation=function(){return gt(tt.Companion,"["+this.rules+", "+this.topRule+", "+this.conclusion+", "+this.groundings+", ["+this.lastDefeasibleRules+", "+this.defeasibleRules+", "+this.defeasiblePremises+"]]")},Ir.prototype.toString=function(){return"argument("+this.termRepresentation()+")"},Ir.prototype.toTerm=function(){return gt(tt.Companion,this.toString())},xr.prototype.of_z0t4vt$=function(t){var e,n=Lr,r=Dr,o=(e=r,function(t){return e(t,0)}),i=Ur,a=wr,s=function(t){return function(e){return t(e,3)}}(r),u=function(t,e){return function(n){return e(t(n.get_za3lpa$(4)),1)}}(n,r),p=function(t,e){return function(n){return e(t(n.get_za3lpa$(4)),2)}}(n,r),l=function(t,e){return function(n){return e(t(n.get_za3lpa$(4)),0)}}(n,r),c=n(t);return new Ir(o(c),i(c),a(c),s(c),u(c),p(c),l(c))},xr.$metadata$={kind:y,simpleName:"Companion",interfaces:[]};var jr=null;function Er(){return null===jr&&new xr,jr}function zr(t,e,n,r){void 0===n&&(n=null),void 0===r&&(r=null),this.attacker=t,this.target=e,this.type=n,this.on=r}function Gr(t,e,n){Hr(),this.arguments=t,this.attacks=e,this.supports=n,this.labellings=j()}function Xr(){qr=this}Ir.$metadata$={kind:g,simpleName:"Argument",interfaces:[]},Ir.prototype.component1=function(){return this.rules},Ir.prototype.component2=function(){return this.topRule},Ir.prototype.component3=function(){return this.conclusion},Ir.prototype.component4=function(){return this.groundings},Ir.prototype.component5=function(){return this.defeasibleRules},Ir.prototype.component6=function(){return this.defeasiblePremises},Ir.prototype.component7=function(){return this.lastDefeasibleRules},Ir.prototype.copy_2b7ur7$=function(t,e,n,r,o,i,a){return new Ir(void 0===t?this.rules:t,void 0===e?this.topRule:e,void 0===n?this.conclusion:n,void 0===r?this.groundings:r,void 0===o?this.defeasibleRules:o,void 0===i?this.defeasiblePremises:i,void 0===a?this.lastDefeasibleRules:a)},Ir.prototype.hashCode=function(){var t=0;return 31*(t=31*(t=31*(t=31*(t=31*(t=31*(t=31*t+e.hashCode(this.rules)|0)+e.hashCode(this.topRule)|0)+e.hashCode(this.conclusion)|0)+e.hashCode(this.groundings)|0)+e.hashCode(this.defeasibleRules)|0)+e.hashCode(this.defeasiblePremises)|0)+e.hashCode(this.lastDefeasibleRules)|0},Ir.prototype.equals=function(t){return this===t||null!==t&&"object"===a(t)&&Object.getPrototypeOf(this)===Object.getPrototypeOf(t)&&e.equals(this.rules,t.rules)&&e.equals(this.topRule,t.topRule)&&e.equals(this.conclusion,t.conclusion)&&e.equals(this.groundings,t.groundings)&&e.equals(this.defeasibleRules,t.defeasibleRules)&&e.equals(this.defeasiblePremises,t.defeasiblePremises)&&e.equals(this.lastDefeasibleRules,t.lastDefeasibleRules)},zr.prototype.toString=function(){var t,e,n;return"attack("+(null!=(t=this.type)?t:"none")+", "+this.attacker.termRepresentation()+", "+this.target.termRepresentation()+", "+(null!=(n=null!=(e=this.on)?e.termRepresentation():null)?n:"none").toString()+")"},zr.prototype.toTerm=function(){return gt(tt.Companion,this.toString())},zr.$metadata$={kind:g,simpleName:"Attack",interfaces:[]},zr.prototype.component1=function(){return this.attacker},zr.prototype.component2=function(){return this.target},zr.prototype.component3=function(){return this.type},zr.prototype.component4=function(){return this.on},zr.prototype.copy_ap9ihh$=function(t,e,n,r){return new zr(void 0===t?this.attacker:t,void 0===e?this.target:e,void 0===n?this.type:n,void 0===r?this.on:r)},zr.prototype.hashCode=function(){var t=0;return 31*(t=31*(t=31*(t=31*t+e.hashCode(this.attacker)|0)+e.hashCode(this.target)|0)+e.hashCode(this.type)|0)+e.hashCode(this.on)|0},zr.prototype.equals=function(t){return this===t||null!==t&&"object"===a(t)&&Object.getPrototypeOf(this)===Object.getPrototypeOf(t)&&e.equals(this.attacker,t.attacker)&&e.equals(this.target,t.target)&&e.equals(this.type,t.type)&&e.equals(this.on,t.on)},Xr.prototype.of_mf1h1a$=function(t,e,n){var r,o=A(b(t,10));for(r=t.iterator();r.hasNext();){var i=r.next();o.add_11rb$(i.argument)}var a=new Gr(o,e,n);return a.labellings=t,a},Xr.$metadata$={kind:y,simpleName:"Companion",interfaces:[]};var qr=null;function Hr(){return null===qr&&new Xr,qr}function Mr(t,e){this.argument=t,this.label=e}function Fr(){}function Wr(t,e,n){void 0===n&&(n=!1),this.identifier_iai0l4$_0=t,this.conclusion_vh7k5e$_0=e,this.strict=n}function Vr(t,e,n,r){void 0===r&&(r=!1),this.identifier_dmumzp$_0=t,this.premises=e,this.conclusion_g53ff$_0=n,this.strict=r}function Yr(t,e){this.supporter=t,this.supported=e}function Qr(){Kr=this,xe.call(this)}Gr.$metadata$={kind:g,simpleName:"Graph",interfaces:[]},Gr.prototype.component1=function(){return this.arguments},Gr.prototype.component2=function(){return this.attacks},Gr.prototype.component3=function(){return this.supports},Gr.prototype.copy_3lhab9$=function(t,e,n){return new Gr(void 0===t?this.arguments:t,void 0===e?this.attacks:e,void 0===n?this.supports:n)},Gr.prototype.toString=function(){return"Graph(arguments="+e.toString(this.arguments)+", attacks="+e.toString(this.attacks)+", supports="+e.toString(this.supports)+")"},Gr.prototype.hashCode=function(){var t=0;return 31*(t=31*(t=31*t+e.hashCode(this.arguments)|0)+e.hashCode(this.attacks)|0)+e.hashCode(this.supports)|0},Gr.prototype.equals=function(t){return this===t||null!==t&&"object"===a(t)&&Object.getPrototypeOf(this)===Object.getPrototypeOf(t)&&e.equals(this.arguments,t.arguments)&&e.equals(this.attacks,t.attacks)&&e.equals(this.supports,t.supports)},Mr.prototype.toString=function(){return this.label+"("+this.argument.termRepresentation()+")"},Mr.prototype.toTerm=function(){return gt(tt.Companion,this.toString())},Mr.$metadata$={kind:g,simpleName:"LabelledArgument",interfaces:[]},Mr.prototype.component1=function(){return this.argument},Mr.prototype.component2=function(){return this.label},Mr.prototype.copy_8rskr$=function(t,e){return new Mr(void 0===t?this.argument:t,void 0===e?this.label:e)},Mr.prototype.hashCode=function(){var t=0;return 31*(t=31*t+e.hashCode(this.argument)|0)+e.hashCode(this.label)|0},Mr.prototype.equals=function(t){return this===t||null!==t&&"object"===a(t)&&Object.getPrototypeOf(this)===Object.getPrototypeOf(t)&&e.equals(this.argument,t.argument)&&e.equals(this.label,t.label)},Fr.prototype.toTerm=function(){return gt(tt.Companion,this.toString())},Fr.$metadata$={kind:h,simpleName:"ArgItem",interfaces:[]},Object.defineProperty(Wr.prototype,"identifier",{get:function(){return this.identifier_iai0l4$_0}}),Object.defineProperty(Wr.prototype,"conclusion",{get:function(){return this.conclusion_vh7k5e$_0}}),Wr.prototype.toString=function(){return"premise(["+this.identifier+", "+this.conclusion+"])"},Wr.$metadata$={kind:g,simpleName:"Premise",interfaces:[Fr]},Wr.prototype.component1=function(){return this.identifier},Wr.prototype.component2=function(){return this.conclusion},Wr.prototype.component3=function(){return this.strict},Wr.prototype.copy_qz9155$=function(t,e,n){return new Wr(void 0===t?this.identifier:t,void 0===e?this.conclusion:e,void 0===n?this.strict:n)},Wr.prototype.hashCode=function(){var t=0;return 31*(t=31*(t=31*t+e.hashCode(this.identifier)|0)+e.hashCode(this.conclusion)|0)+e.hashCode(this.strict)|0},Wr.prototype.equals=function(t){return this===t||null!==t&&"object"===a(t)&&Object.getPrototypeOf(this)===Object.getPrototypeOf(t)&&e.equals(this.identifier,t.identifier)&&e.equals(this.conclusion,t.conclusion)&&e.equals(this.strict,t.strict)},Object.defineProperty(Vr.prototype,"identifier",{get:function(){return this.identifier_dmumzp$_0}}),Object.defineProperty(Vr.prototype,"conclusion",{get:function(){return this.conclusion_g53ff$_0}}),Vr.prototype.toString=function(){return"rule(["+this.identifier+", "+this.premises+", "+this.conclusion+"])"},Vr.$metadata$={kind:g,simpleName:"Rule",interfaces:[Fr]},Vr.prototype.component1=function(){return this.identifier},Vr.prototype.component2=function(){return this.premises},Vr.prototype.component3=function(){return this.conclusion},Vr.prototype.component4=function(){return this.strict},Vr.prototype.copy_fx7y9c$=function(t,e,n,r){return new Vr(void 0===t?this.identifier:t,void 0===e?this.premises:e,void 0===n?this.conclusion:n,void 0===r?this.strict:r)},Vr.prototype.hashCode=function(){var t=0;return 31*(t=31*(t=31*(t=31*t+e.hashCode(this.identifier)|0)+e.hashCode(this.premises)|0)+e.hashCode(this.conclusion)|0)+e.hashCode(this.strict)|0},Vr.prototype.equals=function(t){return this===t||null!==t&&"object"===a(t)&&Object.getPrototypeOf(this)===Object.getPrototypeOf(t)&&e.equals(this.identifier,t.identifier)&&e.equals(this.premises,t.premises)&&e.equals(this.conclusion,t.conclusion)&&e.equals(this.strict,t.strict)},Yr.prototype.toString=function(){return"support("+this.supporter.termRepresentation()+", "+this.supported.termRepresentation()+")"},Yr.prototype.toTerm=function(){return gt(tt.Companion,this.toString())},Yr.$metadata$={kind:g,simpleName:"Support",interfaces:[]},Yr.prototype.component1=function(){return this.supporter},Yr.prototype.component2=function(){return this.supported},Yr.prototype.copy_9dngue$=function(t,e){return new Yr(void 0===t?this.supporter:t,void 0===e?this.supported:e)},Yr.prototype.hashCode=function(){var t=0;return 31*(t=31*t+e.hashCode(this.supporter)|0)+e.hashCode(this.supported)|0},Yr.prototype.equals=function(t){return this===t||null!==t&&"object"===a(t)&&Object.getPrototypeOf(this)===Object.getPrototypeOf(t)&&e.equals(this.supporter,t.supporter)&&e.equals(this.supported,t.supported)},Object.defineProperty(Qr.prototype,"prologRawTheory",{configurable:!0,get:function(){return Wo().theoryCode}}),Qr.$metadata$={kind:y,simpleName:"EngineInterface",interfaces:[xe]};var Kr=null;function Zr(){return null===Kr&&new Qr,Kr}function Jr(){to=this,tn.call(this)}Object.defineProperty(Jr.prototype,"prologRawTheory",{configurable:!0,get:function(){return Ho().theoryCode}}),Jr.$metadata$={kind:y,simpleName:"AbstractMode",interfaces:[tn]};var to=null;function eo(){return null===to&&new Jr,to}function no(){ro=this,mn.call(this)}Object.defineProperty(no.prototype,"prologRawTheory",{configurable:!0,get:function(){return Qo().theoryCode}}),no.$metadata$={kind:y,simpleName:"ArgumentationGraphBuilder",interfaces:[mn]};var ro=null;function oo(){return null===ro&&new no,ro}function io(){ao=this,gn.call(this)}Object.defineProperty(io.prototype,"prologRawTheory",{configurable:!0,get:function(){return Jo().theoryCode}}),io.$metadata$={kind:y,simpleName:"AttackRestrictionHandler",interfaces:[gn]};var ao=null;function so(){return null===ao&&new io,ao}function uo(){po=this,yn.call(this)}Object.defineProperty(uo.prototype,"prologRawTheory",{configurable:!0,get:function(){return ni().theoryCode}}),uo.$metadata$={kind:y,simpleName:"BpMetaGraphHandler",interfaces:[yn]};var po=null;function lo(){return null===po&&new uo,po}function co(){fo=this,hn.call(this)}Object.defineProperty(co.prototype,"prologRawTheory",{configurable:!0,get:function(){return Oi().theoryCode}}),co.$metadata$={kind:y,simpleName:"DefeasiblePreferencesHandler",interfaces:[hn]};var fo=null;function mo(){return null===fo&&new co,fo}function go(){yo=this,_n.call(this)}Object.defineProperty(go.prototype,"prologRawTheory",{configurable:!0,get:function(){return Ni().theoryCode}}),go.$metadata$={kind:y,simpleName:"GenericDefeasiblePreferencesHandler",interfaces:[_n]};var yo=null;function ho(){return null===yo&&new go,yo}function _o(){bo=this,bn.call(this)}Object.defineProperty(_o.prototype,"prologRawTheory",{configurable:!0,get:function(){return Bi().theoryCode}}),_o.$metadata$={kind:y,simpleName:"StrictPreferencesHandler",interfaces:[bn]};var bo=null;function Ao(){return null===bo&&new _o,bo}function $o(){Oo=this,An.call(this)}Object.defineProperty($o.prototype,"prologRawTheory",{configurable:!0,get:function(){return ui().theoryCode}}),$o.$metadata$={kind:y,simpleName:"BpCompleteLabeller",interfaces:[An]};var Oo=null;function To(){return null===Oo&&new $o,Oo}function Ro(){No=this,$n.call(this)}Object.defineProperty(Ro.prototype,"prologRawTheory",{configurable:!0,get:function(){return ii().theoryCode}}),Ro.$metadata$={kind:y,simpleName:"BpLabeller",interfaces:[$n]};var No=null;function So(){return null===No&&new Ro,No}function vo(){ko=this,On.call(this)}Object.defineProperty(vo.prototype,"prologRawTheory",{configurable:!0,get:function(){return ci().theoryCode}}),vo.$metadata$={kind:y,simpleName:"BpPartialLabeller",interfaces:[On]};var ko=null;function Co(){return null===ko&&new vo,ko}function Po(){Bo=this,Tn.call(this)}Object.defineProperty(Po.prototype,"prologRawTheory",{configurable:!0,get:function(){return yi().theoryCode}}),Po.$metadata$={kind:y,simpleName:"CompleteLabeller",interfaces:[Tn]};var Bo=null;function Io(){return null===Bo&&new Po,Bo}function xo(){Lo=this,Rn.call(this)}Object.defineProperty(xo.prototype,"prologRawTheory",{configurable:!0,get:function(){return ki().theoryCode}}),xo.$metadata$={kind:y,simpleName:"GroundedLabeller",interfaces:[Rn]};var Lo=null;function Do(){return null===Lo&&new xo,Lo}function Uo(){wo=this,Nn.call(this)}Object.defineProperty(Uo.prototype,"prologRawTheory",{configurable:!0,get:function(){return zi().theoryCode}}),Uo.$metadata$={kind:y,simpleName:"StatementLabeller",interfaces:[Nn]};var wo=null;function jo(){return null===wo&&new Uo,wo}function Eo(){zo=this,Sn.call(this)}Object.defineProperty(Eo.prototype,"prologRawTheory",{configurable:!0,get:function(){return wi().theoryCode}}),Eo.$metadata$={kind:y,simpleName:"RuleParser",interfaces:[Sn]};var zo=null;function Go(){return null===zo&&new Eo,zo}function Xo(){qo=this,this.theoryCode=yt("\n    computeGlobalAcceptance :-\n        buildGraph,\n        modifyGraph,\n        buildArgumentLabelling,\n        buildStatementLabelling.\n    computeGlobalAcceptance([Arguments, Attacks, Supports], [ArgsIn, ArgsOut, ArgsUnd], [StatIn, StatOut, StatUnd]) :-\n        computeGlobalAcceptance,\n        utils::recoverGraph(Arguments, Attacks, Supports),\n        utils::recoverArgumentLabelling(ArgsIn, ArgsOut, ArgsUnd),\n        utils::recoverStatementLabelling(StatIn, StatOut, StatUnd).\n    buildGraph :-\n        graphBuildMode(X),\n        X:::buildArgumentationGraph.\n    modifyGraph :-\n        findall(X, graphExtension(X), Ext),\n        modifyGraph(Ext).\n    modifyGraph([]).\n    modifyGraph([X|Ext]) :-\n        modifyGraph(Ext),\n        X:::modifyArgumentationGraph.\n    buildArgumentLabelling :-\n        argumentLabellingMode(X),\n        X:::argumentLabelling.\n    buildStatementLabelling :-\n        statementLabellingMode(X),\n        X:::statementLabelling.\n        ")}Xo.$metadata$={kind:y,simpleName:"AbstractMode",interfaces:[]};var qo=null;function Ho(){return null===qo&&new Xo,qo}function Mo(){Fo=this,this.theoryCode=yt("\n    argTuProlog.\n    buildLabelSets([StatIn, StatOut, StatUnd], [ArgsIn, ArgsOut, ArgsUnd]) :-\n        context_reset,\n        parser:::convertAllRules(_),\n        abstract::computeGlobalAcceptance(_, [ArgsIn, ArgsOut, ArgsUnd], [StatIn, StatOut, StatUnd]).\n    buildLabelSets(StatIn, StatOut, StatUnd) :-\n        buildLabelSets([StatIn, StatOut, StatUnd], _).\n    buildLabelSets :-\n        context_reset,\n        parser:::convertAllRules(ArgRules),\n        debug::printTheory(ArgRules),\n        abstract::computeGlobalAcceptance([Arguments, Attacks, Supports], [ArgsIn, ArgsOut, ArgsUnd], [StatIn, StatOut, StatUnd]),\n        debug::printArgumentationGraph(Arguments, Attacks, Supports),\n        debug::printArgumentLabelling([ArgsIn, ArgsOut, ArgsUnd]),\n        debug::printStatementLabelling([StatIn, StatOut, StatUnd]).\n    answerQuery(Goal, Yes, No, Und) :-\n        context_reset,\n        parser:::convertAllRules(_),\n        structured:::computeStatementAcceptance(Goal, Yes, No, Und).\n        ")}Mo.$metadata$={kind:y,simpleName:"ArgumentationEngineInterface",interfaces:[]};var Fo=null;function Wo(){return null===Fo&&new Mo,Fo}function Vo(){Yo=this,this.theoryCode=yt("\n    buildArgumentationGraph :-\n        buildArguments,\n        buildAttacks.\n    buildArguments :-\n    \tbuildArgumentsFromPremises,\n    \tfindall([RuleID, RuleBody, RuleHead], context_check(rule([RuleID, RuleBody, RuleHead])), Rules),\n    \tbuildArgumentsFromRules(Rules, Rules, n).\n    buildArgumentsFromPremises :-\n        findall(\n            _,\n            (\n                context_check(premise([PremiseID, Premise])),\n                checkStrict(PremiseID, DefPrem),\n                ground(Premise),\n                context_assert(argument([[PremiseID], none, Premise, [], [[], [], DefPrem]]))\n            ),\n            _\n        ).\n    buildArgumentsFromRules(Rules, [], n).\n    buildArgumentsFromRules(Rules, [], y) :- buildArgumentsFromRules(Rules, Rules, n).\n    buildArgumentsFromRules(Rules, [H|T], _) :-\n        copy_term(H, HH),\n        buildArgumentsFromRule(HH),\n        buildArgumentsFromRules(Rules, T, y), !.\n    buildArgumentsFromRules(Rules, [_|T], X) :-\n        buildArgumentsFromRules(Rules, T, X).\n    buildArgumentsFromRule([RuleID, RuleBody, RuleHead]) :-\n    \truleBodyIsSupported(RuleBody, [], [], SupportRules, ArgSupports),\n    \t\\+ member(RuleID, SupportRules),\n    \tground(RuleHead),\n    \tutils::sort([RuleID|SupportRules], SortedPremises),\n    \t\\+ context_check(argument([SortedPremises, RuleID, RuleHead, RuleBody, _])),\n    \tbuildArgumentInfo(ArgSupports, RuleID, Info),\n        NewArgument = [SortedPremises, RuleID, RuleHead, RuleBody, Info],\n    \tcontext_assert(argument(NewArgument)),\n    \tsupports(NewArgument, ArgSupports).\n    supports(Argument, Supports) :-\n        findall(_, (\n            member(S, Supports),\n            context_assert(support(S, Argument))\n        ), _).\n    checkStrict(Id, [Id]) :- \\+ context_check(strict(Id)).\n    checkStrict(Id, []) :- context_check(strict(Id)).\n    buildArgumentInfo(Supports, RuleId, [LastDefRules, DefRules, DefPrem]) :-\n        defeasibleRules(RuleId, Supports, DefRules),\n        ordinaryPremises(Supports, DefPrem),\n        lastDefeasibleRules(Supports, RuleId, LastDefRules).\n    ordinaryPremises(Supports, DefPrem) :-\n        findall(Def, member([_, _, _, _, [_, _, Def]], Supports), Prem),\n        utils::appendLists(Prem, TempPrem),\n        utils::sortDistinct(TempPrem, DefPrem).\n    defeasibleRules(RuleId, Supports, DefRules) :-\n    \tfindall(Def, member([_, _, _, _, [_, Def, _]], Supports), UnsortedRules),\n    \tcheckStrict(RuleId, DefRule),\n    \tutils::appendLists([DefRule|UnsortedRules], TempRules),\n    \tutils::sortDistinct(TempRules, DefRules).\n    lastDefeasibleRules(_, TopRule, [TopRule]) :-\n        TopRule \\== none, \\+ context_check(strict(TopRule)).\n    lastDefeasibleRules(Supports, TopRule, LastRules) :-\n    \tcontext_check(strict(TopRule)),\n    \tfindall(Def, member([_, _, _, _, [Def, _, _]], Supports), Res),\n    \tutils::appendLists(Res, TempLastRules),\n    \tutils::sortDistinct(TempLastRules, LastRules).\n    ruleBodyIsSupported([], ResultPremises, ResultSupports, ResultPremises, ResultSupports).\n    ruleBodyIsSupported([ [unless, _] | Others], Premises, Supports, ResultPremises, ResultSupports) :-\n    \truleBodyIsSupported(Others, Premises, Supports, ResultPremises, ResultSupports).\n    ruleBodyIsSupported([ [prolog(Check)] | Others], Premises, Supports, ResultPremises, ResultSupports) :-\n    \t(callable(Check) -> call(Check); Check),\n    \truleBodyIsSupported(Others, Premises, Supports, ResultPremises, ResultSupports).\n    ruleBodyIsSupported([Statement|Others], Premises, Supports, ResultPremises, ResultSupports) :-\n        context_check(argument([ArgumentID, RuleID, Statement, Body, Info])),\n    \tappend(ArgumentID, Premises, NewPremises),\n    \truleBodyIsSupported(Others, NewPremises, [[ArgumentID, RuleID, Statement, Body, Info]|Supports], ResultPremises, ResultSupports).\n    buildAttacks :-\n        findall(X, context_check(argument(X)), Args),\n    \tbuildDirectAttacks(Args),\n    \tbuildTransitiveAttacks.\n    buildDirectAttacks([]).\n    buildDirectAttacks([H|T]) :-\n        findall(_, buildDirectAttack(H), _),\n        buildDirectAttacks(T).\n    buildDirectAttack(A) :-\n    \tcontext_check(argument(B)),\n    \tA \\== B,\n        attacks(T, A, B),\n    \t\\+ context_check(attack(T, A, B, B)),\n    \tcontext_assert(attack(T, A, B, B)).\n    buildTransitiveAttacks :-\n    \tcontext_check(attack(T, A, B, D)),\n    \tcontext_check(support(B, C)),\n    \t\\+ context_check(attack(T, A, C, D)), !,\n    \tcontext_assert(attack(T, A, C, D)),\n        buildTransitiveAttacks.\n    buildTransitiveAttacks.\n    attacks(rebut, A, B) :- rebuts(A, B), !.\n    attacks(contrary_rebut, A, B) :- contraryRebuts(A, B), !.\n    attacks(undermine, A, B) :- undermines(A, B), !.\n    attacks(contrary_undermine, A, B) :- contraryUndermines(A, B), !.\n    attacks(undercut, A, B) :- undercuts(A, B), !.\n    rebuts([IDPremisesA, RuleA, RuleHeadA, _, _], [IDPremisesB, RuleB, RuleHeadB, _, Info]) :-\n    \tRuleB \\== none,\n        Info \\== [[], [], []],\n    \tconflict(RuleHeadA, RuleHeadB).\n    contraryRebuts([IDPremisesA, RuleA, RuleHeadA, _, _], [IDPremisesB, RuleB, RuleHeadB, Body, Info]) :-\n    \tRuleA \\== none,\n    \tRuleB \\== none,\n    \tmember([unless, RuleHeadA], Body).\n    undermines([IDPremisesA, RuleA, RuleHeadA, _, _], [[IDPremiseB], none, RuleHeadB, _, Info]) :-\n    \tInfo \\== [[], [], []],\n    \tconflict(RuleHeadA, RuleHeadB).\n    contraryUndermines([IDPremisesA, none, RuleHeadA, _, _], [IDPremisesB, RuleB, RuleHeadB, Body, Info]) :-\n    \tRuleB \\== none,\n    \tmember([unless, RuleHeadA], Body).\n    undercuts([_, _, [undercut(RuleB)], _, _], [_, RuleB, _, _, [[RuleB], _, _]]).\n    conflict( [Atom], [neg, Atom]).\n    conflict( [neg, Atom], [Atom]).\n    conflict( [obl, [Atom]],  [obl, [neg, Atom]]).\n    conflict( [obl, [neg, Atom]],  [obl, [Atom]]).\n    conflict( [obl, Lit],  [neg, obl, Lit]).\n    conflict( [neg, obl, Lit],  [obl, Lit]).\n    conflict( [perm, [Atom]],  [obl, [neg, Atom]]).\n    conflict( [obl, [neg, Atom]],  [perm, [Atom]]).\n    conflict( [perm, [neg, Atom]],  [obl, [Atom]]).\n    conflict( [obl, [Atom]],  [perm, [neg, Atom]]).\n    conflict([bp, Atom], [neg, bp, Atom]).\n    conflict([neg, bp, Atom], [bp, Atom]).\n    conflict([sup(X, Y)],  [sup(Y, X)]).\n        ")}Vo.$metadata$={kind:y,simpleName:"ArgumentationGraph",interfaces:[]};var Yo=null;function Qo(){return null===Yo&&new Vo,Yo}function Ko(){Zo=this,this.theoryCode=yt("\n    modifyArgumentationGraph :-\n        findall(_, (\n            context_check(attack(T, A, B, C)),\n            checkRebutRestriction(T, A, B, C)\n        ), _).\n    checkRebutRestriction(T, A, B, C) :-\n        \\+ rebutRestriction(T, A, B, C),\n        context_retract(attack(T, A, B, C)).\n    rebutRestriction(rebut, _, _, C) :- restrict(C).\n    rebutRestriction(undermine, _, _, C).\n    rebutRestriction(contrary_rebut, _, _, _).\n    rebutRestriction(contrary_undermine, _, _, _).\n    rebutRestriction(undercut, _, _, _).\n    restrict([_, TopRule, _, _, [[TopRule], _, _]]) :- TopRule \\== none.\n        ")}Ko.$metadata$={kind:y,simpleName:"AttackRestriction",interfaces:[]};var Zo=null;function Jo(){return null===Zo&&new Ko,Zo}function ti(){ei=this,this.theoryCode=yt("\n    modifyArgumentationGraph :-\n        findall(([Rules, Top, [bp, Checked], G, I], [Z, P, Y, GG, II]), (\n            context_check(argument([Rules, Top, [bp, Checked], G, I])),\n            member(Y, Checked),\n            context_check(argument([Z, P, Y, GG, II]))\n        ), TemplateBpPairs),\n        checkBpArguments(TemplateBpPairs).\n    checkBpArguments([]).\n    checkBpArguments(TemplateBpPairs) :-\n        createBpArguments(TemplateBpPairs, BpPairs),\n        createBpAttacks(BpPairs).\n    createBpArguments([], []).\n    createBpArguments([(Original, [Z, P, Y, B, I])|Others], [(Conflict, [Z, P, Y, B, I])|BpPairs]) :-\n        Conflict = [[artificial|Z], artificial, [neg, burdmet(Y)], [], [[artificial], [artificial], []]],\n        context_assert(argument(Conflict)),\n        context_assert(support(Original, Conflict)),\n        liftBpAttacks(Original, Conflict),\n        createBpArguments(Others, BpPairs).\n    liftBpAttacks(Template, BpArg) :-\n        findall(_, (\n            context_check(attack(T, A, Template, O)),\n            context_assert(attack(T, A, BpArg, O))\n        ), _).\n    createBpAttacks(BpPairs) :-\n        generateBpsEvaluationChain(BpPairs, OrderedBpPairs),\n        evaluateBurdenedArgs(OrderedBpPairs).\n    generateBpsEvaluationChain([], []).\n    generateBpsEvaluationChain([BpPair|BpPairs], OrderedBpPairs) :-\n        generateBpsEvaluationChain(BpPairs, TempOrderedBpPairs),\n        insertBpPair(BpPair, TempOrderedBpPairs, OrderedBpPairs).\n    insertBpPair(BpPair, [], [BpPair]).\n    insertBpPair((Bp, Burdened), [(BpL, BurdenedL)|Others], [(BpL, BurdenedL)|Return]) :-\n        bp_grounded::argumentChain(BurdenedL, Burdened),\n        insertBpPair((Bp, Burdened), Others, Return), !.\n    insertBpPair((Bp, Burdened), [(BpL, BurdenedL)|Others], [(Bp, Burdened)|[(BpL, BurdenedL)|Others]]).\n    evaluateBurdenedArgs([]).\n    evaluateBurdenedArgs([(Bp, Burdened)|Others]) :-\n        context_active(X),\n        grounded:::argumentLabelling,\n        statusToAttack((Bp, Burdened), Attack),\n        context_checkout(X),\n        context_assert(Attack),\n        evaluateBurdenedArgs(Others).\n    statusToAttack((Bp, Burdened), attack(bprebut, Burdened, Bp, Bp)) :-\n        context_check(in(Burdened)).\n    statusToAttack((Bp, Burdened), attack(bprebut, Bp, Burdened, Burdened)) :-\n        \\+ context_check(in(Burdened)).\n        ")}ti.$metadata$={kind:y,simpleName:"Bp",interfaces:[]};var ei=null;function ni(){return null===ei&&new ti,ei}function ri(){oi=this,this.theoryCode=yt("\n    argumentLabelling :-\n        reifyBurdenOfProofs,\n        filterBpDefeats,\n        findall(X, context_check(argument(X)), Arguments),\n        bpLabelling(Arguments).\n    bpLabelling(Arguments) :-\n        member(A, Arguments),\n        grounded::allAttacksOUT(A), !,\n        context_assert(in(A)),\n        utils::subtract(Arguments, [A], NewArguments),\n        bpLabelling(NewArguments).\n    bpLabelling(Arguments) :-\n        member(A, Arguments),\n        \\+ isArgumentInBurdenOfProof(A),\n        grounded::oneAttackIN(A), !,\n        context_assert(out(A)),\n        utils::subtract(Arguments, [A], NewArguments),\n        bpLabelling(NewArguments).\n    bpLabelling(Arguments) :-\n        context_active(Branch),\n        mostGroundedBpUnd(Arguments, A),\n        context_branch(Branch, _),\n        context_assert(out(A)),\n        utils::subtract(Arguments, [A], NewArguments),\n        bpLabelling(NewArguments).\n    bpLabelling(Args) :-\n        notLabelled(Args),\n        findall(_, (member(A, Args), context_assert(und(A))), _).\n    notLabelled(Args) :-\n        \\+ (\n            member(A, Args),\n            (\n                context_check(in(A));\n                context_check(out(A));\n                context_check(und(A))\n            )\n        ).\n    isInBurdenOfProof(Conclusion) :-\n        context_check(reifiedBp(Literals)),\n        member(Conclusion, Literals), !.\n    isArgumentInBurdenOfProof([_, _, Conclusion, _, _]) :-\n        isInBurdenOfProof(Conclusion).\n    filterBpDefeats :-\n        findall(_, (\n            context_check(attack(T, A, B, C)),\n            filterBpDefeat(T, A, B, C)\n        ), _).\n    filterBpDefeat(T, B, A, C) :-\n        (T = rebut; T = undermine),\n        isArgumentInBurdenOfProof(B),\n        \\+ superiority::superiorArgument(B, C),\n        context_retract(attack(T, B, A, C)).\n    mostGroundedBpUnd(Arguments, Arg) :-\n        member(Arg, Arguments),\n        isArgumentInBurdenOfProof(Arg),\n        \\+ (\n            member(A, Arguments), Arg \\= A,\n            isArgumentInBurdenOfProof(A),\n            argumentChain(A, Arg)\n        ).\n    argumentChain(A, A) :- !.\n    argumentChain(A, B) :-\n        A \\== B,\n        context_check(attack(_, A, C, _)),\n        argumentChain(C, B).\n    reifyBurdenOfProofs :-\n        findall(_, (\n            context_check(abstractBp(AbstractBp)),\n            fillTemplate(AbstractBp, R),\n            \\+ context_check(reifiedBp(R)),\n            context_assert(reifiedBp(R))\n        ), _).\n    /*\n        Fill the template (first parameter) using arguments conclusions\n    */\n    fillTemplate([], []).\n    fillTemplate([H|T], [H|R]) :-\n        context_check(argument([_, _, Conclusion, _, _])),\n        fillTemplate(T, R).\n        ")}ri.$metadata$={kind:y,simpleName:"BpGrounded",interfaces:[]};var oi=null;function ii(){return null===oi&&new ri,oi}function ai(){si=this,this.theoryCode=yt("\n    argumentLabelling :-\n        bp_grounded::reifyBurdenOfProofs,\n        findall(X, context_check(argument(X)), Arguments),\n        completeBpLabelling(go, Arguments).\n    completeBpLabelling(stop, _).\n    completeBpLabelling(go, Arguments) :-\n        bp_grounded_partial::partialBpLabelling(Arguments), !,\n        findall(X, (context_check(und(X)), context_retract(und(X))), NewArgs),\n        grounded::groundedLabelling(NewArgs),\n        findall(X, context_check(und(X)), LeftArguments),\n        stopCondition(Stop, Arguments, LeftArguments),\n        completeBpLabelling(Stop, LeftArguments).\n    stopCondition(stop, Args, NewArgs) :-\n        utils::sort(Args, SortedArgs),\n        utils::sort(NewArgs, SortedArgs), !.\n    stopCondition(go, _, _) :- context_retract(und(_)).\n        ")}ai.$metadata$={kind:y,simpleName:"BpGroundedComplete",interfaces:[]};var si=null;function ui(){return null===si&&new ai,si}function pi(){li=this,this.theoryCode=yt("\n    argumentLabelling :-\n        bp_grounded::reifyBurdenOfProofs,\n        findall(X, context_check(argument(X)), Arguments),\n        partialBpLabelling(Arguments), !.\n    partialBpLabelling([]).\n    partialBpLabelling(Arguments) :-\n        mostGroundedArgument(Arguments, A),\n        debug::writeDebug(['Evaluating ', A]),\n        demonstration(Arguments, A, [A], Evaluated),\n        utils::subtract(Arguments, [Evaluated], NewArgs),\n        partialBpLabelling(NewArgs).\n    /*\n        (a.i) BP(neg()), and no argument B for neg() such that A < B is IN*, and no A1,...An is OUT*\n    */\n    demonstration(Arguments, A, Resolving, A) :-\n    \tisComplementInBurdenOfProof(A),\n    \t\\+ notEvaluatedSuperiorComplementArgument(Arguments, A, Resolving, _),\n    \t\\+ (\n    \t    superiorComplementArgument(A, B),\n    \t    context_check(in(B))\n    \t),\n    \t\\+ notEvaluatedSubArgument(Arguments, A, Resolving, _),\n    \t\\+ (\n    \t    context_check(support(X, A)),\n    \t    context_check(out(X))\n    \t),\n    \tdebug::writeDebug(['Adding argument: ', A, ' to IN* (2.a.i)']),\n        context_assert(in(A)).\n    /*\n        (a.ii) not BP(neg()) and every argument B for neg() such that B(not <)A is OUT*, and every A1,...An is IN*\n    */\n    demonstration(Arguments, A, Resolving, A) :-\n    \t\\+ isComplementInBurdenOfProof(A),\n    \t\\+ notEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, _),\n    \t\\+ (\n            superiorOrEqualComplementArgument(A, B),\n            \\+ context_check(out(B))\n        ),\n    \t\\+ notEvaluatedSubArgument(Arguments, A, Resolving, _),\n    \t\\+ (\n            context_check(support(X, A)),\n            \\+ context_check(in(X))\n        ),\n    \tdebug::writeDebug(['Adding argument: ', A, ' to IN* (2.a.ii)']),\n        context_assert(in(A)).\n    /*\n        (b.i.1) BP() and exists an argument B for neg() such that B(not <)A is not OUT*\n    */\n    demonstration(Arguments, A, Resolving, A) :-\n    \tbp_grounded::isArgumentInBurdenOfProof(A),\n    \t\\+ notEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, _),\n    \tsuperiorOrEqualComplementArgument(A, B),\n    \t\\+ context_check(out(B)),\n        debug::writeDebug(['Adding argument: ', A, ' to OUT* (2.b.i.1)']),\n        context_assert(out(A)).\n    /*\n        (b.i.2) BP() and exist one of A1,...An is not IN*\n    */\n    demonstration(Arguments, A, Resolving, A) :-\n    \tbp_grounded::isArgumentInBurdenOfProof(A),\n    \t\\+ notEvaluatedSubArgument(Arguments, A, Resolving, _),\n    \tcontext_check(support(X, A)),\n        \\+ context_check(in(X)),\n        debug::writeDebug(['Adding argument: ', A, ' to OUT* (2.b.i.2)']),\n        context_assert(out(A)).\n    /*\n        (b.ii.1) not BP() and an argument B for neg() such A < B is IN*\n    */\n    demonstration(Arguments, A, Resolving, A) :-\n    \t\\+ bp_grounded::isArgumentInBurdenOfProof(A),\n    \t\\+ notEvaluatedSuperiorComplementArgument(Arguments, A, Resolving, _),\n    \tsuperiorComplementArgument(A, B),\n    \tcontext_check(in(B)),\n        debug::writeDebug(['Adding argument: ', A, ' to OUT* (2.b.ii.1)']),\n        context_assert(out(A)).\n    /*\n        (b.ii.2) not BP() and one of A1,...An is OUT*\n    */\n    demonstration(Arguments, A, Resolving, A) :-\n    \t\\+ bp_grounded::isArgumentInBurdenOfProof(A),\n    \t\\+ notEvaluatedSubArgument(Arguments, A, Resolving, _),\n    \tcontext_check(support(X, A)),\n        context_check(out(X)),\n        debug::writeDebug(['Adding argument: ', A, ' to OUT* (2.b.ii.2)']),\n        context_assert(out(A)).\n    /*\n        If above definitions do not apply try to decide on the arguments on which they depend\n    */\n    demonstration(Arguments, A, Resolving, Evaluated) :-\n        isComplementInBurdenOfProof(A),\n    \tnotEvaluatedSuperiorComplementArgument(Arguments, A, Resolving, B),\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\n    demonstration(Arguments, A, Resolving, Evaluated) :-\n    \tisComplementInBurdenOfProof(A),\n    \t\\+ notEvaluatedSuperiorComplementArgument(Arguments, A, Resolving, _),\n    \t\\+ (\n            superiorComplementArgument(A, X),\n            context_check(in(X))\n        ),\n        notEvaluatedSubArgument(Arguments, A, Resolving, B),\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\n    demonstration(Arguments, A, Resolving, Evaluated) :-\n        \\+ isComplementInBurdenOfProof(A),\n    \tnotEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, B),\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\n    demonstration(Arguments, A, Resolving, Evaluated) :-\n    \t\\+ isComplementInBurdenOfProof(A),\n    \t\\+ notEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, _),\n    \t\\+ (\n            superiorOrEqualComplementArgument(A, X),\n            \\+ context_check(out(X))\n        ),\n        notEvaluatedSubArgument(Arguments, A, Resolving, B),\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\n    demonstration(Arguments, A, Resolving, Evaluated) :-\n    \tbp_grounded::isArgumentInBurdenOfProof(A),\n    \tnotEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, B),\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\n    demonstration(Arguments, A, Resolving, Evaluated) :-\n    \tbp_grounded::isArgumentInBurdenOfProof(A),\n    \tnotEvaluatedSubArgument(Arguments, A, Resolving, B),\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\n    demonstration(Arguments, A, Resolving, Evaluated) :-\n    \t\\+ bp_grounded::isArgumentInBurdenOfProof(A),\n    \tnotEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, B),\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\n    demonstration(Arguments, A, Resolving, Evaluated) :-\n    \t\\+ bp_grounded::isArgumentInBurdenOfProof(A),\n    \tnotEvaluatedSubArgument(Arguments, A, Resolving, B),\n        demonstration(Arguments, B, [B|Resolving], Evaluated).\n    /*\n        (c) A is labelled UND* otherwise.\n    */\n    demonstration(Arguments, A, Resolving, A) :-\n    \tdebug::writeDebug(['Adding argument: ', A, ' to UND* (2.c)']),\n        context_assert(und(A)).\n    isComplementInBurdenOfProof(A) :-\n        complement(A, Complement),\n        bp_grounded::isInBurdenOfProof(Complement), !.\n    mostGroundedArgument([], []).\n    mostGroundedArgument([X], X).\n    mostGroundedArgument([[L, _, _, _, _]|T], [L2, Q2, W2, B2, I2]) :-\n        mostGroundedArgument(T, [L2, Q2, W2, B2, I2]),\n        length(L, LN1),\n        length(L2, LN2),\n        LN1 > LN2, !.\n    mostGroundedArgument([A|_], A).\n    /*\n        Get a conclusion complement\n    */\n    complement([_, _, Conclusion, _, _], A) :-\n        standard_af::conflict(Conclusion, A).\n    notEvaluatedSubArgument(Arguments, A, Resolving, B) :-\n        context_check(support(B, A)),\n        member(B, Arguments),\n        \\+ member(B, Resolving).\n    notEvaluatedSuperiorComplementArgument(Arguments, A, Resolving, B) :-\n        superiorComplementArgument(A, B),\n        member(B, Arguments),\n        \\+ member(B, Resolving).\n    notEvaluatedSuperiorOrEqualComplementArgument(Arguments, A, Resolving, B) :-\n        superiorOrEqualComplementArgument(A, B),\n        member(B, Arguments),\n        \\+ member(B, Resolving).\n    superiorComplementArgument(A, [A, B, CA, BB, I]) :-\n        complement(A, CA),\n        context_check(argument([R, B, CA, BB, I])),\n        superiority::superiorArgument([R, B, CA, BB, I], A).\n    superiorOrEqualComplementArgument(A, [R, B, CA, BB, I]) :-\n        complement(A, CA),\n        context_check(argument([R, B, CA, BB, I])),\n        \\+ superiority::superiorArgument(A, [R, B, CA, BB, I]).\n        ")}pi.$metadata$={kind:y,simpleName:"BpGroundedPartial",interfaces:[]};var li=null;function ci(){return null===li&&new pi,li}function di(){fi=this,this.theoryCode=yt("\n    argumentBPLabelling([Arguments, Attacks, _], [BPIN, BPOUT, BPUND]) :-\n        reifyBurdenOfProofs(Arguments, [], []),\n        once(filterBpDefeat(Attacks, FilteredAttacks)),\n        smartBpLabelling(Arguments, FilteredAttacks, [], [], [], BPIN, BPOUT, BPUND), !.\n    filterBpDefeat([], []).\n    filterBpDefeat([(T, B, A)|Attacks], FilteredAttacks) :-\n        (T = rebut; T = undermine),\n        isArgumentInBurdenOfProof(B),\n        attack(T, B, A, C),\n        \\+ superiorArgument(B, A, C),\n        filterBpDefeat(Attacks, FilteredAttacks).\n    filterBpDefeat([A|Attacks], [A|FilteredAttacks]) :-\n        filterBpDefeat(Attacks, FilteredAttacks).\n    smartBpLabelling(Arguments, Attacks, IN, OUT, UND, ResultIN, ResultOUT, ResultUND) :-\n        member(A, Arguments),\n        allAttacksOUT(Attacks, A, OUT),\n        subtract(Arguments, [A], NewArguments),\n        smartBpLabelling(NewArguments, Attacks, [A|IN], OUT, UND, ResultIN, ResultOUT, ResultUND).\n    smartBpLabelling(Arguments, Attacks, IN, OUT, UND, ResultIN, ResultOUT, ResultUND) :-\n        member(A, Arguments),\n        \\+ isArgumentInBurdenOfProof(A),\n        oneAttackIN(Attacks, A, IN),\n        subtract(Arguments, [A], NewArguments),\n        smartBpLabelling(NewArguments, Attacks, IN, [A|OUT], UND, ResultIN, ResultOUT, ResultUND).\n    smartBpLabelling(Arguments, Attacks, IN, OUT, UND, ResultIN, ResultOUT, ResultUND) :-\n        mostGroundedBpUnd(Arguments, Attacks, A),\n        subtract(Arguments, [A], NewArguments),\n        smartBpLabelling(NewArguments, Attacks, IN, [A|OUT], UND, ResultIN, ResultOUT, ResultUND).\n    smartBpLabelling(Arguments, _, IN, OUT, _, IN, OUT, Arguments).\n    mostGroundedBpUnd(Arguments, Attacks, Arg) :-\n        member(Arg, Arguments),\n        isArgumentInBurdenOfProof(Arg),\n        \\+ (\n            (member(A, Arguments), Arg \\= A, isArgumentInBurdenOfProof(A)),\n            argumentChain(A, Arg, Attacks)\n        ).\n    writeDemonstration([]) :-\n        demonstration,\n        write('\\n').\n    writeDemonstration([X|T]) :-\n        demonstration,\n        write(X),\n        writeDemonstration(T).\n    writeDemonstration(_).\n    argumentBPLabelling(COMPLETION ,[IN, OUT, UND], [BPIN, BPOUT, BPUND]) :-\n        reifyBurdenOfProofs(IN, OUT, UND),\n        writeDemonstration(['=========================================>DEMONSTRATION']),\n        argumentBPLabelling(COMPLETION, IN, OUT, UND, BPIN, BPOUT, BPUND),\n        writeDemonstration(['=====================================>END DEMONSTRATION']), !.\n    argumentBPLabelling(partial, IN, OUT, UND, BPIN, BPOUT, BPUND) :-\n        partialHBPLabelling(UND, IN, OUT, [], BPIN, BPOUT, BPUND).\n    argumentBPLabelling(complete, IN, OUT, UND, BPIN, BPOUT, BPUND) :-\n        hbpComplete(go, IN, OUT, UND, BPIN, BPOUT, BPUND).\n    hbpComplete(stop, IN, OUT, UND, IN, OUT, UND).\n    hbpComplete(_, IN, OUT, UND, BPIN, BPOUT, BPUND) :-\n        writeDemonstration(['======================================================>']),\n        partialHBPLabelling(UND, IN, OUT, [], BaseIN, BaseOUT, BaseUND),\n        completeLabelling(BaseIN, BaseOUT, BaseUND, CompleteIN, CompleteOUT, CompleteUND),\n        stopCondition(FLAG, IN, CompleteIN, OUT, CompleteOUT, UND, CompleteUND),\n        hbpComplete(FLAG, CompleteIN, CompleteOUT, CompleteUND, BPIN, BPOUT, BPUND).\n    stopCondition(X, IN, CIN, OUT, COUT, UND, CUND) :-\n        sort(IN, SIN),\n        sort(CIN, SCIN),\n        sort(OUT, SOUT),\n        sort(COUT, SCOUT),\n        sort(UND, SUND),\n        sort(CUND, SCUND),\n        stopCondition_sorted(X, SIN, SCIN, SOUT, SCOUT, SUND, SCUND).\n    stopCondition_sorted(stop, IN, IN, OUT, OUT, UND, UND).\n    stopCondition_sorted(go, _, _, _, _, _, _).\n    partialHBPLabelling([], IN_STAR, OUT_STAR, UND_STAR, IN_STAR, OUT_STAR, UND_STAR).\n    partialHBPLabelling(UND, IN_STAR, OUT_STAR, UND_STAR, ResultIN, ResultOUT, ResultUND) :-\n        more_grounded_argument(UND, A),\n        writeDemonstration(['Evaluating ', A]),\n        demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, [A], NewUnd, TempIN, TempOUT, TempUND),\n        partialHBPLabelling(NewUnd, TempIN, TempOUT, TempUND, ResultIN, ResultOUT, ResultUND).\n    /*\n        (a.i) BP(neg()), and no argument B for neg() such that A < B is IN*, and no A1,...An is OUT*\n    */\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, OUT_STAR, UND_STAR) :-\n    \tisComplementInBurdenOfProof(A),\n    \t\\+ findSupUndComplargument(A, UND, RESOLVING, _, _),\n    \tnoSuperiorComplementInSet(A, IN_STAR),\n    \t\\+ findUndSubargument(A, UND, RESOLVING, _, _),\n    \tnoSubArgumentInSet(A, OUT_STAR),\n    \twriteDemonstration(['Adding argument: ', A, ' to IN* (2.a.i)']),\n        append(IN_STAR, [A], TempIN),\n        subtract(UND, [A], NewUnd).\n    /*\n        (a.ii) not BP(neg()) and every argument B for neg() such that B(not <)A is OUT*, and every A1,...An is IN*\n    */\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, OUT_STAR, UND_STAR) :-\n    \t\\+ isComplementInBurdenOfProof(A),\n    \t\\+ findSupOrEqualUndComplargument(A, UND, RESOLVING, _, _),\n    \tallComplementInSet(A, OUT_STAR),\n    \t\\+ findUndSubargument(A, UND, RESOLVING, _, _),\n    \tallSubArgumentInSet(A, IN_STAR),\n    \twriteDemonstration(['Adding argument: ', A, ' to IN* (2.a.ii)']),\n        append(IN_STAR, [A], TempIN),\n        subtract(UND, [A], NewUnd).\n    /*\n        (b.i.1) BP() and exists an argument B for neg() such that B(not <)A is not OUT*\n    */\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, IN_STAR, TempOUT, UND_STAR) :-\n    \tisArgumentInBurdenOfProof(A),\n    \t\\+ findSupOrEqualUndComplargument(A, UND, RESOLVING, _, _),\n    \toneOutSuperiorOrEqualComplementFromSet(A, UND, OUT_STAR),\n        writeDemonstration(['Adding argument: ', A, ' to OUT* (2.b.i.1)']),\n        append(OUT_STAR, [A], TempOUT),\n        subtract(UND, [A], NewUnd).\n    /*\n        (b.i.2) BP() and exist one of A1,...An is not IN*\n    */\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, IN_STAR, TempOUT, UND_STAR) :-\n    \tisArgumentInBurdenOfProof(A),\n    \t\\+ findUndSubargument(A, UND, RESOLVING, _, _),\n    \toneOutSubArgumentFromSet(A, UND, IN_STAR),\n        writeDemonstration(['Adding argument: ', A, ' to OUT* (2.b.i.2)']),\n        append(OUT_STAR, [A], TempOUT),\n        subtract(UND, [A], NewUnd).\n    /*\n        (b.ii.1) not BP() and an argument B for neg() such A < B is IN*\n    */\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, IN_STAR, TempOUT, UND_STAR) :-\n    \t\\+ isArgumentInBurdenOfProof(A),\n    \t\\+ findSupUndComplargument(A, UND, RESOLVING, _, _),\n    \toneInSuperiorOrEqualComplementFromSet(A, IN_STAR),\n        writeDemonstration(['Adding argument: ', A, ' to OUT* (2.b.ii.1)']),\n        append(OUT_STAR, [A], TempOUT),\n        subtract(UND, [A], NewUnd).\n    /*\n        (b.ii.2) not BP() and one of A1,...An is OUT*\n    */\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, IN_STAR, TempOUT, UND_STAR) :-\n    \t\\+ isArgumentInBurdenOfProof(A),\n    \t\\+ findUndSubargument(A, UND, RESOLVING, _, _),\n    \toneInSubArgumentFromSet(A, OUT_STAR),\n        writeDemonstration(['Adding argument: ', A, ' to OUT* (2.b.ii.2)']),\n        append(OUT_STAR, [A], TempOUT),\n        subtract(UND, [A], NewUnd).\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\n        isComplementInBurdenOfProof(A),\n    \tfindSupUndComplargument(A, UND, RESOLVING, NR, Compl),\n        demonstration(Compl, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\n    \tisComplementInBurdenOfProof(A),\n    \t\\+ findSupUndComplargument(A, UND, RESOLVING, _, _),\n    \tnoSuperiorComplementInSet(A, IN_STAR),\n        findUndSubargument(A, UND, RESOLVING, NR, Sub),\n        demonstration(Sub, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\n        \\+ isComplementInBurdenOfProof(A),\n    \tfindAllUndComplargument(A, UND, RESOLVING, NR, Compl),\n        demonstration(Compl, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\n    \t\\+ isComplementInBurdenOfProof(A),\n    \t\\+ findAllUndComplargument(A, UND, RESOLVING, _, _),\n    \tallComplementInSet(A, OUT_STAR),\n        findUndSubargument(A, UND, RESOLVING, NR, Sub),\n        demonstration(Sub, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\n    \tisArgumentInBurdenOfProof(A),\n    \tfindSupOrEqualUndComplargument(A, UND, RESOLVING, NR, Compl),\n        demonstration(Compl, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\n    \tisArgumentInBurdenOfProof(A),\n    \tfindUndSubargument(A, UND, RESOLVING, NR, Sub),\n        demonstration(Sub, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\n    \t\\+ isArgumentInBurdenOfProof(A),\n    \tfindSupOrEqualUndComplargument(A, UND, RESOLVING, NR, Compl),\n        demonstration(Compl, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, RESOLVING, NewUnd, TempIN, TempOUT, TempUND) :-\n    \t\\+ isArgumentInBurdenOfProof(A),\n    \tfindUndSubargument(A, UND, RESOLVING, NR, Sub),\n        demonstration(Sub, UND, IN_STAR, OUT_STAR, UND_STAR, NR, NewUnd, TempIN, TempOUT, TempUND).\n    /*\n        (c) A is labelled UND* otherwise.\n    */\n    demonstration(A, UND, IN_STAR, OUT_STAR, UND_STAR, _, NewUnd, IN_STAR, OUT_STAR, TempUND) :-\n    \twriteDemonstration(['Adding argument: ', A, ' to UND* (2.c)']),\n        append(UND_STAR, [A], TempUND),\n        subtract(UND, [A], NewUnd).\n    /*\n        Load dependencies\n    */\n    findUndSubargument(A, UND, RESOLVING, NEW_RESOLVING, Sub) :-\n        support(Sub, A),\n        member(Sub, UND),\n        \\+ member(Sub, RESOLVING),\n        append(RESOLVING, [Sub], NEW_RESOLVING).\n    findAllUndComplargument(A, UND, RESOLVING, NEW_RESOLVING, Compl) :-\n        allComplArguments(A, List),\n        findAcceptable(A, List, UND, RESOLVING, NEW_RESOLVING, Compl).\n    findSupUndComplargument(A, UND, RESOLVING, NEW_RESOLVING, Compl) :-\n        superiorComplArguments(A, List),\n        findAcceptable(A, List, UND, RESOLVING, NEW_RESOLVING, Compl).\n    findSupOrEqualUndComplargument(A, UND, RESOLVING, NEW_RESOLVING, Compl) :-\n        superiorOrEqualComplArguments(A, List),\n        findAcceptable(A, List, UND, RESOLVING, NEW_RESOLVING, Compl).\n    findAcceptable(A, List, UND, RESOLVING, NEW_RESOLVING, Compl) :-\n        member(Compl, List),\n        member(Compl, UND),\n        \\+ member(Compl, RESOLVING),\n        append(RESOLVING, [Compl], NEW_RESOLVING).\n    /*\n        Conditions\n    */\n    noSuperiorComplementInSet(Argument, Set) :-\n        superiorComplArguments(Argument, LIST),\n        noInWithEmptyCheck(LIST, Set).\n    noSubArgumentInSet(Argument, Set) :-\n        allDirectsSubArguments(Argument, LIST),\n        noInWithEmptyCheck(LIST, Set).\n    allComplementInSet(Argument, Set) :-\n        allComplArguments(Argument, LIST),\n        allInWithEmptyCheck(LIST, Set).\n    allSubArgumentInSet(Argument, Set) :-\n        allDirectsSubArguments(Argument, LIST),\n        allInWithEmptyCheck(LIST, Set).\n    oneOutSuperiorOrEqualComplementFromSet(Argument, UND, Set) :-\n        superiorOrEqualComplArguments(Argument, LIST),\n        oneOut(LIST, UND, Set).\n    oneOutSubArgumentFromSet(Argument, UND, Set) :-\n        allDirectsSubArguments(Argument, LIST),\n        oneOut(LIST, UND, Set).\n    oneInSuperiorOrEqualComplementFromSet(Argument, Set) :-\n        superiorOrEqualComplArguments(Argument, LIST),\n        oneIn(LIST, Set).\n    oneInSubArgumentFromSet(Argument, Set) :-\n        allDirectsSubArguments(Argument, LIST),\n        oneIn(LIST, Set).\n    /*\n        Support\n    */\n    allDirectsSubArguments(Argument, LIST) :-\n        findall(Sub, support(Sub, Argument), LIST).\n    allComplArguments(Argument, LIST) :-\n        findall(X, (\n            complement(Argument, CA),\n            findall([A, B, CA], argument([A, B, CA]), X)\n        ), Y),\n        appendLists(Y, LIST).\n    superiorComplArguments(Argument, LIST) :-\n        findall(X, (\n            complement(Argument, CA),\n            findall([A, B, CA], (argument([A, B, CA]), superiorArgument([A, B, CA], Argument)), X)\n        ), Y),\n        appendLists(Y, LIST).\n    superiorOrEqualComplArguments(Argument, LIST) :-\n        findall(X, (\n            complement(Argument, CA),\n            findall([A, B, CA], (argument([A, B, CA]), \\+ superiorArgument(Argument, [A, B, CA])), X)\n        ), Y),\n        appendLists(Y, LIST).\n    noInWithEmptyCheck([], _).\n    noInWithEmptyCheck(List, Target) :- noIn(List, Target).\n    noIn(List, Target) :-\n        member(X, List),\n        \\+ member(X, Target).\n    allInWithEmptyCheck([], _).\n    allInWithEmptyCheck(List, Target) :- allIn(List, Target).\n    allIn(List, Target) :-\n        member(_, List),\n        \\+ (member(Y, List), \\+ member(Y, Target)).\n    oneInWithEmptyCheck([], _).\n    oneInWithEmptyCheck(List, Target) :- oneIn(List, Target).\n    oneIn(List, Target) :-\n        member(X, List),\n        member(X, Target).\n    oneOutWithEmptyCheck([], _, _).\n    oneOutWithEmptyCheck(List, UND, Target) :- oneOut(List, UND, Target).\n    oneOut(List, UND, Target) :-\n        member(X, List),\n        \\+ member(X, UND),\n        \\+ member(X, Target).\n    completeLabelling(IN, OUT, UND, ResultIN, ResultOUT, ResultUND) :-\n        findoneIn(IN, OUT, UND, A),\n        writeDemonstration(['Adding argument: ', A, ' to IN* (4.4)']),\n        append(IN, [A], NewIN),\n        subtract(UND, [A], NewUnd),\n        completeLabelling(NewIN, OUT, NewUnd, ResultIN, ResultOUT, ResultUND).\n    completeLabelling(IN, OUT, UND, ResultIN, ResultOUT, ResultUND) :-\n        findoneOut(IN, OUT, UND, A),\n        writeDemonstration(['Adding argument: ', A, ' to OUT* (4.4)']),\n        append(OUT, [A], NewOUT),\n        subtract(UND, [A], NewUnd),\n        completeLabelling(IN, NewOUT, NewUnd, ResultIN, ResultOUT, ResultUND).\n    completeLabelling(IN, OUT, UND, IN, OUT, UND).\n    findoneIn(IN, OUT, UND, A):-\n        member(A, UND),\n        completeIn(A, IN, OUT).\n    findoneOut(IN, OUT, UND, A):-\n        member(A, UND),\n        completeOut(A, IN, OUT).\n    completeIn(A, _, OUT) :- checkOutAttackers(A, OUT).\n    /*\n        If an attack exists, it should come from an OUT argument\n    */\n    checkOutAttackers(A, OUT) :-\n        \\+ ( attack(_, B, A), \\+ ( member(B, OUT)) ).\n    completeOut(A, IN, _) :- checkInAttacker(A, IN).\n    completeOut(A, IN, _) :- checkInAttecked(A, IN).\n    /*\n        Find an attack, if exists, from an IN argument, then ends\n    */\n    checkInAttacker(A, IN) :-\n        attack(_, B, A),\n        member(B, IN), !.\n    /*\n        If A attacks an IN argument, then A is OUT\n    */\n    checkInAttecked(A, IN) :-\n        attack(_, A, B),\n        member(B, IN), !.\n    /*\n        Checks Burden of proof membership\n    */\n    isInBurdenOfProof(Concl) :-\n        reifiedBp(Literals),\n        member(Concl, Literals), !.\n    isComplementInBurdenOfProof(A) :-\n        complement(A, Compl),\n        isInBurdenOfProof(Compl), !.\n    isArgumentInBurdenOfProof([_, _, Concl]) :-\n        isInBurdenOfProof(Concl).\n    more_grounded_argument([], []).\n    more_grounded_argument([X], X).\n    more_grounded_argument([[L,_,_]|T], [L2,Q2,W2]) :-\n        more_grounded_argument(T, [L2,Q2,W2]),\n        length(L, LN1),\n        length(L2, LN2),\n        LN1 > LN2.\n    more_grounded_argument([[L,Q,W]|_], [L,Q,W]).\n    /*\n        Get a conclusion complement\n    */\n    complement([_, _, Conc], A) :- conflict(Conc, A).\n    reifyBurdenOfProofs(IN, OUT, UND) :-\n        extractConclusions(IN, OUT, UND, Conclusions),\n        computeBp(Conclusions).\n    extractConclusions(IN, OUT, UND, SL) :-\n        findall(Conc, member([_, _, Conc], IN), In),\n        findall(Conc, member([_, _, Conc], OUT), Out),\n        findall(Conc, member([_, _, Conc], UND), Und),\n        appendLists([In, Out, Und], L),\n        sort(L, SL).\n    computeBp(Conclusions) :-\n        abstractBp(AbstractBp),\n        fillTemplate(AbstractBp, Conclusions, R),\n        \\+ reifiedBp(R),\n        asserta(reifiedBp(R)),\n        computeBp(Conclusions).\n    computeBp(_).\n    /*\n        Fill the template (first parameter) using predicates belonging\n        to the second list (second parameter)\n    */\n    fillTemplate([], _, []).\n    fillTemplate([H|T], C, [H|R]) :- member(H, C), fillTemplate(T, C, R).\n        ")}di.$metadata$={kind:y,simpleName:"BpPartialComplete",interfaces:[]};var fi=null;function mi(){gi=this,this.theoryCode=yt("\n    argumentLabelling :-\n        cache_retract(complete(_,_,_)),\n        grounded:::argumentLabelling,\n        context_active(Branch),\n        completeLabelling(Branch).\n    completeLabelling(_) :-\n        admissibleSet,\n        utils::recoverArgumentLabelling(In, Out, Und),\n        \\+ cache_check(complete(In, Out, Und)),\n        cache_assert(complete(In, Out, Und)).\n    completeLabelling(Branch) :-\n        context_check(und(X)),\n        context_branch(Branch, NewBranch),\n        findall(Y, (context_check(und(Y)), Y \\= X), Arguments),\n        context_retract(und(_)),\n        context_assert(in(X)),\n        grounded::groundedLabelling(Arguments),\n        completeLabelling(NewBranch).\n    admissibleSet :-\n        \\+ (context_check(in(H)), \\+ admissible(H)).\n    admissible(H) :-\n        \\+ (\n            context_check(attack(_, Attacker, H, _)),\n            \\+ (\n                context_check(attack(_, Defendant, Attacker, _)),\n                context_check(in(Defendant))\n            )\n        ).\n        ")}mi.$metadata$={kind:y,simpleName:"Complete",interfaces:[]};var gi=null;function yi(){return null===gi&&new mi,gi}function hi(){_i=this,this.theoryCode=yt("\n    printTheory(Rules) :-\n        write('HERE THE THEORY:'),nl,\n        findall(rule([Id, Body, Head]), member(rule([Id, Body, Head]), Rules), ListRules),\n        utils::writeListNl(ListRules),\n        findall(premise([A, B]), member(premise([A, B]), Rules), ListPremises),\n        utils::writeListNl(ListPremises),\n        findall(sup(A, B), member(sup(A, B), Rules), ListSups),\n        utils::writeListNl(ListSups).\n    printArgumentationGraph(Arguments, Attacks, Supports) :-\n    \tfindall(\n    \t    [IDPremises, '\\n',  ' TOPRULE ',  TopRule, '\\n', ' CONCLUSION ', RuleHead, '\\n', ' BODY ', Body, '\\n', ' INFO ', Info, '\\n'],\n    \t    member([IDPremises, TopRule, RuleHead, Body, Info], Arguments),\n            ArgumentsToPrint\n        ),\n        findall((A1, ' SUPPORTS ', A2), member((A1, A2), Supports), SupportsToPrint),\n    \tfindall((A1, ' ', T, ' ', A2, ' ON ', A3),  member((T, A1, A2, A3), Attacks),  AttacksToPrint),\n        write('HERE THE GROUNDED SEMI-ABSTRACT ARGUMENTATION GRAPH'),nl,\n    \tutils::writeListNl(ArgumentsToPrint),\n    \tutils::writeListNl(SupportsToPrint),\n    \tutils::writeListNl(AttacksToPrint).\n    printArgumentLabelling([IN, OUT, UND]) :-\n        write('HERE THE ARGUMENTS LABELLED IN: '),nl,\n        utils::writeListNl(IN),\n        write('HERE THE ARGUMENTS LABELLED OUT: '),nl,\n        utils::writeListNl(OUT),\n        write('HERE THE ARGUMENTS LABELLED UND: '),nl,\n        utils::writeListNl(UND).\n    printStatementLabelling([In, Ni, Und]) :-\n        write('HERE THE STATEMENTS LABELLED IN: '),nl,\n        utils::writeListNl(In),\n        write('HERE THE STATEMENTS LABELLED NI: '),nl,\n        utils::writeListNl(Ni),\n        write('HERE THE STATEMENTS LABELLED UND: '),nl,\n        utils::writeListNl(Und).\n    debug.\n    writeDebug(List) :-\n        debug,\n        utils::writeList(List).\n    writeDebug(_) :- \\+ debug.\n        ")}hi.$metadata$={kind:y,simpleName:"Debug",interfaces:[]};var _i=null;function bi(){return null===_i&&new hi,_i}function Ai(){$i=this,this.theoryCode=yt("\n    modifyArgumentationGraph :-\n        assertAllSup,\n        findall((T, A, B, C), context_check(attack(T, A, B, C)), Attacks),\n        filterSupRelatedAttacks(Attacks, InvalidAttacks),\n        convertAttacks(InvalidAttacks),\n        buildPrefAttacks.\n    assertAllSup :-\n        context_retract(sup(_, _)),\n        findall(_,\n            (\n                context_check(argument([_, _, [sup(RuleOne, RuleTwo)], _, _])),\n                \\+ context_check(sup(RuleOne, RuleTwo)),\n                context_assert(sup(RuleOne, RuleTwo))\n            ),\n        _).\n    filterSupRelatedAttacks([], []).\n    filterSupRelatedAttacks([(T, A, B, C)|Attacks], [(T, A, B, C)|Invalid]) :-\n        invalid(T, A, B, C, _),\n        filterSupRelatedAttacks(Attacks, Invalid), !.\n    filterSupRelatedAttacks([_|Attacks], Invalid) :-\n        filterSupRelatedAttacks(Attacks, Invalid).\n    invalid(rebut, A, B, C, SupSet) :- superiority::superiorArgument(C, A, SupSet), !.\n    invalid(undermine, A, B, C, SupSet) :- superiority::superiorArgument(C, A, SupSet), !.\n    /*\n    *   Translates the attack relations identified during the building phase.\n    *   Attack from A to B -> Argument [[], attack, Attack]\n    *                         support(A, Argument)\n    *                         attack(Argument, B)\n    *   If an Argument A built in this way attacks the argument B, and this one also attacks a third argument C\n    *   through the argument B1 we have to consider an attack from A to B1 (transitive attack)\n    */\n    convertAttacks(Attacks) :-\n        conversion(Attacks),\n        standard_af::buildTransitiveAttacks.\n    conversion(List) :-\n        member((T, A, B, B), List),\n        generateDirectAttackArgument(T, A, B, B),\n        fail.\n    conversion(List) :-\n        member((T, A, B, C), List),\n        C \\= B,\n        generateTransitiveAttackArgument(T, A, B, C),\n        fail.\n    conversion(_).\n    generateTransitiveAttackArgument(T, A, B, C) :-\n        context_check(argument([Id, attack, [attack(T, A, C, C)], G, I])),\n        context_assert(attack(T, [Id, attack, [attack(T, A, C, C)], G, I], B, C)),\n        context_retract(attack(T, A, B, C)).\n    generateDirectAttackArgument(T, A, B, B) :-\n        RArgument = [[attack], attack, [attack(T, A, B, B)], [], [[attack], [attack], []]],\n        \\+ context_check(argument(RArgument)),\n        context_assert(argument(RArgument)),\n        context_assert(support(A, RArgument)),\n        context_assert(attack(T, RArgument, B, B)),\n        context_retract(attack(T, A, B, B)).\n    /*\n    *   Computes the pref attack. If an Argument A has a conclusion in the form sup(a, b), we verify if\n    *   the attacks involving arguments built on the rules a or b are compatible with this preference.\n    *   If there are some contradictions we add an attack from the argument A towards the incompatible attack\n    */\n    buildPrefAttacks :-\n        context_check(argument([IdB, attack, [attack(T, A, B, C)], G, I])),\n        invalid(T, A, B, C, SupSet),\n        member(X, SupSet),\n        context_check(argument([IdA, TRA, [X], GG, II])),\n        Attack = attack(pref, [IdA, TRA, [X], GG, II], [IdB, attack, [attack(T, A, B, C)], G, I], [IdB, attack, [attack(T, A, B, C)], G, I]),\n        \\+ context_check(Attack),\n        context_assert(Attack),\n        fail.\n    buildPrefAttacks.\n        ")}Ai.$metadata$={kind:y,simpleName:"DefPreferences",interfaces:[]};var $i=null;function Oi(){return null===$i&&new Ai,$i}function Ti(){Ri=this,this.theoryCode=yt("\n    modifyArgumentationGraph :-\n        defeasiblePref::assertAllSup,\n        findall((T, A, B, C), context_check(attack(T, A, B, C)), Attacks),\n        defeasiblePref::filterSupRelatedAttacks(Attacks, InvalidAttacks),\n        defeasiblePref::convertAttacks(InvalidAttacks),\n        buildPrefAttacks,\n        standard_af::buildTransitiveAttacks.\n    buildPrefAttacks :-\n        context_check(argument([IdB, attack, [attack(T, A, B, C)], G, I])),\n        defeasiblePref::invalid(T, A, B, C, SupSet),\n        createSuperiorityArgument(SupSet, Arg),\n        write(Arg), nl,\n        Attack = attack(pref, Arg, [IdB, attack, [attack(T, A, B, C)], G, I], [IdB, attack, [attack(T, A, B, C)], G, I]),\n        \\+ context_check(Attack),\n        context_assert(Attack),\n        fail.\n    buildPrefAttacks.\n    createSuperiorityArgument(SupSet, Argument) :-\n        findall([Id, TR, [X], G, I], (\n            member(X, SupSet),\n            context_check(argument([Id, TR, [X], G, I]))\n        ), SupportArguments),\n        mergeIds(SupportArguments, MergedId),\n        Argument = [MergedId, pref, [mergedPreference], [], [[pref], MergedId, []]],\n        \\+ context_check(argument(Argument)),\n        context_assert(argument(Argument)),\n        findall(_, (\n            member(A, SupportArguments),\n            \\+ context_check(support(A, Argument)),\n            context_assert(support(A, Argument))\n        ), _).\n    mergeIds([], [pref]).\n    mergeIds(Arguments, [pref|MergedId]) :-\n        findall(Id, member([Id, _, _, _, _], Arguments), Res),\n        utils::appendLists(Res, MergedId).\n        ")}Ti.$metadata$={kind:y,simpleName:"GenericDefPreferences",interfaces:[]};var Ri=null;function Ni(){return null===Ri&&new Ti,Ri}function Si(){vi=this,this.theoryCode=yt("\n    argumentLabelling :-\n        findall(X, context_check(argument(X)), Arguments),\n        groundedLabelling(Arguments).\n    groundedLabelling(UND) :-\n        member(A, UND), \n        allAttacksOUT(A), !,\n        utils::subtract(UND, [A], NewUND),\n        context_assert(in(A)),\n        groundedLabelling(NewUND).\n    groundedLabelling(UND) :-\n        member(A, UND),\n        oneAttackIN(A), !,\n        utils::subtract(UND, [A], NewUND),\n        context_assert(out(A)),\n        groundedLabelling(NewUND).\n    groundedLabelling(Args) :- findall(_, (member(A, Args), context_assert(und(A))), _).\n    allAttacksOUT(A) :-\n        \\+ ( context_check(attack(_, B, A, _)), \\+ (context_check(out(B)))).\n    oneAttackIN(A) :-\n        context_check(attack(_, B, A, _)),\n        context_check(in(B)), !.\n    oneAttackIN(A) :-\n        context_check(attack(_, A, B, _)),\n        context_check(in(B)), !.\n        ")}Si.$metadata$={kind:y,simpleName:"Grounded",interfaces:[]};var vi=null;function ki(){return null===vi&&new Si,vi}function Ci(){Pi=this,this.theoryCode=yt("\n    modifyArgumentationGraph :-\n        findall(_, (\n            context_check(attack(T, A, B, C)),\n            checkStandardPreference(T, A, B, C)\n        ), _).\n    checkStandardPreference(T, A, B, C) :-\n        \\+ standardPreferences(T, A, B, C),\n        context_retract(attack(T, A, B, C)).\n    standardPreferences(rebut, A, _, C) :- \\+ superiority::superiorArgument(C, A).\n    standardPreferences(undermine, A, _, C) :- \\+ superiority::superiorArgument(C, A).\n    standardPreferences(contrary_rebut, _, _, _).\n    standardPreferences(contrary_undermine, _, _, _).\n    standardPreferences(undercut, _, _, _).\n        ")}Ci.$metadata$={kind:y,simpleName:"Preferences",interfaces:[]};var Pi=null;function Bi(){return null===Pi&&new Ci,Pi}function Ii(){xi=this,this.theoryCode=yt("\n    computeStatementAcceptance(Goal, YesResult, NoResult, UndResult) :-\n        \\+ queryMode,\n        abstract:::computeGlobalAcceptance,\n        mineResults(Goal, YesResult, NoResult, UndResult).\n    computeStatementAcceptance(Goal, YesResult, NoResult, UndResult) :-\n        queryMode,\n        argumentLabellingMode(grounded),\n        parser::check_modifiers_in_list(effects, [Goal], [X]),\n        findall(_, query(X, _), _),\n        statementLabellingMode(Y),\n        Y:::statementLabelling,\n        mineResults(Goal, YesResult, NoResult, UndResult).\n    mineResults(Goal, YesResult, NoResult, UndResult) :-\n        parser::check_modifiers_in_list(effects, [Goal], [X]),\n        findall(Goal, context_check(statIn(X)), In),\n        findall(Goal, context_check(statOut(X)), Out),\n        findall(Goal, context_check(statUnd(X)), Und),\n        utils::sort(In, YesResult),\n        utils::sort(Out, NoResult),\n        utils::sort(Und, UndResult).\n    query(Query, Res) :-\n        buildArgument(Query, Argument),\n        once(defend(Argument, [], Res)).\n    query(Query, und) :- \\+ buildArgument(Query, _).\n    defend(Argument, _, no) :- context_check(out(Argument)).\n    defend(Argument, _, und) :- context_check(und(Argument)).\n    defend(Argument, _, yes) :- context_check(in(Argument)).\n    defend(Argument, QueryChain, no) :-\n        findAttacker(Argument, QueryChain, Attacker, yes),\n        once(defend(Attacker, [Argument|QueryChain], X)),\n        X == yes,\n        bufferResult(Argument, no), !.\n    defend(Argument, QueryChain, und) :-\n        findAttacker(Argument, QueryChain, Attacker, no),\n        bufferResult(Argument, und), !.\n    defend(Argument, QueryChain, und) :-\n        findAttacker(Argument, QueryChain, Attacker, yes),\n        once(defend(Attacker, [Argument|QueryChain], X)),\n        X == und,\n        bufferResult(Argument, und), !.\n    defend(Argument, QueryChain, yes) :- bufferResult(Argument, yes).\n    bufferResult(Argument, no) :- \\+ context_check(out(Argument)), context_assert(out(Argument)), !.\n    bufferResult(Argument, yes) :- \\+ context_check(in(Argument)), context_assert(in(Argument)), !.\n    bufferResult(Argument, und) :- \\+ context_check(und(Argument)), context_assert(und(Argument)), !.\n    bufferResult(_, _).\n    findAttacker(Target, QueryChain, Attacker, IsValid) :-\n        attacker(Target, Attacker),\n        bufferAttacker(Attacker, Target),\n        detectCycle(Attacker, QueryChain, IsValid).\n    bufferAttacker(Attacker, Target) :-\n        \\+ context_check(attack(none, Attacker, Target, none)),\n        context_assert(attack(none, Attacker, Target, none)), !.\n    bufferAttacker(_, _).\n    detectCycle(Attacker, QueryChain, yes) :- \\+ member(Attacker, QueryChain).\n    detectCycle(Attacker, QueryChain, no) :- member(Attacker, QueryChain).\n    attacker([Rules, TopRule, Conclusion, Groundings, ArgInfo], Argument) :-\n        member(X, Rules),\n        \\+ context_check(strict(X)),\n        attackerOnRule(X, [Rules, TopRule, Conclusion, Groundings, ArgInfo], Argument).\n    attacker([Rules, TopRule, Conclusion, Groundings, ArgInfo], Argument) :-\n        member(X, Groundings),\n        attackerOnTerm(X, [Rules, TopRule, Conclusion, Groundings, ArgInfo], Argument).\n    attackerOnRule(Rule, _, Argument) :-\n        buildArgument([undercut(Rule)], Argument).\n    attackerOnTerm(Term, [TargetRules, TopRule, Conclusion, Groundings, ArgInfo], Attacker) :-\n        Term \\= [unless, _],\n        \\+ strict([TargetRules, TopRule, Conclusion, Groundings, ArgInfo]),\n        buildSubArgument(Term, TargetRules, SubArgument),\n        rebutRestriction(SubArgument),\n        standard_af::conflict(Term, X),\n        buildArgument(X, Attacker),\n        \\+ superiorArgument(SubArgument, Attacker).\n    attackerOnTerm([unless, X], _, Attacker) :-\n        buildArgument(X, Attacker).\n    strict([_, _, _, _, [_, [], []]]).\n    rebutRestriction([TargetRules, none, Conclusion, Groundings, ArgInfo]) :-\n        graphExtension(rebutRestriction).\n    rebutRestriction([TargetRules, TopRule, Conclusion, Groundings, ArgInfo]) :-\n        graphExtension(rebutRestriction),\n        TopRule \\= none,\n        rebutRestriction::restrict([TargetRules, TopRule, Conclusion, Groundings, ArgInfo]).\n    rebutRestriction(_) :- \\+ graphExtension(rebutRestriction).\n    superiorArgument(SubArgument, Attacker) :-\n        superiority::superiorArgument(SubArgument, Attacker).\n    buildSubArgument(Term, Rules, [SubRules, SubTopRule, SubConclusion, SubGrounds, Info]) :-\n        buildArgument(Term, [SubRules, SubTopRule, SubConclusion, SubGrounds, Info]),\n        contained(SubRules, Rules).\n    contained([], _).\n    contained([H|T], Target) :- member(H, Target), contained(T, Target).\n    buildArgument(Query, Argument) :-\n        \\+ context_check(explored(Query)),\n        findall(_, (\n            buildSingleArgument(Query, Argument),\n            context_assert(argument(Argument))\n        ), _),\n        context_assert(explored(Query)),\n        fail.\n    buildArgument(Query, [R, T, Query, B, I]) :- context_check(argument([R, T, Query, B, I])).\n    buildSingleArgument(Query, Argument) :-\n        build(Query, Groundings, [AllRules, TopRule, LastDefRules, DefRules, DefPremises]),\n        utils::deduplicate(DefRules, CDefRules),\n        utils::deduplicate(DefPremises, CDefPremises),\n        utils::deduplicate(Groundings, CGroundings),\n        Argument = [AllRules, TopRule, Query, CGroundings, [LastDefRules, CDefRules, CDefPremises]].\n    build(Conclusion, [Conclusion], Rules) :-\n        context_check(premise([Id, Conclusion])),\n        premiseRules(Id, Rules).\n    build(Conclusion, [Conclusion|Conclusions], Rules) :-\n        context_check(rule([Id, Premises, Conclusion])),\n        buildPremises(Premises, Conclusions, ResRules),\n        ruleRules(Id, ResRules, Rules).\n    build([prolog(Check)], [], []) :- (callable(Check) -> call(Check); Check).\n    build([unless, Atom], [[unless, Atom]], []).\n    buildPremises([], [], [[], [], [], []]).\n    buildPremises([H|T], Conclusions, Rules) :-\n        build(H, HConclusions, HRules),\n        buildPremises(T, TConclusions, TRules),\n        utils::appendLists([HConclusions, TConclusions], Conclusions),\n        mergeRules(HRules, TRules, Rules).\n    premiseRules(Id, [[Id], none, [], [], [Id]]) :- \\+ context_check(strict(Id)).\n    premiseRules(Id, [[Id], none, [], [], []]) :- context_check(strict(Id)).\n    ruleRules(Id, [AllRules, _, DefRules, DefPremises], \n        [[Id|AllRules], Id, [Id], [Id|DefRules], DefPremises]) :- \\+ context_check(strict(Id)).\n    ruleRules(Id, [AllRules, LastDefRules, DefRules, DefPremises], \n        [[Id|AllRules], Id, LastDefRules, DefRules, DefPremises]) :- context_check(strict(Id)).\n    mergeRules([], [AllRules, LastDefRules, DefRules, DefPremises], [AllRules, LastDefRules, DefRules, DefPremises]).\n    mergeRules([HAR, _, HLDR, HDR, HDP], [TAR, TLDR, TDR, TDP], [AR, LDR, DR, DP]) :-\n       utils::appendLists([HAR, TAR], AR),\n       utils::appendLists([HLDR, TLDR], LDR),\n       utils::appendLists([HDR, TDR], DR),\n       utils::appendLists([HDP, TDP], DP).\n        ")}Ii.$metadata$={kind:y,simpleName:"QueryMode",interfaces:[]};var xi=null;function Li(){return null===xi&&new Ii,xi}function Di(){Ui=this,this.theoryCode=yt("\n    /*\n     *  Main directive. Find all the rules in the theory in the format (Name : Preconditions => Conclusion)\n     *  or (Name : Effects) and then if:\n     *  - It is a standard rule, translate it in the standard format (rule([Name, Preconditions, Conclusions]));\n     *  - It is a bp rule, translate it to (abstractBp([Effects]))\n     *  During the process, clean them from the unallowed symbols (-, o, p).\n     */\n    convertAllRules(ArgRules) :-\n        defeasibleRules(DefeasibleRules),\n        strictRules(StrictRules, RulesIds),\n        ordinaryPremises(Premises),\n        axiomPremises(Axioms, AxiomsIds),\n        specialRules(SpecialRules),\n        utils::appendLists([DefeasibleRules, StrictRules, Premises, Axioms, SpecialRules], L),\n        convertAllRules(L, Rules), !,\n        findall(sup(X, Y), sup(X, Y), Sups),\n        utils::appendLists([Rules, AxiomsIds, RulesIds, Sups], ArgRules),\n        findall(_, (member(X, ArgRules), context_assert(X)), _).\n    defeasibleRules(DefeasibleRules) :-\n        findall([RuleName, Preconditions, Effect], (RuleName : Preconditions => Effect), DefeasibleRulesOld),\n        prologDefeasibleRules(DefeasibleRulesNew),\n        append(DefeasibleRulesOld, DefeasibleRulesNew, DefeasibleRules).\n    strictRules(CtrRules, Ids) :-\n        findall([RuleName, Preconditions, Effect], (RuleName : Preconditions -> Effect), StrictRulesOld),\n        prologStrictRules(StrictRulesNew),\n        append(StrictRulesOld, StrictRulesNew, StrictRules),\n        transpose(StrictRules, StrictRules, CtrRules),\n        findall(strict(RN), member([RN, _, _], CtrRules), Ids).\n    ordinaryPremises(Premises) :-\n        findall([RuleName, Effect], ((RuleName :=> Effect), atom(RuleName)), PremisesOld),\n        prologPremises(PremisesNew),\n        append(PremisesOld, PremisesNew, Premises).\n    axiomPremises(Axioms, Ids) :-\n        findall([RuleName, Effect], ((RuleName :-> Effect), atom(RuleName)), AxiomsOld),\n        prologAxioms(AxiomsNew),\n        append(AxiomsOld, AxiomsNew, Axioms),\n        findall(strict(RN), member([RN, _], Axioms), Ids).\n    specialRules(SpecialRules) :-\n        bpsNew(SpecialRules).\n    transpose(_, CtrRules, CtrRules) :- \\+ autoTransposition. \n    transpose([], CtrRules, CtrRules).\n    transpose([H|T], TempCtrRules, CtrRules) :-\n        transpose(T, TempCtrRules, CR),\n        findall(TrH, transposition(H, TrH), Tran),\n        mergeCtrRules(CR, Tran, CtrRules).\n    mergeCtrRules(All, ToMerge, X) :-\n        append(All, ToMerge, XT),\n        deduplicate(XT, X).\n    deduplicate([], []).\n    deduplicate([[RN,A,B]|T], X) :- deduplicate(T, TT), (member([RN,_,_], TT) -> X = TT; X = [[RN,A,B]|TT]). \n    transposition([Id, Prec, Effect], [Id, Prec, Effect]).\n    transposition([Id, Prec, Effect], [NewId, NewPrec ,XNegated]) :-\n        compound(Prec),\n        tuple_to_list(Prec, LPrec),!,\n        transposition_sequential(LPrec, LPrec, Effect, Id, [], NewPrec, XNegated, NewId).\n    transposition([Id, Prec, Effect], [NewId, EffectNegated ,XNegated]) :-\n        \\+ compound(Prec),\n        Prec \\== [],\n        prologEscape(Prec),\n        negate(Prec, XNegated),\n        negate(Effect, EffectNegated),\n        atom_concat(Id, '_i', NewId).\n    transposition_sequential(LPrec, [H|T], Effect, Id, Skipped, NewPrec, XNegated, NewId) :-\n        transposition_sequential(LPrec, T, Effect, Id, [H|Skipped], NewPrec, XNegated, NewId).\n    transposition_sequential(LPrec, [X|T], Effect, Id, Skipped, NewPrec, XNegated, NewId) :-\n        prologEscape(X),\n        append(Skipped, T, CleanedPrec),\n        negate(X, XNegated),\n        negate(Effect, EffectNegated),\n        list_to_tuple([EffectNegated|CleanedPrec], NewPrec),\n        newIdentifier(Skipped, Id, NewId).\n    newIdentifier(List, OldId, NewId) :-\n        modifier(List, Mod),\n        atom_concat(OldId, Mod, NewId).\n    modifier([], '_i').\n    modifier([_|Tail], Index):-\n        modifier(Tail, Index1),\n        atom_concat(Index1, 'i', Index).\n    negate(X, Arg) :-\n        functor(X, '-', _) -> (\n            arg(1, X, Arg));\n        functor(X, 'p', _) -> (\n            arg(1, X, PX),\n            (functor(PX, '-', _) -> (\n                arg(1, PX, PNX),\n                Arg = o(PNX)\n            );\n            Arg = o(-(PX))));\n        Arg = -(X).\n    prologEscape(X) :- \\+ functor(X, 'prolog', _), \\+ functor(X, '~', _).\n    /*\n     *   Standard rules (RuleName : Preconditions => Effects)\n     *   Special rules (RuleName : Effects)\n     */\n    convertAllRules([], []).\n    convertAllRules([[H,P,E]|T], [R|Rules]) :- convertRule(H, P, E, R), convertAllRules(T, Rules).\n    convertAllRules([[H,E]|T], [R|Rules]) :- convertRule(H, E, R), convertAllRules(T, Rules).\n    /*\n     *   Convert the given rule to the standard format\n     *   Example:\n     *   r2: followedGuidelines(X), doctor(X) => -liable(X)\n     *   rule([r2,[[followedGuidelines(X_e4149)],[doctor(X_e4149)]],[neg,liable(X_e4149)]]).\n     */\n    convertRule(RuleName, Preconditions, Effects, rule(List)) :-\n        tuple_to_list(Preconditions, Lprecond),\n        tuple_to_list(Effects, Leffects),\n        check_modifiers_in_list(preconditions, Lprecond, LprecondChecked),\n        check_modifiers_in_list(effects, Leffects, LeffectsChecked),\n        flatten_first_level(LeffectsChecked, LeffectsCheckedFlattened),\n        List = [RuleName, LprecondChecked, LeffectsCheckedFlattened].\n    /*\n     *   Convert the given special rule\n     *   Example:\n     *   bp(-liable(X)).\n     *   abastractBp([[neg, liable(X_e4149)]]).\n     */\n    convertRule(bps, Effects, abstractBp(Checked)) :-\n        functor(Effects, 'bp', _),\n        Effects =.. L,\n        removehead(L, LC),\n        check_modifiers_in_list(effects, LC, Checked).\n    convertRule(Name, Effects, premise([Name, LeffectsCheckedFlattened])) :-\n        tuple_to_list(Effects, Leffects),\n        check_modifiers_in_list(effects, Leffects, LeffectsChecked),\n        flatten_first_level(LeffectsChecked, LeffectsCheckedFlattened).\n    /*\n     *   Find negations(-), obligations(o), permissions(p) on a list of preconditions/effects and\n     *   raplace them with the assigned literal (neg, obl, perm)\n     */\n    check_modifiers_in_list(MODE, [], []).\n    check_modifiers_in_list(MODE, [H|T], L) :- H == [], L = [].\n    check_modifiers_in_list(MODE, [H|T], L) :- H \\== [],\n                                check_modifiers(H, LH),\n                                check_admissibility(MODE, H, LH),\n                                check_modifiers_in_list(MODE, T, LT),\n                                append([LH], LT, L).\n    check_admissibility(preconditions, H, LH) :-\n        \\+ defeasible_admissible(LH),\n        throw(['Premise  ', H, '  is not a well formed member of the argumentation language.']).\n    check_admissibility(effects, H, LH) :-\n        \\+ admissible(LH),\n        throw(['Conclusion  ', H, '  is not a well formed member of the argumentation language.']).\n    check_admissibility(_, _, _).\n    check_modifiers([], []).\n    check_modifiers(H, List) :-\n        functor(H, '-', _) -> (\n            arg(1, H, Arg),\n            check_modifiers(Arg, Lobl),\n            append([neg], Lobl, Lf),\n            List = Lf);\n        functor(H, 'o', _) -> (\n            arg(1, H, Arg),\n            check_modifiers(Arg, Lobl),\n            List = [obl|[Lobl]]);\n        functor(H, 'p', _) -> (\n            arg(1, H, Arg),\n            check_modifiers(Arg, Lper),\n            List = [perm|[Lper]]);\n        functor(H, '~', _) -> (\n            arg(1, H, Arg),\n            check_modifiers(Arg, Lper),\n            List = [unless|[Lper]]);\n        functor(H, 'bp', _) -> (\n            H =.. [_|Arg],\n            check_modifiers_in_list(effects, Arg, Lper),\n            List = [bp|[Lper]]);\n        List = [H].\n    /*\n     *   Convert the given tuple to list\n     */\n    tuple_to_list((A,B),L) :- tuple_to_list(A, La), tuple_to_list(B, Lb), append(La, Lb,L).\n    tuple_to_list(A,[A]) :- nonvar(A), A \\= (_ , _).\n    list_to_tuple([H], (H)).\n    list_to_tuple([H|T], (H,TT)) :- list_to_tuple(T,TT).\n    /*\n     *   Replace all the occurences of a given element with the given argument\n     */\n    replace(_, _, [],[]).\n    replace(O, R, [O|T], [R|T2]) :- replace(O, R, T, T2).\n    replace(O, R, [H|T], [H|T2]) :- H \\= O, replace(O, R, T, T2).\n    flatten_first_level([X], X).\n    flatten_first_level.\n    removehead([_|Tail], Tail).\n    in(A, A) :- nonvar(A), A \\= (_ , _).\n    in(A, (A, _)).\n    in(A, (_ , Cs)) :- in(A, Cs).\n    defeasible_admissible([unless, Term]) :- admissible(Term).\n    defeasible_admissible(Term) :- admissible(Term).\n    admissible([neg, bp, Term]) :- admissible_terms_complete(Term).\n    admissible([bp, Term]) :- admissible_terms_complete(Term).\n    admissible([neg, Term]) :- admissible_term(Term).\n    admissible([obl, [Term]]) :- admissible_term(Term).\n    admissible([obl, [neg, Term]]) :- admissible_term(Term).\n    admissible([neg, obl, [Term]]) :- admissible_term(Term).\n    admissible([neg, obl, [neg, Term]]) :- admissible_term(Term).\n    admissible([perm, [Term]]) :- admissible_term(Term).\n    admissible([perm, [neg, Term]]) :- admissible_term(Term).\n    admissible([Term]) :- admissible_term(Term).\n    admissible_term(Term) :-\n        atomic(Term),\n        Term \\== neg,\n        Term \\== obl,\n        Term \\== perm,\n        Term \\== unless,\n        Term \\== bp.\n    admissible_term(Term) :- var(Term).\n    admissible_term(Term) :-\n        compound(Term),\n        \\+ functor(Term, 'o', _),\n        \\+ functor(Term, 'p', _),\n        \\+ functor(Term, '-', _),\n        \\+ functor(Term, '~', _),\n        \\+ functor(Term, 'bp', _),\n        Term =.. [_|Args],\n        admissible_terms(Args).\n    admissible_terms([]).\n    admissible_terms([H|T]) :-\n        admissible_term(H),\n        admissible_terms(T).\n    admissible_terms_complete([]).\n    admissible_terms_complete([H|T]) :-\n        admissible(H),\n        admissible_terms_complete(T).\n        ")}Di.$metadata$={kind:y,simpleName:"RuleTranslator",interfaces:[]};var Ui=null;function wi(){return null===Ui&&new Di,Ui}function ji(){Ei=this,this.theoryCode=yt("\n    statementLabelling :-\n        findall(_, (\n            context_check(in([_, _, Conc, _, _])),\n            \\+ context_check(statIn(Conc)),\n            context_assert(statIn(Conc))\n        ), _),\n        findall(_, (\n            context_check(out([_, _, Conc, _, _])),\n            \\+ context_check(statIn(Conc)),\n            \\+ context_check(statOut(Conc)),\n            context_assert(statOut(Conc))\n        ), _),\n        findall(_, (\n            context_check(und([_, _, Conc, _, _])),\n            \\+ context_check(statIn(Conc)),\n            \\+ context_check(statOut(Conc)),\n            \\+ context_check(statUnd(Conc)),\n            context_assert(statUnd(Conc))\n        ), _).\n        ")}ji.$metadata$={kind:y,simpleName:"StatementLabelling",interfaces:[]};var Ei=null;function zi(){return null===Ei&&new ji,Ei}function Gi(){Xi=this,this.theoryCode=yt("\n    superiorArgument(A, B) :- superiorArgumentSupportBuffered(A, B, _).\n    superiorArgument(A, B, SupSet) :- superiorArgumentSupportBuffered(A, B, SupSet).\n    superiorArgumentSupportBuffered(A, B, SupSet) :-\n        context_check(superior(A, B, SupSet, true)), !.\n    superiorArgumentSupportBuffered(A, B, SupSet) :-\n        context_check(superior(A, B, SupSet, false)),\n        fail, !.\n    superiorArgumentSupportBuffered(A, B, SupSet) :-\n        \\+ context_check(superior(A, B, _, _)),\n        superiorArgumentSupport(A, B, SupSet),\n        context_assert(superior(A, B, SupSet, true)), !.\n    superiorArgumentSupportBuffered(A, B, SupSet) :-\n        \\+ cache_check(superior(A, B, _, _)),\n        context_assert(superior(A, B, [], false)),\n        fail, !.\n    superiorArgumentSupport([_, _, _, _, [LastDefRulesA, DefRulesA, DefPremisesA]], [_, _, _, _, [LastDefRulesB, DefRulesB, DefPremisesB]], SupSet) :-\n    \tsuperiorArgumentSupport(LastDefRulesA, DefRulesA, DefPremisesA, LastDefRulesB, DefRulesB, DefPremisesB, SupSet).\n    superiorArgumentSupport(LastDefRulesA, _, DefPremisesA, LastDefRulesB, _, DefPremisesB, SupSet) :-\n        orderingPrinciple(last),\n    \tsuperior(LastDefRulesA, DefPremisesA, LastDefRulesB, DefPremisesB, SupSet).\n    superiorArgumentSupport(_, DefRulesA, DefPremisesA, _, DefRulesB, DefPremisesB, SupSet) :-\n        orderingPrinciple(weakest),\n    \tsuperior(DefRulesA, DefPremisesA, DefRulesB, DefPremisesB, SupSet).\n    superior([], PremisesA, [], PremisesB, SupSet) :-\n    \tweaker(PremisesB, PremisesA, SupSet).\n    superior(DefRulesA, _, DefRulesB, _, SupSet) :-\n    \torderingPrinciple(last),\n    \t(DefRulesA \\== []; DefRulesB \\== []),\n    \tweaker(DefRulesB, DefRulesA, SupSet).\n    superior(DefRulesA, [], DefRulesB, [], SupSet) :-\n    \torderingPrinciple(weakest),\n    \tweaker(DefRulesB, DefRulesA, SupSet).\n    superior(DefRulesA, PremisesA, DefRulesB, PremisesB, SupSet) :-\n    \torderingPrinciple(weakest),\n    \t(DefRulesA \\== []; DefRulesB \\== []),\n    \t(PremisesA \\== []; PremisesB \\== []),\n    \tweaker(DefRulesB, DefRulesA, SupSetA),\n    \tweaker(PremisesB, PremisesA, SupSetB),\n    \tutils::appendLists([SupSetA, SupSetB], SupSet).\n    weaker(RulesA, [], []) :-\n    \tRulesA \\== [].\n    weaker(RulesA, RulesB, SupSet) :-\n    \tRulesA \\== [],\n    \tRulesB \\== [],\n    \torderingComparator(elitist),\n    \tmember(Rule, RulesA),\n    \tallStronger(Rule, RulesB, SupSet), !.\n    weaker(RulesA, RulesB, SupSet) :-\n    \tRulesA \\== [],\n    \tRulesB \\== [],\n    \torderingComparator(democrat),\n    \tweakerDemo(RulesA, RulesB, SupSet).\n    weaker(RulesA, RulesB, [sup(X, W)]) :-\n    \tRulesA \\== [],\n    \tRulesB \\== [],\n    \torderingComparator(normal),\n    \tmember(W, RulesA),\n    \tmember(X, RulesB),\n    \tcontext_check(sup(X, W)), !.\n    weakerDemo([], _, []).\n    weakerDemo([H|T], Rules, [Sup|SupSet]) :-\n    \tsingleStronger(H, Rules, Sup),\n    \tweakerDemo(T, Rules, SupSet).\n    singleStronger(Target, Rules, sup(Rule, Target)) :-\n    \tmember(Rule, Rules),\n    \tcontext_check(sup(Rule, Target)), !.\n    allStronger(_, [], []).\n    allStronger(Target, [Rule|Rules], [sup(Rule, Target)|SupSet]) :-\n    \tcontext_check(sup(Rule, Target)),\n    \tallStronger(Target, Rules, SupSet).\n        ")}Gi.$metadata$={kind:y,simpleName:"SuperiorityRelation",interfaces:[]};var Xi=null;function qi(){return null===Xi&&new Gi,Xi}function Hi(){Mi=this,this.theoryCode=yt("\n    writeList([]) :- nl.\n    writeList([X|Others]) :-\n    \twrite(X),\n    \twriteList(Others).\n    writeListNl([]).\n    writeListNl([X|Others]) :-\n    \twrite(X),nl,\n    \twriteListNl(Others).\n    sortDistinct(List, Sorted) :-\n        deduplicate(List, Deduplicated),\n        sort(Deduplicated, Sorted).\n    deduplicate([], []).\n    deduplicate(List, Output) :-\n        List \\== [],\n        setof(X, member(X, List), Output).\n    sort(List,Sorted) :- q_sort(List, [], Sorted).\n    q_sort([], Acc, Acc).\n    q_sort([H|T], Acc, Sorted) :-\n    \tpivoting(H, T, L1, L2),\n    \tq_sort(L1, Acc, Sorted1),\n    \tq_sort(L2, [H|Sorted1], Sorted).\n    pivoting(H,[],[],[]).\n    pivoting(H, [X|T], [X|L], G) :-\n        H @>= X,\n        pivoting(H, T, L, G).\n    pivoting(H, [X|T], L, [X|G]) :-\n        X @> H,\n        pivoting(H, T, L, G).\n    subtract([], _, []).\n    subtract([Head|Tail], L2, L3) :-\n            member(Head, L2), !,\n            subtract(Tail, L2, L3).\n    subtract([Head|Tail1], L2, [Head|Tail3]) :-\n            subtract(Tail1, L2, Tail3).\n    isEmptyList([]).\n    appendLists([], []).\n    appendLists([H|T], R) :-\n        appendLists(T, AT),\n        append(H, AT, R).\n    search(F, L, S) :-\n       between(1, L, N),\n       functor(S, F, N),\n       call(S).\n    between(N, M, K) :- N < M, K = N.\n    between(N, M, K) :- N == M, !, K = N.\n    between(N, M, K) :- N < M, N1 is N+1, between(N1, M, K).\n    recoverGraph(Args, Attacks, Supports) :-\n            findall(X, context_check(argument(X)), TempArgs),\n            findall((T, A, B, C), context_check(attack(T, A, B, C)), TempAttacks),\n            findall((A, B), context_check(support(A, B)), TempSupports),\n            utils::sort(TempArgs, Args),\n            utils::sort(TempAttacks, Attacks),\n            utils::sort(TempSupports, Supports).\n    recoverArgumentLabelling(ArgsIn, ArgsOut, ArgsUnd) :-\n            findall(X, context_check(in(X)), TempArgsIn),\n            findall(X, context_check(out(X)), TempArgsOut),\n            findall(X, context_check(und(X)), TempArgsUnd),\n            utils::sort(TempArgsIn, ArgsIn),\n            utils::sort(TempArgsOut, ArgsOut),\n            utils::sort(TempArgsUnd, ArgsUnd).\n    recoverStatementLabelling(In, Out, Und) :-\n            findall(X, context_check(statIn(X)), TempIn),\n            findall(X, context_check(statOut(X)), TempOut),\n            findall(X, context_check(statUnd(X)), TempUnd),\n            utils::sort(TempIn, In),\n            utils::sort(TempOut, Out),\n            utils::sort(TempUnd, Und).\n        ")}Hi.$metadata$={kind:y,simpleName:"Utils",interfaces:[]};var Mi=null;function Fi(){return null===Mi&&new Hi,Mi}function Wi(){Vi=this,er.call(this)}Object.defineProperty(Wi.prototype,"prologRawTheory",{configurable:!0,get:function(){return Li().theoryCode}}),Wi.$metadata$={kind:y,simpleName:"StructuredMode",interfaces:[er]};var Vi=null;function Yi(){return null===Vi&&new Wi,Vi}function Qi(){Ki=this,ir.call(this)}Object.defineProperty(Qi.prototype,"prologRawTheory",{configurable:!0,get:function(){return bi().theoryCode}}),Qi.$metadata$={kind:y,simpleName:"Debug",interfaces:[ir]};var Ki=null;function Zi(){return null===Ki&&new Qi,Ki}function Ji(){ta=this,ar.call(this)}Object.defineProperty(Ji.prototype,"prologRawTheory",{configurable:!0,get:function(){return qi().theoryCode}}),Ji.$metadata$={kind:y,simpleName:"SuperiorityRelation",interfaces:[ar]};var ta=null;function ea(){return null===ta&&new Ji,ta}function na(){ra=this,fr.call(this)}Object.defineProperty(na.prototype,"prologRawTheory",{configurable:!0,get:function(){return Fi().theoryCode}}),na.$metadata$={kind:y,simpleName:"Utils",interfaces:[fr]};var ra=null;function oa(){return null===ra&&new na,ra}Object.defineProperty(Ft,"Companion",{get:Qt});var ia=t.it||(t.it={}),aa=ia.unibo||(ia.unibo={}),sa=aa.tuprolog||(aa.tuprolog={}),ua=sa.argumentation||(sa.argumentation={}),pa=ua.core||(ua.core={});pa.Arg2pSolver=Ft,pa.arg2p=function(){return Qt().of_gdqvf0$(_([Zr(),new fe,new se]),_([oa(),Zi(),Go(),Ge(),He(),oo(),so(),lo(),mo(),ho(),Ao(),So(),Io(),Do(),jo(),eo(),Yi(),ea(),Co(),To()]))};var la=pa.dsl||(pa.dsl={});la.PrologWithArgumentation=Kt,la.PrologWithArgumentationImpl=Zt,la.arg2pScope_c8pr0v$=function(t){return t(new Zt)};var ca=pa.libs||(pa.libs={});ca.ArgLibrary=Jt,ca.BaseArgLibrary=te,ca.UnionArgLibrary=ee,ca.RawPrologContent=ne,ca.LazyRawPrologContent=re,ca.Loadable=oe,ca.ArgsFlag=ie,ca.PrimitiveWithSignature=ae,se.CacheAssert=ue,se.CacheRetract=pe,se.CacheGet=le;var da=ca.basic||(ca.basic={});da.Cache=se,fe.DynamicCacheReset=me,fe.DynamicCacheSelected=ge,fe.DynamicCacheCheckout=ye,fe.DynamicCacheBranch=he,fe.DynamicCacheAssert=_e,fe.DynamicCacheRetract=be,fe.DynamicCacheGet=Ae,fe.DynamicCacheGetIndexed=Te,da.Context=fe,Se.AbstractWithLib=ve,Se.WithLib=Pe,Se.WithLibInNewContext=Be,da.DynamicLoader=Se,da.EngineInterfaceBase=xe,Object.defineProperty(Le,"Companion",{get:we}),da.FlagsBuilder=Le;var fa=ca.extra||(ca.extra={});Object.defineProperty(fa,"MetaInterpreter",{get:Ge}),Object.defineProperty(fa,"ModuleCalls",{get:He}),Object.defineProperty(fa,"ModulesPath",{get:We}),Object.defineProperty(fa,"ModuleCall",{get:Je});var ma=ca.graph||(ca.graph={});ma.AbstractModeBase=tn,Object.defineProperty(ma,"GraphExtension",{get:rn}),Object.defineProperty(ma,"ArgumentLabellingMode",{get:sn}),Object.defineProperty(ma,"StatementLabellingMode",{get:ln}),Object.defineProperty(ma,"GraphBuildMode",{get:fn});var ga=ma.builder||(ma.builder={});ga.ArgumentationGraphBuilderBase=mn;var ya=ma.extension||(ma.extension={});ya.AttackRestrictionHandlerBase=gn,ya.BpMetaGraphHandlerBase=yn,ya.DefeasiblePreferencesHandlerBase=hn,ya.GenericDefeasiblePreferencesHandlerBase=_n,ya.StrictPreferencesHandlerBase=bn;var ha=ma.labelling||(ma.labelling={});ha.BpCompleteLabellerBase=An,ha.BpLabellerBase=$n,ha.BpPartialLabellerBase=On,ha.CompleteLabellerBase=Tn,ha.GroundedLabellerBase=Rn,ha.StatementLabellerBase=Nn;var _a=ca.language||(ca.language={});_a.RuleParserBase=Sn,Object.defineProperty(_a,"AutoTransposition",{get:Cn}),Object.defineProperty(_a,"PrologStrictCompatibility",{get:In}),Object.defineProperty(_a,"ConversionUtils",{get:Un}),Object.defineProperty(_a,"StrictRules",{get:En}),Object.defineProperty(_a,"Axioms",{get:qn}),Object.defineProperty(_a,"Premises",{get:Wn}),Object.defineProperty(_a,"DefeasibleRules",{get:Qn}),Object.defineProperty(_a,"Bps",{get:tr});var ba=ca.structured||(ca.structured={});ba.StructuredModeBase=er,Object.defineProperty(ba,"QueryMode",{get:or});var Aa=ca.utils||(ca.utils={});Aa.DebugBase=ir,Aa.SuperiorityRelationBase=ar,Object.defineProperty(Aa,"OrderingPrinciple",{get:pr}),Object.defineProperty(Aa,"OrderingComparator",{get:dr}),Aa.UtilsBase=fr;var $a=pa.mining||(pa.mining={});$a.mineGraph=function(t,e){var n=Or(t,e);return Hr().of_mf1h1a$(Br(t,e,n),Nr(t,e,n),kr(t,e,n))},$a.mineArguments=Or,$a.mineAttacks=Nr,$a.mineSupports=kr,$a.mineLabels=Br,Object.defineProperty(Ir,"Companion",{get:Er});var Oa=pa.model||(pa.model={});Oa.Argument=Ir,Oa.Attack=zr,Object.defineProperty(Gr,"Companion",{get:Hr}),Oa.Graph=Gr,Oa.LabelledArgument=Mr,Oa.ArgItem=Fr,Oa.Premise=Wr,Oa.Rule=Vr,Oa.Support=Yr,Object.defineProperty(da,"EngineInterface",{get:Zr}),Object.defineProperty(ma,"AbstractMode",{get:eo}),Object.defineProperty(ga,"ArgumentationGraphBuilder",{get:oo}),Object.defineProperty(ya,"AttackRestrictionHandler",{get:so}),Object.defineProperty(ya,"BpMetaGraphHandler",{get:lo}),Object.defineProperty(ya,"DefeasiblePreferencesHandler",{get:mo}),Object.defineProperty(ya,"GenericDefeasiblePreferencesHandler",{get:ho}),Object.defineProperty(ya,"StrictPreferencesHandler",{get:Ao}),Object.defineProperty(ha,"BpCompleteLabeller",{get:To}),Object.defineProperty(ha,"BpLabeller",{get:So}),Object.defineProperty(ha,"BpPartialLabeller",{get:Co}),Object.defineProperty(ha,"CompleteLabeller",{get:Io}),Object.defineProperty(ha,"GroundedLabeller",{get:Do}),Object.defineProperty(ha,"StatementLabeller",{get:jo}),Object.defineProperty(_a,"RuleParser",{get:Go});var Ta=ca.sources||(ca.sources={});return Object.defineProperty(Ta,"AbstractMode",{get:Ho}),Object.defineProperty(Ta,"ArgumentationEngineInterface",{get:Wo}),Object.defineProperty(Ta,"ArgumentationGraph",{get:Qo}),Object.defineProperty(Ta,"AttackRestriction",{get:Jo}),Object.defineProperty(Ta,"Bp",{get:ni}),Object.defineProperty(Ta,"BpGrounded",{get:ii}),Object.defineProperty(Ta,"BpGroundedComplete",{get:ui}),Object.defineProperty(Ta,"BpGroundedPartial",{get:ci}),Object.defineProperty(Ta,"BpPartialComplete",{get:function(){return null===fi&&new di,fi}}),Object.defineProperty(Ta,"Complete",{get:yi}),Object.defineProperty(Ta,"Debug",{get:bi}),Object.defineProperty(Ta,"DefPreferences",{get:Oi}),Object.defineProperty(Ta,"GenericDefPreferences",{get:Ni}),Object.defineProperty(Ta,"Grounded",{get:ki}),Object.defineProperty(Ta,"Preferences",{get:Bi}),Object.defineProperty(Ta,"QueryMode",{get:Li}),Object.defineProperty(Ta,"RuleTranslator",{get:wi}),Object.defineProperty(Ta,"StatementLabelling",{get:zi}),Object.defineProperty(Ta,"SuperiorityRelation",{get:qi}),Object.defineProperty(Ta,"Utils",{get:Fi}),Object.defineProperty(ba,"StructuredMode",{get:Yi}),Object.defineProperty(Aa,"Debug",{get:Zi}),Object.defineProperty(Aa,"SuperiorityRelation",{get:ea}),Object.defineProperty(Aa,"Utils",{get:oa}),Vt.prototype.to2pLibraries=Ft.prototype.to2pLibraries,Vt.prototype.operators=Ft.prototype.operators,Kt.prototype.call1=O.prototype.call1,Object.defineProperty(Kt.prototype,"A",Object.getOwnPropertyDescriptor(O.prototype,"A")),Object.defineProperty(Kt.prototype,"B",Object.getOwnPropertyDescriptor(O.prototype,"B")),Object.defineProperty(Kt.prototype,"C",Object.getOwnPropertyDescriptor(O.prototype,"C")),Object.defineProperty(Kt.prototype,"D",Object.getOwnPropertyDescriptor(O.prototype,"D")),Object.defineProperty(Kt.prototype,"E",Object.getOwnPropertyDescriptor(O.prototype,"E")),Object.defineProperty(Kt.prototype,"F",Object.getOwnPropertyDescriptor(O.prototype,"F")),Object.defineProperty(Kt.prototype,"G",Object.getOwnPropertyDescriptor(O.prototype,"G")),Object.defineProperty(Kt.prototype,"H",Object.getOwnPropertyDescriptor(O.prototype,"H")),Object.defineProperty(Kt.prototype,"I",Object.getOwnPropertyDescriptor(O.prototype,"I")),Object.defineProperty(Kt.prototype,"J",Object.getOwnPropertyDescriptor(O.prototype,"J")),Object.defineProperty(Kt.prototype,"K",Object.getOwnPropertyDescriptor(O.prototype,"K")),Object.defineProperty(Kt.prototype,"L",Object.getOwnPropertyDescriptor(O.prototype,"L")),Object.defineProperty(Kt.prototype,"M",Object.getOwnPropertyDescriptor(O.prototype,"M")),Object.defineProperty(Kt.prototype,"N",Object.getOwnPropertyDescriptor(O.prototype,"N")),Object.defineProperty(Kt.prototype,"O",Object.getOwnPropertyDescriptor(O.prototype,"O")),Object.defineProperty(Kt.prototype,"P",Object.getOwnPropertyDescriptor(O.prototype,"P")),Object.defineProperty(Kt.prototype,"Q",Object.getOwnPropertyDescriptor(O.prototype,"Q")),Object.defineProperty(Kt.prototype,"R",Object.getOwnPropertyDescriptor(O.prototype,"R")),Object.defineProperty(Kt.prototype,"S",Object.getOwnPropertyDescriptor(O.prototype,"S")),Object.defineProperty(Kt.prototype,"T",Object.getOwnPropertyDescriptor(O.prototype,"T")),Object.defineProperty(Kt.prototype,"U",Object.getOwnPropertyDescriptor(O.prototype,"U")),Object.defineProperty(Kt.prototype,"V",Object.getOwnPropertyDescriptor(O.prototype,"V")),Object.defineProperty(Kt.prototype,"W",Object.getOwnPropertyDescriptor(O.prototype,"W")),Object.defineProperty(Kt.prototype,"X",Object.getOwnPropertyDescriptor(O.prototype,"X")),Object.defineProperty(Kt.prototype,"Y",Object.getOwnPropertyDescriptor(O.prototype,"Y")),Object.defineProperty(Kt.prototype,"Z",Object.getOwnPropertyDescriptor(O.prototype,"Z")),Object.defineProperty(Kt.prototype,"_",Object.getOwnPropertyDescriptor(O.prototype,"_")),Object.defineProperty(Kt.prototype,"at_end_of_stream",Object.getOwnPropertyDescriptor(O.prototype,"at_end_of_stream")),Object.defineProperty(Kt.prototype,"cut",Object.getOwnPropertyDescriptor(O.prototype,"cut")),Object.defineProperty(Kt.prototype,"halt",Object.getOwnPropertyDescriptor(O.prototype,"halt")),Object.defineProperty(Kt.prototype,"nl",Object.getOwnPropertyDescriptor(O.prototype,"nl")),Object.defineProperty(Kt.prototype,"repeat",Object.getOwnPropertyDescriptor(O.prototype,"repeat")),Kt.prototype.abolish1=O.prototype.abolish1,Kt.prototype.append3=O.prototype.append3,Kt.prototype.arg3=O.prototype.arg3,Kt.prototype.assert1=O.prototype.assert1,Kt.prototype.asserta1=O.prototype.asserta1,Kt.prototype.assertz1=O.prototype.assertz1,Kt.prototype.at_end_of_stream1=O.prototype.at_end_of_stream1,Kt.prototype.atom1=O.prototype.atom1,Kt.prototype.atom_chars2=O.prototype.atom_chars2,Kt.prototype.atom_codes2=O.prototype.atom_codes2,Kt.prototype.atom_concat3=O.prototype.atom_concat3,Kt.prototype.atom_length2=O.prototype.atom_length2,Kt.prototype.atomic1=O.prototype.atomic1,Kt.prototype.bagof3=O.prototype.bagof3,Kt.prototype.between3=O.prototype.between3,Kt.prototype.blockOf=O.prototype.blockOf,Kt.prototype.callable1=O.prototype.callable1,Kt.prototype.catch3=O.prototype.catch3,Kt.prototype.char_code2=O.prototype.char_code2,Kt.prototype.clause_fzbqwd$=O.prototype.clause_fzbqwd$,Kt.prototype.clause2=O.prototype.clause2,Kt.prototype.compound1=O.prototype.compound1,Kt.prototype.consOfAny=O.prototype.consOfAny,Kt.prototype.consult1=O.prototype.consult1,Kt.prototype.substitutionContains=O.prototype.substitutionContains,Kt.prototype.copy_term2=O.prototype.copy_term2,Kt.prototype.current_flag2=O.prototype.current_flag2,Kt.prototype.current_op3=O.prototype.current_op3,Kt.prototype.current_prolog_flag2=O.prototype.current_prolog_flag2,Kt.prototype.directive=O.prototype.directive,Kt.prototype.directiveOfAny=O.prototype.directiveOfAny,Kt.prototype.dynamic1=O.prototype.dynamic1,Kt.prototype.fact=O.prototype.fact,Kt.prototype.factOfAny=O.prototype.factOfAny,Kt.prototype.findall3=O.prototype.findall3,Kt.prototype.float1=O.prototype.float1,Kt.prototype.functor3=O.prototype.functor3,Kt.prototype.substitutionGet=O.prototype.substitutionGet,Kt.prototype.ground1=O.prototype.ground1,Kt.prototype.include1=O.prototype.include1,Kt.prototype.initialization1=O.prototype.initialization1,Kt.prototype.integer1=O.prototype.integer1,Kt.prototype.list$default=O.prototype.list$default,Kt.prototype.listOfAny=O.prototype.listOfAny,Kt.prototype.load1=O.prototype.load1,Kt.prototype.matchAny$default=O.prototype.matchAny$default,Kt.prototype.match=O.prototype.match,Kt.prototype.matchWithOccurCheck=O.prototype.matchWithOccurCheck,Kt.prototype.member2=O.prototype.member2,Kt.prototype.merge=O.prototype.merge,Kt.prototype.mguAny$default=O.prototype.mguAny$default,Kt.prototype.mgu=O.prototype.mgu,Kt.prototype.naf1=O.prototype.naf1,Kt.prototype.natural=O.prototype.natural,Kt.prototype.nonvar1=O.prototype.nonvar1,Kt.prototype.not1=O.prototype.not1,Kt.prototype.number1=O.prototype.number1,Kt.prototype.number_chars2=O.prototype.number_chars2,Kt.prototype.number_codes2=O.prototype.number_codes2,Kt.prototype.op3=O.prototype.op3,Kt.prototype.retract1=O.prototype.retract1,Kt.prototype.retractall1=O.prototype.retractall1,Kt.prototype.rule=O.prototype.rule,Kt.prototype.scope=O.prototype.scope,Kt.prototype.set_flag2=O.prototype.set_flag2,Kt.prototype.set_prolog_flag2=O.prototype.set_prolog_flag2,Kt.prototype.setof3=O.prototype.setof3,Kt.prototype.solve1=O.prototype.solve1,Kt.prototype.static1=O.prototype.static1,Kt.prototype.structOfAny=O.prototype.structOfAny,Kt.prototype.sub_atom5=O.prototype.sub_atom5,Kt.prototype.theory=O.prototype.theory,Kt.prototype.theoryOf=O.prototype.theoryOf,Kt.prototype.theoryOfIterable=O.prototype.theoryOfIterable,Kt.prototype.theoryOfSequence=O.prototype.theoryOfSequence,Kt.prototype.throw1=O.prototype.throw1,Kt.prototype.tupleOfAny=O.prototype.tupleOfAny,Kt.prototype.unifyAny$default=O.prototype.unifyAny$default,Kt.prototype.unify=O.prototype.unify,Kt.prototype.unifyWithOccurCheck=O.prototype.unifyWithOccurCheck,Kt.prototype.var1=O.prototype.var1,Kt.prototype.write1=O.prototype.write1,Kt.prototype.neq2=O.prototype.neq2,Kt.prototype.nid2=O.prototype.nid2,Kt.prototype.power=O.prototype.power,Kt.prototype.eq2=O.prototype.eq2,Kt.prototype.arithNeq2=O.prototype.arithNeq2,Kt.prototype.id2=O.prototype.id2,Kt.prototype.arithEq2=O.prototype.arithEq2,Kt.prototype.pow=O.prototype.pow,Kt.prototype.anyAnd=O.prototype.anyAnd,Kt.prototype.substitutionContainsKey=O.prototype.substitutionContainsKey,Kt.prototype.substitutionContainsValue=O.prototype.substitutionContainsValue,Kt.prototype.anyDiv=O.prototype.anyDiv,Kt.prototype.anyEqualsTo=O.prototype.anyEqualsTo,Kt.prototype.anyGreaterThan=O.prototype.anyGreaterThan,Kt.prototype.anyGreaterThanOrEqualsTo=O.prototype.anyGreaterThanOrEqualsTo,Kt.prototype.anyIf=O.prototype.anyIf,Kt.prototype.anyIfVararg=O.prototype.anyIfVararg,Kt.prototype.anyImpliedBy=O.prototype.anyImpliedBy,Kt.prototype.anyImpliedByVararg=O.prototype.anyImpliedByVararg,Kt.prototype.anyIntDiv=O.prototype.anyIntDiv,Kt.prototype.stringInvoke=O.prototype.stringInvoke,Kt.prototype.anyIs=O.prototype.anyIs,Kt.prototype.anyLowerThan=O.prototype.anyLowerThan,Kt.prototype.anyLowerThanOrEqualsTo=O.prototype.anyLowerThanOrEqualsTo,Kt.prototype.anyMatches=O.prototype.anyMatches,Kt.prototype.anyMguWith=O.prototype.anyMguWith,Kt.prototype.anyMinus=O.prototype.anyMinus,Kt.prototype.anyNonGreaterThan=O.prototype.anyNonGreaterThan,Kt.prototype.anyNonLowerThan=O.prototype.anyNonLowerThan,Kt.prototype.anyNotEqualsTo=O.prototype.anyNotEqualsTo,Kt.prototype.anyOr=O.prototype.anyOr,Kt.prototype.anyPlus=O.prototype.anyPlus,Kt.prototype.anyPow=O.prototype.anyPow,Kt.prototype.anyRem=O.prototype.anyRem,Kt.prototype.anySup=O.prototype.anySup,Kt.prototype.anyThen=O.prototype.anyThen,Kt.prototype.anyTimes=O.prototype.anyTimes,Kt.prototype.varTo=O.prototype.varTo,Kt.prototype.stringTo=O.prototype.stringTo,Kt.prototype.anyUnifyWith=O.prototype.anyUnifyWith,Kt.prototype.univ2=O.prototype.univ2,Kt.prototype.list=O.prototype.list,Kt.prototype.listFrom=O.prototype.listFrom,Kt.prototype.listFromIterable=O.prototype.listFromIterable,Kt.prototype.listFromSequence=O.prototype.listFromSequence,Kt.prototype.matchAny=O.prototype.matchAny,Kt.prototype.mguAny=O.prototype.mguAny,Kt.prototype.mguWithOccurCheck=O.prototype.mguWithOccurCheck,Kt.prototype.unifyAny=O.prototype.unifyAny,Zt.prototype.call_k9kufj$=Kt.prototype.call_k9kufj$,Zt.prototype.matchAny$default=Kt.prototype.matchAny$default,Zt.prototype.mguAny$default=Kt.prototype.mguAny$default,Zt.prototype.theory=Kt.prototype.theory,Zt.prototype.theoryOf=Kt.prototype.theoryOf,Zt.prototype.theoryOfIterable=Kt.prototype.theoryOfIterable,Zt.prototype.theoryOfSequence=Kt.prototype.theoryOfSequence,Zt.prototype.unifyAny$default=Kt.prototype.unifyAny$default,Zt.prototype.anyMatches=Kt.prototype.anyMatches,Zt.prototype.anyMguWith=Kt.prototype.anyMguWith,Zt.prototype.anyUnifyWith=Kt.prototype.anyUnifyWith,Zt.prototype.list=Kt.prototype.list,Zt.prototype.listFromSequence=Kt.prototype.listFromSequence,Zt.prototype.listFrom=Kt.prototype.listFrom,Zt.prototype.listFromIterable=Kt.prototype.listFromIterable,Zt.prototype.matchAny=Kt.prototype.matchAny,Zt.prototype.mguWithOccurCheck=Kt.prototype.mguWithOccurCheck,Zt.prototype.mguAny=Kt.prototype.mguAny,Zt.prototype.unifyAny=Kt.prototype.unifyAny,te.prototype.flags=Jt.prototype.flags,te.prototype.content=Jt.prototype.content,xe.prototype.flags=Jt.prototype.flags,xe.prototype.content=Jt.prototype.content,tn.prototype.flags=Jt.prototype.flags,tn.prototype.content=Jt.prototype.content,mn.prototype.flags=Jt.prototype.flags,mn.prototype.content=Jt.prototype.content,gn.prototype.flags=Jt.prototype.flags,gn.prototype.content=Jt.prototype.content,yn.prototype.flags=Jt.prototype.flags,yn.prototype.content=Jt.prototype.content,hn.prototype.flags=Jt.prototype.flags,hn.prototype.content=Jt.prototype.content,_n.prototype.flags=Jt.prototype.flags,_n.prototype.content=Jt.prototype.content,bn.prototype.flags=Jt.prototype.flags,bn.prototype.content=Jt.prototype.content,An.prototype.flags=Jt.prototype.flags,An.prototype.content=Jt.prototype.content,$n.prototype.flags=Jt.prototype.flags,$n.prototype.content=Jt.prototype.content,On.prototype.flags=Jt.prototype.flags,On.prototype.content=Jt.prototype.content,Tn.prototype.flags=Jt.prototype.flags,Tn.prototype.content=Jt.prototype.content,Rn.prototype.flags=Jt.prototype.flags,Rn.prototype.content=Jt.prototype.content,Nn.prototype.flags=Jt.prototype.flags,Nn.prototype.content=Jt.prototype.content,Sn.prototype.flags=Jt.prototype.flags,Sn.prototype.content=Jt.prototype.content,er.prototype.flags=Jt.prototype.flags,er.prototype.content=Jt.prototype.content,ir.prototype.flags=Jt.prototype.flags,ir.prototype.content=Jt.prototype.content,ar.prototype.flags=Jt.prototype.flags,ar.prototype.content=Jt.prototype.content,fr.prototype.flags=Jt.prototype.flags,fr.prototype.content=Jt.prototype.content,Wr.prototype.toTerm=Fr.prototype.toTerm,Vr.prototype.toTerm=Fr.prototype.toTerm,e.defineModule("@tuprolog/arg2p-core",t),t})?r.apply(e,o):r)||(t.exports=i)},3654:()=>{}}]);